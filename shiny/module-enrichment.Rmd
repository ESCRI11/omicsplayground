Enrichment {data-orientation=rows}
================================================================================

Inputs {.sidebar data-width=250}
--------------------------------------------------------------------------------

<br>
**Enrichment Analysis**.

<br><br>

```{r}
selectInput("gs_contrast","Comparison:", choices=NULL)
selectInput("gs_features","Gene set collection:", choices=NULL, multiple=FALSE)
FDR.VALUES2 = c(1e-9,1e-6,1e-3,0.01,0.05,0.1,0.2,0.5,1)
fillRow( flex=c(1,1),
        selectInput("gs_fdr","FDR", choices=FDR.VALUES2, selected=0.2),
        selectInput("gs_lfc","logFC threshold", choices=c(0,0.2,0.5,1,2,5), selected=0.2)
        )
br();br();br();br();
checkboxInput('gs_ungroup','ungroup',FALSE)
checkboxInput('gs_top10','top 10',FALSE)

br();br();br();br();
if(PRO.VERSION) textInput("gs_filter","Filter:")
GSET.DEFAULTMETHODS = c("fisher","gsva","camera","fgsea")
GSET.DEFAULTMETHODS = c("fisher","gsva","camera")
GSET.DEFAULTMETHODS = c("gsva","camera","fgsea","fisher")

if(PRO.VERSION) checkboxGroupInput('gs_method','Test method:', choices=NULL)
if(DEV.VERSION) radioButtons('gs_lfcmethod','LFC method:', choices=c("fc","gs"))

selected_gsetmethods <- reactive({
    ngs <- inputData()
    gset.methods0 = colnames(ngs$gset.meta$meta[[1]]$fc)
    test = head(intersect(GSET.DEFAULTMETHODS,gset.methods0),3) ## maximum three
    if(PRO.VERSION) test = input$gs_method
    test = intersect(test,gset.methods0) ## maximum three
    test
})

observe({
    ngs <- inputData()
    if(is.null(ngs)) return(NULL)
    meta <- ngs$gset.meta$meta
    comparisons <- colnames(ngs$model.parameters$contr.matrix)
    comparisons = sort(intersect(comparisons, names(meta)))
    updateSelectizeInput(session, "gs_contrast", choices=comparisons)
    gset.methods = sort(colnames(meta[[1]]$fc))
    if(PRO.VERSION) {
        sel2 = intersect(GSET.DEFAULTMETHODS,gset.methods)
        updateCheckboxGroupInput(session, 'gs_method',
                                 choices=gset.methods,
                                 selected = sel2)
    }
})

observe({
    ngs <- inputData()
    if(is.null(ngs)) return(NULL)
    ##gsets.groups = names(table(sub(":.*","",rownames(ngs$gsetX))))
    gsets.groups <- names(COLLECTIONS)
    gsets.groups <- c("<all>",sort(gsets.groups))
    sel = "<all>"
    hmark <- grep("^H$|hallmark|",gsets.groups,ignore.case=TRUE,value=TRUE)
    if(length(hmark)>0) sel <- hmark[1]
    updateSelectInput(session, "gs_features",choices=gsets.groups, selected=sel)
    
})

calculateMeta <- function(comparison, methods, ngs) {
    ##ngs <- inputData()
    mx = ngs$gset.meta$meta[[comparison]]
    if(is.null(mx)) return(NULL)
    mx.methods = colnames(unclass(mx$fc))
    mx.methods
    methods = intersect(methods, mx.methods)
    if(is.null(methods) || length(methods)==0) {
        cat("ERROR: calculateMeta:: no valid methods\n")
        return(NULL)
    }
        
    ## recalculate meta values
    pv = unclass(mx$p)[,methods,drop=FALSE]
    qv = unclass(mx$q)[,methods,drop=FALSE]
    fc = unclass(mx$fc)[,methods,drop=FALSE]
    pv[is.na(pv)] = 0.999
    qv[is.na(qv)] = 0.999
    fc[is.na(fc)] = 0
    score = fc * (-log10(qv))
    
    if(NCOL(pv)>1) {
        ss.rank <- function(x) scale(sign(x)*rank(abs(x)),center=FALSE)
        fc = rowMeans(scale(fc,center=FALSE),na.rm=TRUE)  ## REALLY???
        ##pv = apply(pv,1,function(x) metap::allmetap(x,method="sumz")$p[[1]])
        ##pv = apply(pv,1,vec.combinePvalues,method="stouffer")
        ##qv = p.adjust(pv, method="fdr")
        pv = apply(pv,1,max,na.rm=TRUE)
        qv = apply(qv,1,max,na.rm=TRUE)
        ##score = rowMeans(scale(score,center=FALSE),na.rm=TRUE)
        score = rowMeans(apply(score, 2, ss.rank),na.rm=TRUE)
    }
    meta = cbind( score=score, fc=fc, pv=pv, qv=qv)
    colnames(meta) = c("score","fc","pv","qv")  ## need
    return(meta)
}

getGeneSetTable <- reactive({
    ngs <- inputData()
    if(is.null(ngs)) return(NULL)
    comp=1
    comp = input$gs_contrast
    if(is.null(comp)) return(NULL)
    if(!(comp %in% names(ngs$gset.meta$meta))) return(NULL)
    mx = ngs$gset.meta$meta[[comp]]
    dim(mx)
    
    outputs = NULL
    gsmethod = gsmethod0 = colnames(unclass(mx$fc))
    gsmethod = intersect(gsmethod0, GSET.DEFAULTMETHODS)
    if(PRO.VERSION) gsmethod <- input$gs_method   
    if(is.null(gsmethod) || length(gsmethod)==0) return(NULL)
    
    ## filter gene sets for table
    gsfeatures="<all>"
    gsfeatures = input$gs_features
    if(is.null(input$gs_features)) return(NULL)
    if(1 && !(gsfeatures %in% c(NA,"","*","<all>"))  &&
       gsfeatures %in% names(COLLECTIONS)) {
        ##grp = paste(paste0("^",gsfeatures,":"),collapse="|")
        ##sel <- grep(grp,rownames(mx),ignore.case=TRUE)
        sel <- intersect(rownames(mx),COLLECTIONS[[gsfeatures]]) 
        mx = mx[sel,,drop=FALSE]
    }
    ##outputs = lapply(outputs, function(m) m[rownames(mx),])
    
    gsfilt <- input$gs_filter[1]
    if(!is.null(gsfilt) && !(gsfilt %in% c(""," "))) {
        gsfilt.gene <- substring(gsfilt,2,999)
        ii <- grep(gsfilt.gene,rownames(ngs$GMT),ignore.case=TRUE)
        jj <- NULL
        if(length(ii)>0) jj <- which(Matrix::colSums(ngs$GMT[c(ii,ii),,drop=FALSE]!=0)>0)
        if(substring(gsfilt,1,1)=="#" && nchar(gsfilt.gene)>=2 && length(jj)>0 ) {
            ## search for gene sets that includes this gene
            nmatch <- Matrix::colSums(ngs$GMT[ii,jj,drop=FALSE]!=0)
            jj <- jj[order(-nmatch)]
            gs.matched <- colnames(ngs$GMT)[jj]
            gs.matched <- intersect(gs.matched, rownames(mx))
            
            mx <- mx[gs.matched,,drop=FALSE]
        } else {            
            mx = mx[grep(gsfilt,rownames(mx),ignore.case=TRUE),,drop=FALSE]
        }

    }
        
    rpt = NULL
    ##length(gsmethod)==1 && any(grepl("gsea",gsmethod))
    if(FALSE && length(gsmethod)==1 && any(grepl("^gsea",gsmethod)) ) {
        ## show GSEA table (single method)
        rpt = outputs[[gsmethod]]
        kk = c("GS","SIZE","NES","NOM p-val","FDR q-val","LEADING GENES")
        rpt = rpt[,kk]
    } else if(is.null(outputs) || length(gsmethod)>1) {
        
        ## show meta-statistics table (multiple methods)        
        pv = unclass(mx$p)[,gsmethod,drop=FALSE]
        qv = unclass(mx$q)[,gsmethod,drop=FALSE]
        fx = unclass(mx$fc)[,gsmethod,drop=FALSE]
        pv[is.na(pv)] = 0.999
        qv[is.na(qv)] = 0.999
        fx[is.na(fx)] = 0

        stars.symbols = sapply(1:20,function(i) paste(rep("â˜…",i),collapse=""))
        ##stars.symbols = sapply(1:20,function(i) paste(rep("*",i),collapse=""))
        stars = c("",stars.symbols)[1+rowSums(qv < 0.05)]                
        names(stars) <- rownames(mx)
        
        ##------------ calculate META parameters ----------------
        meta <- calculateMeta(comp, gsmethod, ngs=ngs)
        meta <- meta[rownames(mx),,drop=FALSE]        
        dim(meta)
        ##gset.size = sapply(ngs$gmt.all[rownames(mx)],length)
        gset.size = Matrix::colSums(ngs$GMT[,rownames(mx),drop=FALSE]!=0)
        names(gset.size) <- rownames(mx)
        
        ## ---------- report *average* group expression FOLD CHANGE
        ## THIS SHOULD BETTER GO DIRECTLY WHEN CALCULATING GSET TESTS
        ##
        
        s1 <- names(which(ngs$model.parameters$exp.matrix[,comp]>0))
        s0 <- names(which(ngs$model.parameters$exp.matrix[,comp]<0))
        jj <- colnames(ngs$GMT)
        jj <- rownames(mx)
        
        gsdiff.method <- "fc"  ## OLD default
        if(DEV.VERSION) gsdiff.method <- input$gs_lfcmethod
        if(gsdiff.method=="gs") {
            AveExpr1 <- rowMeans(ngs$gsetX[jj,s1])
            AveExpr0 <- rowMeans(ngs$gsetX[jj,s0])
            meta.fc <- AveExpr1 - AveExpr0
        } else {
            ## WARNING!!! THIS STILL ASSUMES GENES AS rownames(ngs$X)
            ## and rownames(GMT)
            fc <- ngs$gx.meta$meta[[comp]]$meta.fx  ## stable
            names(fc) <- rownames(ngs$gx.meta$meta[[comp]])
            pp <- intersect(rownames(ngs$GMT),names(fc))
            rnaX <- ngs$X
            
            ## check if multi-omics
            is.multiomics <- any(grepl("\\[gx\\]|\\[mrna\\]",names(fc)))
            is.multiomics
            if(is.multiomics) {
                ii <- grep("\\[gx\\]|\\[mrna\\]",names(fc))
                fc <- fc[ii]
                rnaX <- ngs$X[names(fc),]
                names(fc) <- sub(".*:|.*\\]","",names(fc))
                rownames(rnaX) <- sub(".*:|.*\\]","",rownames(rnaX))
                pp <- intersect(rownames(ngs$GMT),names(fc))
                length(pp)
            }            
            ngenes <- Matrix::colSums(ngs$GMT[pp,jj])
            G <- t(ngs$GMT[pp,jj])
            meta.fc <- as.vector(G %*% fc[pp] / ngenes)
            names(meta.fc) <- rownames(G)
            AveExpr1 <- Matrix::rowMeans(G %*% rnaX[pp,s1]) / ngenes
            AveExpr0 <- Matrix::rowMeans(G %*% rnaX[pp,s0]) / ngenes
            remove(rnaX)
        }
        
        ## TWIDDLE means to reflect foldchange... 
        mean0 <- (AveExpr0 + AveExpr1)/2
        AveExpr1 <- mean0 + meta.fc/2
        AveExpr0 <- mean0 - meta.fc/2
        
        ##
        gs <- intersect(names(meta.fc),rownames(meta))
        length(gs)
        
        rpt = data.frame( size = gset.size[gs],
                         logFC = meta.fc[gs],
                         meta.q = meta[gs,"qv"],
                         stars = stars[gs],
                         AveExpr0=AveExpr0[gs],
                         AveExpr1=AveExpr1[gs])
        if(PRO.VERSION) {
            ## add extra p/q value columns
            colnames(qv) <- paste0("q.",colnames(qv))
            rpt <- cbind( rpt, qv[gs,])
        }
        ##rownames(rpt) = gs
    }  else {
        ## show original table (single method)
        rpt = outputs[[gsmethod]]
    }    
    rpt = data.frame(rpt)
    
    ## Get the meta q-value column, filter on q-value
    qv.col = grep("meta.q|fdr|adj.p.val|q.value|adjusted.p|padj|qv",
                  colnames(rpt),ignore.case=TRUE)[1]
    if(length(qv.col)==0) stop("could not parse q-value column")
    qv = rpt[,qv.col]
    fdr = 1
    fdr <- input$gs_fdr
    rpt = rpt[ which( qv <= as.numeric(fdr) ), ,drop=FALSE ]  ## important to cast numeric!

    ## filter on fold-change    
    fx.col = grep("score|fx|fc|sign|NES|logFC",colnames(rpt))[1]
    if(1 && PRO.VERSION) {
        fx  = as.numeric(rpt[,fx.col])
        names(fx) = rownames(rpt)
        lfc = as.numeric(input$gs_lfc)
        rpt = rpt[which(abs(fx) >= lfc),,drop=FALSE]
    }
    fx  = rpt[,fx.col]
    rpt = rpt[order(-abs(fx)),]
    
    ## just show top 10
    if(input$gs_top10) {
        fx  = as.numeric(rpt[,fx.col])
        names(fx) = rownames(rpt)
        pp <- unique(c(head(names(sort(-fx[which(fx>0)])),10),
                       head(names(sort(fx[which(fx<0)])),10)))
        rpt = rpt[pp,,drop=FALSE]
        fx  = as.numeric(rpt[,fx.col])
        rpt = rpt[order(-fx),]
    }

    ## limit to 1000 rows
    rpt <- head(rpt, 1000)
    rpt <- data.frame(rpt)
    
    return(rpt)
})



```

Row {.tabset data-height=500}
--------------------------------------------------------------------------
    
### Top enriched

```{r message=FALSE, warning=FALSE}
renderPlot({

    ngs <- inputData()
    if(is.null(ngs)) return(NULL)
    
    comp=1
    comp = input$gs_contrast
    if(is.null(comp)) return(NULL)
    if(!(comp %in% names(ngs$gx.meta$meta))) return(NULL)
    gx.meta <- ngs$gx.meta$meta[[comp]]
    ##rnk0 <- gx.meta[,"fc"][,"trend.limma"]
    ##names(rnk0) = gx.meta[,"gene_name"]        
    rnk0 <- gx.meta$meta.fx
    names(rnk0) = ngs$genes[rownames(gx.meta),"gene_name"]
    rnk0 = rnk0 - mean(rnk0,na.rm=TRUE)  ## scaling/centering should be done in calculation...
    
    rpt = getGeneSetTable()
    if(is.null(rpt)) return(NULL)
    fx.col = grep("score|fx|fc|sign|NES|logFC",colnames(rpt))[1]
    qv.col = grep("meta.q|q$",colnames(rpt))[1]
    fx = rpt[,fx.col]
    qv = rpt[,qv.col]
    names(qv) <- names(fx) <- rownames(rpt)

    top.up   <- names(sort(fx[which(fx>0)],decreasing=TRUE))
    top.down <- names(sort(fx[which(fx<0)]))
    
    par(mfrow=c(2,5), mar=c(0.5,3.2,3.6,0.5), mgp=c(2,0.8,0))
    for(i in 1:5) {
        if(i > length(top.up)) {
            frame()
        } else {
            gs <- top.up[i]
            genes = names(which(ngs$GMT[,gs]!=0))
            gs1 = breakstring(gs,25,70,force=FALSE)
            gsea.enplot(rnk0, genes, names=NULL, ##main=gs,
                        main=gs1, cex.main=0.9, len.main=80)
            qv1 = formatC(qv[gs],format="e", digits=2)
            legend("topright", paste("q=",qv1), bty="n",cex=0.85)
        }
    }
    for(i in 1:5) {
        if(i > length(top.down)) {
            frame()
        } else {
            gs <- top.down[i]
            genes = names(which(ngs$GMT[,gs]!=0))
            gs1 = breakstring(gs,25,70,force=FALSE)
            gsea.enplot(rnk0, genes, names=NULL, ##main=gs,
                        main=gs1, cex.main=0.9, len.main=80)
            qv1 = formatC(qv[gs],format="e", digits=2)
            legend("topright", paste("q=",qv1), bty="n",cex=0.85)
        }
    }
    
}, res=100)
```   

### Plots

```{r message=FALSE, warning=FALSE, fig.width=1, fig.height=1}
## get colors (what a mess...)
##comp0=colnames(ngs$model.parameters$contr.matrix)[1]

getcolors <- function(ngs, comp0) {   
    ## get colors
    contr.matrix <- ngs$model.parameters$contr.matrix
    require(RColorBrewer)
    exp.matrix <- ngs$model.parameters$exp.matrix        
    xgroup = as.character(ngs$Y$group)
    names(xgroup) = rownames(ngs$Y)
    table(xgroup)
    samples = names(which(exp.matrix[,comp0]!=0))

    xgroup1 <- xgroup[samples]
    table(xgroup1)
    ngrp <- length(unique(xgroup1))
    grp.klr = c("grey90",rep(brewer.pal(12,"Paired"),99)[1:ngrp])
    names(grp.klr) <- c("other",as.character(sort(unique(xgroup1))))
    grp.klr
    
    xgroup2 <- as.character(xgroup)
    xgroup2[which(!(xgroup %in% xgroup1))] <- "other"
    sample.klr = grp.klr[xgroup2]
    names(sample.klr) <- rownames(ngs$samples)
    table(sample.klr)
    list(samples=sample.klr, group=grp.klr)
}    


fillRow(height = '100%', flex = c(1,1,1,1), 
        plotOutput('gs_subplot1'),
        plotOutput('gs_subplot2'),
        plotOutput('gs_subplot3'),
        plotOutput('gs_subplot4')
        )

output$gs_subplot1 <- renderPlot({

    par(mfrow=c(1,1), mgp=c(2.0,0.8,0), oma=c(0.5,0,0.5,0.2) )
    par(mar=c(5,3.5,3,0.5))
    
    ngs <- inputData()    

    ##----------------------------------------------------------------------
    ## 0: Volcano plot in gene space
    ##----------------------------------------------------------------------
    comp=1;gs=1
    comp = input$gs_contrast
    ngs <- inputData()
    if(is.null(ngs)) return(NULL)

    gx.meta <- ngs$gx.meta$meta[[comp]]
    limma1 = sapply(gx.meta[,c("fc","p","q")],function(x) x[,"trend.limma"])
    gx.annot <- ngs$genes[rownames(gx.meta),c("gene_name","gene_title")]
    ##limma = cbind( gx.meta[,c("gene_name","gene_title")], limma1)
    limma = cbind(gx.annot, limma1)
    
    gs = gset_selected()
    if(is.null(gs)) return(NULL)
    gs <- gs[1]
    
    ##sel.genes = names(which(ngs$GMT[,gs]!=0))
    jj = match(toupper(GSETS[[gs]]), toupper(limma$gene_name))
    sel.genes <- setdiff(limma$gene_name[jj],c(NA,""," "))
    fdr = 1
    fdr = as.numeric(input$gs_fdr)
    
    fc.genes = as.character(limma[,grep("^gene$|gene_name",colnames(limma))])
    fx = limma[,grep("logFC|meta.fx|fc",colnames(limma))[1]]
    qval = limma[,grep("^q|adj.P.Val|meta.q|qval|padj",colnames(limma))[1]]
    sig.genes = fc.genes[which(qval <= fdr & abs(fx) > 0.1)]
    
    qval <- pmax(qval,1e-12)  ## prevent q=0
    qval[which(is.na(qval))] <- 1
    xlim = c(-1,1)*max(abs(fx),na.rm=TRUE)
    ylim = c(0,12)
    ylim = c(0, max(12, 1.1*max(-log10(qval),na.rm=TRUE)))
    ylim
    
    lfc=0.20
    lfc = as.numeric(input$gs_lfc)
    
    ##par(mar=c(4,3,3,1), mgp=c(2.0,0.8,0), oma=c(1,1.5,1,1.5) )
    gx.volcanoPlot.XY( x=fx, pv=qval, gene=fc.genes,
                      render="canvas", n=5000, nlab=10, 
                      xlim=xlim, ylim=ylim, ## hi.col="#222222",
                      use.fdr=TRUE, p.sig=fdr, lfc=lfc,
                      cex=0.9, lab.cex=1.3, cex.main=0.8,
                      xlab="fold change (log2)",
                      ylab="significance (log10q)",
                      highlight=sel.genes)
    gs = breakstring(gs,50)
    title(gs, cex.main=0.85)
    
}, res=80)


output$gs_subplot2 <- renderPlot({

    par(mfrow=c(1,1), mgp=c(2.0,0.8,0), oma=c(0.5,0,0.5,0.2) )
    par(mar=c(5,3.5,3,0.5))
    
    ngs <- inputData()    

    ##----------------------------------------------------------------------
    ## 1: Gene set activation {data-width=200}
    ##----------------------------------------------------------------------
    require(RColorBrewer)
    gset = rownames(ngs$gsetX)[1]
    gset = gset_selected()
    if(is.null(gset) || length(gset)==0 ) return(NULL)
    gset <- gset[1]
    
    comp0 = colnames(ngs$model.parameters$contr.matrix)[1]
    comp0 = input$gs_contrast
    
    grouped=TRUE
    grouped=FALSE
    grouped <- !input$gs_ungroup
    has.design <- !is.null(ngs$model.parameters$design)
    collapse.others <- ifelse(has.design, FALSE, TRUE)
    ##collapse.others=TRUE

    ngrp <- length(unique(ngs$samples$group))
    srt <- ifelse(!grouped || ngrp>4, 30, 0)
    if(!grouped && ncol(ngs$X) > 15) srt <- 60
    pgx.plotGeneExpression(
        ngs, gset, comp=comp0, logscale=TRUE, level="geneset",
        collapse.others=collapse.others, grouped=grouped,
        srt=srt, main="", ylab="gene set activation")
    title(breakstring(gset,42,80), cex.main=0.85)

}, res=80)


output$gs_subplot3 <- renderPlot({
    ##----------------------------------------------------------------------
    ## 2: Gene expression {data-width=200}
    ##----------------------------------------------------------------------

    par(mfrow=c(1,1), mgp=c(2.0,0.8,0), oma=c(0.5,0,0.5,0.2) )
    par(mar=c(5,3.5,3,0.5))
    
    ngs <- inputData()    
    if(is.null(ngs)) return(NULL)
    comp0 = colnames(ngs$model.parameters$contr.matrix)[1]
    comp0 = input$gs_contrast

    has.design <- !is.null(ngs$model.parameters$design)
    collapse.others <- ifelse(has.design, FALSE, TRUE)
    ##collapse.others=TRUE

    require(RColorBrewer)
    sel  = gene_selected()

    if(is.null(sel) || is.na(sel) || length(sel)==0) {
        frame()
    } else {
        gene = sel$gene
        ngrp <- length(unique(ngs$samples$group))
        grouped=TRUE
        grouped <- !input$gs_ungroup
        srt <- ifelse(!grouped || ngrp>4, 30, 0)
        if(!grouped && ncol(ngs$X) > 15) srt <- 60
        pgx.plotGeneExpression(
            ngs, gene, comp=comp0, logscale=TRUE, level="gene",
            collapse.others=collapse.others, grouped=grouped,
            srt=srt, main="")
        title(gene, cex.main=0.9)
    }
}, res=80)

output$gs_subplot4 <- renderPlot({
    ##----------------------------------------------------------------------
    ## 3: Gene - gene set correlation
    ##----------------------------------------------------------------------

    par(mfrow=c(1,1), mgp=c(2.0,0.8,0), oma=c(0.5,0,0.5,0.2) )
    par(mar=c(5,3.5,3,0.5))
    
    ngs <- inputData()    

    require(RColorBrewer)
    gene = rownames(ngs$X)[1]
    sel  = gene_selected()
    gset = gset_selected()
    if(is.null(sel)) return(NULL)
    if(is.null(gset)) return(NULL)

    if(is.null(sel) || length(sel)==0) {
        frame()
    } else {
        gene = sel$gene
        gset <- gset[1]    
        gx = ngs$X[sel$probe,]
        sx = ngs$gsetX[gset,]
        if( length(gx)==0 || length(sx)==0 ||
            length(gx)!=length(sx) ) {
            frame()
            return(NULL)
        }
        ## get colors
        comp0 = "Th17_mut_2h_VS_Th17_wt_2h_BLA"
        comp0 = input$gs_contrast
        klrs = getcolors(ngs, comp0)
        klr = klrs$samples[names(sx)]
        klr = paste0(col2hex(klr),"99")
        
        cex1 = c(1.4,0.8,0.3)[cut(length(gx),c(0,100,500,99999))]
        gset1 = breakstring(substring(gset,1,80),32)
        tt = paste( breakstring(gset,40,80), "\nvs.", gene,"expression")
        plot( gx, sx, col=klr, main=tt,
             ylab = "gene set activation",
             xlab = paste(gene,"expression"),
             cex.lab=1, pch=19, cex=1.0*cex1, cex.main=0.85)
        abline( lm(sx ~ gx), lty=2, lwd=0.7, col="black" )
    }    
}, res=80)
```   

### Compare

```{r message=FALSE, warning=FALSE}
renderPlot({

    ngs <- inputData()
    if(is.null(ngs)) return(NULL)
    
    comp=1
    comp = input$gs_contrast
    if(is.null(comp)) return(NULL)

    gset=rownames(ngs$gsetX)[1]
    gset <- gset_selected()
    if(is.null(gset)) return(NULL)
    gset <- gset[1]

    score <- sapply(ngs$gset.meta$meta, function(x) x[gset,"meta.fx"])

    cat("Compare:: gset=",gset,"\n")
    cat("Compare:: head.score=",head(score),"\n")


    top.up <- names(sort(score[which(score>0)],decreasing=TRUE))
    top.down <- names(sort(score[which(score<0)]))
    genes <- names(which(ngs$GMT[,gset]!=0))
    genes <- toupper(sub(".*:","",genes))
    gx.meta <- ngs$gx.meta$meta
    
    par(mfrow=c(2,5), mar=c(0.5,3.2,3.6,0.5), mgp=c(2,0.8,0))
    i=1
    for(i in 1:5) {
        if(i > length(top.up)) {
            frame()
        } else {
            cmp <- top.up[i]
            rnk0 <- gx.meta[[cmp]]$meta.fx
            names(rnk0) <- rownames(gx.meta[[1]])
            names(rnk0) <- toupper(sub(".*:","",names(rnk0)))
            qv0 <- ngs$gset.meta$meta[[cmp]][gset,"meta.q"]
            gs1 = breakstring(gset,25,70,force=FALSE)
            gsea.enplot(rnk0, genes, names=NULL, ##main=gs,
                        main=cmp, cex.main=1, len.main=80)
            qv1 = formatC(qv0,format="e", digits=2)
            legend("topright", paste("q=",qv1), bty="n",cex=0.85)
        }
    }
    for(i in 1:5) {
        if(i > length(top.down)) {
            frame()
        } else {
            cmp <- top.down[i]
            rnk0 <- gx.meta[[cmp]]$meta.fx
            names(rnk0) <- rownames(gx.meta[[1]])
            names(rnk0) <- toupper(sub(".*:","",names(rnk0)))
            qv0 <- ngs$gset.meta$meta[[cmp]][gset,"meta.q"]
            gs1 = breakstring(gset,25,70,force=FALSE)
            gsea.enplot(rnk0, genes, names=NULL, ##main=gs,
                        main=cmp, cex.main=1, len.main=80)
            qv1 = formatC(qv0,format="e", digits=2)
            legend("topright", paste("q=",qv1), bty="n",cex=0.85)
        }
    }
    
}, res=95)
```   

### Volcano (all)

```{r message=FALSE, warning=FALSE, fig.width=12, fig.height=12}
##renderScatterD3({
renderPlot({
    ##renderPlotly({
    require(metap)
    ngs = inputData()
    if(is.null(ngs)) return(NULL)
    if(is.null(input$gs_features)) return(NULL)
    
    meta = ngs$gset.meta$meta
    gsmethod0 = colnames(meta[[1]]$fc)
    gsmethod = intersect(gsmethod0, GSET.DEFAULTMETHODS)    
    if(PRO.VERSION) gsmethod <- input$gs_method
    if(is.null(gsmethod) || length(gsmethod)==0) return(NULL)
    
    ng = length(meta)
    nn = c(2, max(ceiling(ng/2),5))
    ##if(ng>12) nn = c(3,8)
    par(mfrow=nn, mar=c(2,4,2.3,2)*0, mgp=c(2.6,1,0))
    n = ceiling(sqrt(ng))
    if(ng>24) {
        n = max(ceiling(ng/3),6)
        par(mfrow=c(3,n), mar=c(4,4,2,2)*0)
    } else if(FALSE && ng <= 3) {
        par(mfrow=c(1,3), mar=c(4,4,2,2)*0)
    } else {
        n = max(ceiling(ng/2),6)
        par(mfrow=c(2,n), mar=c(4,4,2,2)*0)
    }

    fdr = as.numeric(input$gs_fdr)    
    lfc = as.numeric(input$gs_lfc)
    sel.gsets = COLLECTIONS[[1]]
    sel.gsets = COLLECTIONS[[input$gs_features]]

    withProgress(message="computing volcano plots ...", value=0, {
        i=1
        for(i in 1:length(meta)) {
            mx <- calculateMeta(i, gsmethod, ngs=ngs)
            is.sig <- (mx[,"qv"] <= fdr & abs(mx[,"fc"]) >= lfc)
            sig.gs = rownames(mx)[which(is.sig)]
            sig.gs <- intersect(sel.gsets, sig.gs)
            gx.volcanoPlot.XY(
                x = mx[,"fc"], pv = mx[,"qv"],
                use.fdr=TRUE, p.sig=fdr, lfc=lfc,                
                gene = substring(rownames(mx),1,35), 
                xlab = "effect size (NES)", lab.cex=1.5, nlab=3,
                render="canvas", n=1000, highlight=sig.gs,
                cex=1, cex.axis=1.3, cex.main=1.4, axes=FALSE,
                ylim=c(0,10), main="" )
            ##title(names(meta)[i],line=-1)
            legend("topright",names(meta)[i], cex=1.2, bg="white")

            ## draw axis if first column or last row
            ##n=nn[2]
            is.first = (i%%n==1)
            last.row = ( (i-1)%/%n == (length(meta)-1)%/%n )
            if(is.first) axis(2, tcl=0.5, mgp=c(-2,-1.5,0))
            if(last.row) axis(1, tcl=0.5, mgp=c(-2,-1.5,0))
            box()

            ##volcano_plot(limma, render="plotly", n=1000, cex=1, highlight=genes)
            incProgress( 1/length(meta) )
        }
    })
})
``` 

### Volcano (methods)

```{r message=FALSE, warning=FALSE}
##renderScatterD3({
renderPlot({
    ##renderPlotly({
    ngs <- inputData()    
    if(is.null(ngs)) return(NULL)
    if(is.null(input$gs_features)) return(NULL)
    
    cmp = 1
    cmp = input$gs_contrast
    mx = ngs$gset.meta$meta[[cmp]]
    fx = unclass(mx$fc)
    qv = unclass(mx$q)
    pv = unclass(mx$p)    

    fx[which(is.na(fx))] <- NA
    fx[which(is.infinite(fx))] <- NA
    qv[which(is.na(qv))] <- 1

    fdr=1;lfc=0
    fdr=0.05;lfc=1
    fdr = as.numeric(input$gs_fdr)    
    lfc = as.numeric(input$gs_lfc)
    sel.gsets <- rownames(mx)
    sel.gsets = COLLECTIONS[[1]]
    sel.gsets = COLLECTIONS[[input$gs_features]]
    
    ng = ncol(fx)
    nn = c(2, max(ng/2,5))
    par(mfrow=nn, mar=c(2,4,2.3,2)*0, mgp=c(2.6,1,0))

    i=1
    for(i in 1:ng) {
        
        is.sig <- ( qv[,i] <= fdr & abs(fx[,i]) >= lfc)
        sig.gs = rownames(mx)[which(is.sig)]
        sig.gs <- intersect(sel.gsets, sig.gs)
        
        method = colnames(fx)[i]
        gx.volcanoPlot.XY(
            x = fx[,i], pv = qv[,i],
            use.fdr=TRUE, p.sig=fdr, lfc=lfc,
            ##gene = substring(rownames(mx),1,35),
            gene = rownames(mx),
            xlab = "effect size (NES)", ylim=c(0,10), 
            lab.cex=1.5, nlab=3, axes=FALSE, 
            render="canvas", n=1000, highlight=sig.gs,
            cex=1, cex.axis=1.3, main="")

        ##title(mt, line=-1.5, cex.main=1.4)
        legend("topright",method,bg="white", cex=1.2)
        
        ##volcano_plot(limma, render="plotly", n=1000, cex=1, highlight=genes)
        ## draw axis if first column or last row
        n=nn[2]
        is.first = (i%%n==1)
        last.row = ( (i-1)%/%n == (ng-1)%/%n )
        if(is.first) axis(2, tcl=0.5, mgp=c(-2,-1.5,0))
        if(last.row) axis(1, tcl=0.5, mgp=c(-2,-1.5,0))
        box()

    }

})
``` 

`r if(!DEV.VERSION) {"<!--------------------------------------------------------"}`

### Gene map

```{r message=FALSE, warning=FALSE, fig.width=12, fig.height=12}
renderPlot({
    require(Matrix)

    ## -------------- get the gene-centric fold-changes (default LIMMA)
    comp1=1
    comp1 = input$gs_contrast
    ngs <- inputData()
    gx.meta <- ngs$gx.meta$meta[[comp1]]
    limma1 = sapply(gx.meta[,c("fc","p","q")],function(x) x[,"trend.limma"])
    ##limma = cbind( ngs$gx.meta$meta[[comp1]][,c("gene_name","gene_title")], limma1)
    gx.annot <- ngs$genes[rownames(gx.meta),c("gene_name","gene_title")]
    ##limma = cbind( gx.meta[,c("gene_name","gene_title")], limma1)
    limma = cbind(gx.annot, limma1)
    
    gs = rownames(ngs$gsetX)[1]
    gs = gset_selected()
    if(is.null(gs)) return(NULL)
    gs <- gs[1]
    
    ##gsets = names(ngs$gmt.all)
    gsets = colnames(ngs$GMT)
    if(!(gs %in% gsets)) {
        cat("warning:: geneset",gs,"not in GSETS!!\n")
        return(NULL)
    }
    
    ## ------------------- compute closests neighbours (gene set)
    rpt = isolate( getGeneSetTable() )
    mx = ngs$gset.meta$meta[[comp1]]
    mx = mx[intersect(rownames(mx),rownames(rpt)),]  ## only those currently selected
    mx = mx[intersect(rownames(mx),gsets),]  ## only those that have GMT

    ##genes = rownames(ngs$X)
    ##genes = ngs$genes$gene_name
    kk <- intersect(rownames(ngs$gsetX), colnames(ngs$GMT))    
    G = ngs$GMT[,kk]    
    colnames(G) = kk
    gg = intersect(rownames(G),as.character(limma$gene_name))
    fc = abs(limma[match(gg,limma$gene_name),"fc"])    
    g1 = as.matrix(G[gg,rownames(mx)])*fc
    g2 = G[gg,gs]*fc
    suppressWarnings( rho1 <- cor(g1, g2)[,1] )
    
    ## ----------- create map with closest neigbours (what crappy coding...)
    gs.top = head(names(sort(-abs(rho1))),25)  ## how many gene sets
    fx = mx[gs.top,"meta.fx"]
    M = t(G[,gs.top]) * fx
    rownames(M) = gs.top
    M = M[,intersect(colnames(M),limma$gene_name)]
    fc = limma[match(colnames(M),limma$gene_name),"fc"]
    M = t(t(M) * abs(fc))
    jj = head(order(-Matrix::colSums(abs(M))), 80)  ## how many genes
    M = M[,jj]
    M = 1*(M!=0)
    fx = mx[rownames(M),"meta.fx"]
    fc = limma[match(colnames(M),limma$gene_name),"fc"]
    fc[is.na(fc)] = 0
    fx[is.na(fx)] = 0    
    M = t( t(M * rank(abs(fx)) ) * fc )
    M = sign(M) * abs(M)**0.33
    M = as.matrix(M)
    ##d3heatmap(M, scale="none", colors="Spectral", cexRow=0.7, cexCol=0.6 )
    hc <- gx.heatmap(M-1e-8, mar=c(6,38), cexRow=1.00, cexCol=0.95,
                     scale='none', keysize=0.3, key=FALSE)
    
})
```

### Concept enrichment

```{r message=FALSE, warning=FALSE}
renderPlot({

    ngs <- inputData()
    if(is.null(ngs)) return(NULL)
    
    comp=1
    comp = input$gs_contrast
    if(is.null(comp)) return(NULL)
    if(!(comp %in% names(ngs$gx.meta$meta))) return(NULL)

    S <- sapply( ngs$gset.meta$meta, function(x) x$meta.fx)
    rownames(S) <- rownames(ngs$gset.meta$meta[[1]])

    keyword = "lipid"
    keyword = "apoptosis"
    keyword = "cell.cycle"
    keyword <- input$gs_filter
    if(is.null(keyword) || keyword=="") keyword <- "cell.cycle"
    targets <- grep(keyword, rownames(S), ignore.case=TRUE, value=TRUE)
    length(targets)
    gmt <- list(targets)
    names(gmt) = keyword
    
    require(fgsea)
    i=1
    res <- c()
    for(i in 1:ncol(S)) {
        res1 <- fgsea( gmt, S[,i], nperm=400 )[,1:5]
        res <- rbind(res, as.data.frame(res1)[1,])
    }
    rownames(res) <- colnames(S)
    ##res$padj <- p.adjust( res$pval, method="bonferroni")
    res$padj <- p.adjust( res$pval, method="fdr")
    ##res <- res[order(-res$NES),]
    
    fx <- res$NES
    names(fx) <- rownames(res)
    top.up   <- names(sort(fx[which(fx>0)],decreasing=TRUE))
    top.down <- names(sort(fx[which(fx<0)]))

    par(mfrow=c(2,5), mar=c(0.5,3.2,3.5,0.5), mgp=c(2,0.8,0))
    i=1
    for(i in 1:5) {
        if(i > length(top.up)) {
            frame()
        } else {
            cmp <- top.up[i]
            gsea.enplot(S[,cmp], targets, names=NULL, ##main=gs,
                        main = paste0("#",toupper(keyword),"\n",cmp),
                        cex.main=0.9, len.main=80)
            qv1 = formatC(res[cmp,"padj"],format="e", digits=2)
            nes1 = formatC(res[cmp,"NES"],format="f", digits=2)
            tt <- c(paste("NES=",nes1),paste("q=",qv1))
            legend("topright", tt, bty="n",cex=0.85)
        }
    }
    i=1
    for(i in 1:5) {
        if(i > length(top.down)) {
            frame()
        } else {
            cmp <- top.down[i]
            gsea.enplot(S[,cmp], targets, names=NULL, ##main=gs,
                        main = paste0("#",toupper(keyword),"\n",cmp),
                        cex.main=0.9, len.main=80)
            qv1 = formatC(res[cmp,"padj"],format="e", digits=2)
            nes1 = formatC(res[cmp,"NES"],format="f", digits=2)
            tt <- c(paste("NES=",nes1),paste("q=",qv1))
            legend("topright", tt, bty="n",cex=0.85)
        }
    }
    
}, res=95)
```   

`r if(!DEV.VERSION) {"----------------------------------------------------->"}`


Row {.tabset data-height=450}
--------------------------------------------------------------------------
   
### Enrichment table

```{r message=FALSE, warning=FALSE}

fillRow(height = 600, flex = c(2,0.10,1), 
        dataTableOutput('gs_gseatable'), br(),
        dataTableOutput('gs_genetable')
        )

output$gs_gseatable <- DT::renderDataTable({

    rpt = getGeneSetTable()
    if(is.null(rpt)) return(NULL)
    if(nrow(rpt)==0) return(NULL)
    ##cat("dim.rpt=",dim(rpt),"\n")
    
    if(!("GS" %in% colnames(rpt))) rpt = cbind(GS=rownames(rpt),rpt)
    if("GS" %in% colnames(rpt)) rpt$GS = shortstring(rpt$GS,72)
    if("size" %in% colnames(rpt)) rpt$size = as.integer(rpt$size)

    fx = NULL
    fx.col = grep("score|fx|fc|sign|NES|logFC",colnames(rpt))[1]
    if(length(fx.col)>0) fx = rpt[,fx.col]

    jj = which(sapply(rpt,is.numeric))
    if(length(jj)>0) rpt[,jj] = round(rpt[,jj],digits=4)    
    jj = which( sapply(rpt,is.character) |  sapply(rpt,is.factor) )
    if(length(jj)>0) rpt[,jj] = apply(rpt[,jj,drop=FALSE],2,shortstring,100)

    selectmode <- ifelse(TRUE, "multiple", "single")
    selectmode = "single"
    ##if(PRO.VERSION) selectmode <- ifelse(input$gs_multimode==TRUE, "multiple", "single")
    selectmode
   
    numeric.cols <- which(sapply(rpt, is.numeric))
    numeric.cols

    ##rpt = format(rpt, digits=4)
    DT::datatable(rpt,
                  class = 'compact cell-border stripe hover',
                  rownames=FALSE,
                  extensions = c('Buttons','Scroller'),                  
                  selection=list(mode=selectmode, target='row', selected=1),
                  options=list(
                      ##dom = 'Blfrtip',
                      dom = 'Blrftip', 
                      buttons = list('copy','csv',
                                     list(extend='pdf',
                                          pageSize="A3", orientation='landscape',
                                          filename="gsea-toptable", title="")),
                      ##pageLength = 20,##  lengthMenu = c(20, 30, 40, 60, 100, 250),
                      scrollX = TRUE, scrollY = 290, scroller=TRUE, deferRender=TRUE
                  )) %>%
        formatSignif(numeric.cols,4) %>%
        DT::formatStyle(0, target='row', fontSize='11px', lineHeight='70%')  %>%
            DT::formatStyle(fx.col, 
                            background = color_from_middle( fx, 'lightblue', '#f5aeae'))
}, server=FALSE)



output$gs_genetable <- DT::renderDataTable({

    rpt <- geneDetails()    
    
    rpt$gene_title <- NULL    
    if(!is.null(rpt) && nrow(rpt)>0 ) {
        jj = which(sapply(rpt,is.numeric))
        rpt[,jj] = round(rpt[,jj],digits=4)
        jj = which( sapply(rpt,is.character) |  sapply(rpt,is.factor) )
        if(length(jj)>0) rpt[,jj] = apply(rpt[,jj,drop=FALSE],2,shortstring,60)
    } else {
        rpt <- data.frame(0,0,0,0,0)[0,]
        colnames(rpt) <- c("gene_name","fc","p","q","gset.rho")
    }
    if(!PRO.VERSION) {
        rpt <- rpt[,c("gene_name","fc","p","q","gset.rho"),drop=FALSE]
    }
    
    numeric.cols <- which(sapply(rpt, is.numeric))
    numeric.cols

    tbl <- DT::datatable(rpt,
                         class = 'compact cell-border stripe', rownames=FALSE,
                         extensions = c('Buttons','Scroller'),
                         selection=list(mode="single", target='row', selected=1),
                         options=list(
                             ##dom = 'Blfrtip',
                             dom = 'Blrtip', 
                             buttons = list('copy','csv',
                                            list(extend='pdf', orientation='landscape', pageSize="A3",
                                                 filename="gsea-genes", title="")),
                             ##pageLength = 20,##  lengthMenu = c(20, 30, 40, 60, 100, 250),
                             scrollX = TRUE, scrollY = 290, scroller=TRUE, deferRender=TRUE
                         )) %>%
    formatSignif(numeric.cols,4)
    
    if( nrow(rpt)>0 && ("fc" %in% colnames(rpt)) ) {
        fx = rpt[,"fc"]
        tbl <- tbl %>%
            DT::formatStyle(0, target='row', fontSize='11px', lineHeight='70%')  %>%
            DT::formatStyle("fc", background = color_from_middle( fx, 'lightblue', '#f5aeae'))
    }
    tbl
}, server=FALSE)

gset_selected <- reactive({
    i = as.integer(input$gs_gseatable_rows_selected)
    if(is.null(i) || length(i)==0) return(NULL)
    rpt = getGeneSetTable()
    gs = rownames(rpt)[i]
    return(gs)
})

geneDetails <- reactive({
    ## return details of the genes in the selected gene set
    ##
    
    ngs <- inputData()
    if(is.null(ngs)) return(NULL)
    gs=1;comp=1

    comp = input$gs_contrast
    if(is.null(comp)) return(NULL)
    gs = gset_selected()
    if(is.null(gs) || length(gs)==0) return(NULL)
    
    ##limma = ngs$gx.meta$outputs[["trend.limma"]]$tables[[comp]]
    mx <- ngs$gx.meta$meta[[comp]]
    is.multiomics <- any(grepl("\\[gx\\]|\\[mrna\\]",rownames(mx)))
    is.multiomics
    if(is.multiomics) {
        ii <- grep("\\[gx\\]|\\[mrna\\]",rownames(mx))
        mx <- mx[ii,]
        ##rownames(mx) <- sub(".*:|.*\\]","",rownames(mx))
    }            
    
    gxmethods <- c("trend.limma","ttest.welch")
    gxmethods <- selected_gxmethods() ## from module-expression
    req(gxmethods)
    ##limma1 = sapply(mx[,c("fc","p","q")], function(x) x[,"trend.limma"])
    limma1.fc <- rowMeans(mx$fc[,gxmethods,drop=FALSE],na.rm=TRUE)
    limma1.pq = sapply(mx[,c("p","q")], function(x) {
        apply(x[,gxmethods,drop=FALSE],1,max,na.rm=TRUE)
    })
    limma1 <- cbind( fc=limma1.fc, limma1.pq)
    ##limma  = cbind( ngs$gx.meta$meta[[comp]][,c("gene_name","gene_title")], limma1)
    
    ## in multi-mode we select *common* genes
    ns <- length(gs)
    gmt1 <- ngs$GMT[,gs,drop=FALSE]
    genes = rownames(gmt1)[which(Matrix::rowSums(gmt1!=0)==ns)]
    genes = intersect(genes, ngs$genes[rownames(mx),"gene_name"])
    genes = setdiff(genes, c("",NA,"NA"," "))

    title = as.character(GENE.TITLE[genes])
    title[is.na(title)] <- " "
        
    rpt <- data.frame("gene_name"=genes, "gene_title"=as.character(title) )
    genes = rpt[,"gene_name"]
    genes1 <- ngs$genes[rownames(limma1),"gene_name"]
    limma1 = limma1[match(genes, genes1),,drop=FALSE ]    
    avg.rho <- rowMeans(cor(t(ngs$X[rownames(limma1),,drop=FALSE]),
                            t(ngs$gsetX[gs,,drop=FALSE])))
        
    rpt = cbind(rpt, limma1, gset.rho=avg.rho)
    rpt = rpt[which(!is.na(rpt$fc) & !is.na(rownames(rpt))),,drop=FALSE]
    ##rpt = data.frame(rpt, check.names=FALSE)

    if(nrow(rpt)>0) {
        rpt = rpt[order(-abs(rpt$fc)),,drop=FALSE]
    }
    return(rpt)
})

gene_selected <- reactive({
    ngs <- inputData()
    if(is.null(ngs)) return(NULL)
    i = 1
    i = as.integer(input$gs_genetable_rows_selected)
    if(is.null(i) || is.na(i) || length(i)==0) i=1
    rpt <- geneDetails()
    if(is.null(rpt) || nrow(rpt)==0) {
        return(list(gene=NA, probe=NA))
    }
    sel.gene = rownames(rpt)[i]
    gene = as.character(rpt$gene_name[i])
    probe = rownames(ngs$genes)[match(gene, ngs$genes$gene_name)]
    return(list(gene=gene, probe=probe))
})
```

`r if(!PRO.VERSION) {"<!--------------------------------------------------------"}`

### Foldchange (all)

```{r echo=FALSE, warning=FALSE, fig.height=5, fig.width=8}
fillRow(flex = c(1), width = "100%", 
        dataTableOutput('gs_fctable')
        )

output$gs_fctable <- renderDataTable({
    ngs <- inputData()
    
    F <- sapply( ngs$gset.meta$meta, function(x) x[,"meta.fx"])
    qv <- sapply( ngs$gset.meta$meta, function(x) x[,"meta.q"])
    rownames(qv) <- rownames(F) <- rownames(ngs$gset.meta$meta[[1]])
    fc.var <- round( rowMeans(F**2,na.rm=TRUE), digits=3)
    gs <- substring(rownames(F),1,60)
    F1 <- data.frame( geneset=gs, fc.var=fc.var, round(F,digits=3), check.names=FALSE)

    ## get current filtered geneset and extract names of gene sets
    rpt = getGeneSetTable()
    F1 <- F1[intersect(rownames(rpt),F1$geneset),,drop=FALSE]    
    
    DT::datatable( F1, rownames=FALSE,
                  class = 'compact cell-border stripe hover',                  
                  extensions = c('Buttons','Scroller'),
                  selection=list(mode='single', target='row', selected=c(1)),
                  options=list(
                      dom = 'Blfrtip', 
                      buttons = list('copy','csv',
                                     list(extend='pdf',
                                          pageSize="A3", orientation='landscape', 
                                          filename="diffexpr-table", title="")),
                      ##pageLength = 20,##  lengthMenu = c(20, 30, 40, 60, 100, 250),
                      scrollX = TRUE, scrollY = 290, scroller=TRUE, deferRender=TRUE
                  )  ## end of options.list 
                  ) %>%
        DT::formatStyle(0, target='row', fontSize='11px', lineHeight='70%')  %>%
            DT::formatStyle( "fc.var",
                            ##background = styleColorBar(c(0,3), 'lightblue'),
                            background = color_from_middle(fc.var, 'lightblue', '#f5aeae'),
                            backgroundSize = '98% 88%', backgroundRepeat = 'no-repeat',
                            backgroundPosition = 'center')  %>%
            DT::formatStyle( colnames(F),
                            ##background = styleColorBar(c(0,3), 'lightblue'),
                            background = color_from_middle(F[,], 'lightblue', '#f5aeae'),
                            backgroundSize = '98% 88%', backgroundRepeat = 'no-repeat',
                            backgroundPosition = 'center')

}, server=FALSE)
```

### FDR table

#### Number of significant gene sets

```{r message=FALSE, warning=FALSE}
##renderPlot({
require(kableExtra)
renderDataTable({
    ngs <- inputData()    

    meta <- ngs$gset.meta
    test = GSET.DEFAULTMETHODS
    if(PRO.VERSION) test <- input$gs_method
    if(is.null(test)) return(NULL)

    if(length(test)==1) {
        sig.up   = meta$sig.counts[[test]][["up"]]
        sig.down = meta$sig.counts[[test]][["down"]]
        rownames(sig.up) = paste0(rownames(sig.up),"::",test[1])
        rownames(sig.down) = paste0(rownames(sig.down),"::",test[1])
    } else {
        sig.up = c()
        sig.down = c()
        for(i in 1:length(test)) {
            sig1 = meta$sig.counts[[test[i]]][["up"]]
            sig2 = meta$sig.counts[[test[i]]][["down"]]
            rownames(sig1) = paste0(rownames(sig1),"::",test[i])
            rownames(sig2) = paste0(rownames(sig2),"::",test[i])
            sig.up <- rbind(sig.up, sig1)
            sig.down <- rbind(sig.down, sig2)
        }
    }
    sig.up <- sig.up[order(rownames(sig.up)),,drop=FALSE]
    sig.down <- sig.down[order(rownames(sig.down)),,drop=FALSE]    
    pvals = sort( c(1e-16, 10**seq(-8,-2,2), 0.05, 0.1, 0.2, 0.5,1))
    kk = intersect(colnames(sig.up),pvals)
    sig.up = sig.up[,match(kk,colnames(sig.up)),drop=FALSE]
    sig.down = sig.down[,match(kk,colnames(sig.down)),drop=FALSE]
    
    colnames(sig.up)[1] = paste("UP   FDR = ",colnames(sig.up)[1])
    colnames(sig.down)[1] = paste("DOWN   FDR = ",colnames(sig.down)[1])
    colnames(sig.down) = paste0("  ",colnames(sig.down))
    sigcount = cbind( sig.down, sig.up[rownames(sig.down),] )
    dim(sigcount)    
    maxsig = 0.99 * max(sigcount,na.rm=TRUE)
    ##gs.up %>% kable("html") %>%
    ##    kable_styling(bootstrap_options = c("striped", "hover", "condensed"),
    ##                  font_size = 10)

    contr = sub("::.*","",rownames(sigcount))
    ##contr = rownames(sigcount)
    metd  = sub(".*::","",rownames(sigcount))
    D = data.frame( method=metd, contrast=contr, sigcount, check.names=FALSE)

    ##width  <- session$clientData$output_kegg_graph_width
    ##height <- session$clientData$output_kegg_graph_height    

    DT::datatable( D, rownames=FALSE,
                  class = 'compact cell-border stripe hover',                  
                  extensions = c('Scroller'),
                  options=list(
                      dom = 't',
                      pageLength = 40,##  lengthMenu = c(20, 30, 40, 60, 100, 250),
                      scrollX = TRUE, scrollY = 300, scroller=TRUE, deferRender=TRUE
                  )  ## end of options.list 
                  ) %>%
        DT::formatStyle(0, target='row', fontSize='11px', lineHeight='70%') %>%
            DT::formatStyle(colnames(sig.up),
                            background = styleColorBar(c(0,maxsig), '#f5aeae'),
                            backgroundSize = '98% 88%', backgroundRepeat = 'no-repeat',
                            backgroundPosition = 'center')  %>% 
            DT::formatStyle(colnames(sig.down),
                            background = styleColorBar(c(0,maxsig), 'lightblue'),
                            backgroundSize = '98% 88%', backgroundRepeat = 'no-repeat',
                            backgroundPosition = 'center')  
}, server=FALSE)
```

`r if(!PRO.VERSION) {"-------------------------------------------------------->"}`
