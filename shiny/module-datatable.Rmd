Data table  {data-orientation=rows}
================================================================================


Inputs {.sidebar data-width=250}
--------------------------------------------------------------------------------
<br>
**Data Table.** Descriptive statistical analysis on a gene level with visualisations. 


```{r}
##actionLink("hm_info", " ", icon = icon("info") )
##actionLink("data_info", "More details ...", icon=icon("info")); br()
##actionLink("data_info2", "More details ...", icon=icon("info-circle")); br()
actionLink("data_info", "Info", icon=icon("info-circle")); br()
##actionLink("data_info3", "Help", icon=icon("question")); br()

data_infotext =
    "The <strong>Data Table module</strong> provides a descriptive statistical analysis on a gene level with visualisations. During the visual analysis, users can filter out some samples or collapse the samples by predetermined groups. It is also possible to visualize the information on a raw count level (CPM) rather than a logarithmic expression level (logCPM). 

<br><br>The <strong>Plots tab</strong> displays figures related to the expression level of the selected gene, correlation to other genes, and average expression ranking within the dataset. To find out more information from the literature, hyperlinks are provide to connect the selected gene to OMIM, KEGG and GO databases. It also correlates the gene to the expressions of other genes across datasets such as ImmProt and HPA, and plots the cumulative correlation. Furthermore, it displays the tissue expression for a selected gene using the genotype-tissue expression (GTEx) dataset. 

<br><br>In the <strong>Counts tab</strong>, the total number of counts (abundance) per sample and their distribution among the samples are displayed. For each sample, users can also see the percentage of counts in terms of major gene types such as CD molecules, kinanses or RNA binding motifs.

<br><br>Under <strong>Gene Table tab</strong>, the exact expression values across the samples can be read, where genes are ordered by the correlation with respect to the first gene. Gene-wise average expression of a phenotype sample grouping is also presented in this table.

<br><br>In the <strong>Sample Table tab</strong>, more complete information about samples and their phenotype grouping can be found.

"

observeEvent( input$data_info, {
    showModal(modalDialog(
        title = HTML("<strong>Data Table Module</strong>"),
        HTML(data_infotext),
        easyClose = TRUE ))
})

##require(tippy)
##tippy("Help/Info", tooltip=hm_infotext)
```


<br><br>

```{r}
require(htmltools)
## data set parameters
##textInput("search_gene","Filter genes", value="")
selectInput("search_gene","Search gene", choices=NULL)

br();br();
actionLink("dt_options", "Options", icon=icon("cog", lib = "glyphicon"));br()
##actionLink("dt_options2a", "Options ...", icon=icon("cog", lib = "glyphicon"));br()
##actionLink("dt_options2c", "Options ...", icon=icon("cogs", lib = "fontawesome"));br()

## br();br()
datatypes <- c("CPM","logCPM")
if(PRO.VERSION) datatypes <- c("counts","CPM","logCPM")
conditionalPanel(
    "input.dt_options % 2 == 1",
    tagList(
        selectInput("data_samplefilter","Filter samples", choices=NULL, multiple=TRUE),
        checkboxInput('data_grouped','grouped',TRUE),
        checkboxInput('data_geneinfo','gene summary',FALSE),
        radioButtons('data_type','Data type:', choices=datatypes, selected="logCPM", inline=TRUE)
    )
)

br();br();HTML("Download: ")
downloadLink('data_downloadData', '[counts]')
downloadLink('gx_downloadData', ' [comparisons]')
downloadLink('gs_downloadData', ' [enrichment]')

br();br();br();br();br();br()

## ------- download functions -----------
output$data_downloadData <- downloadHandler(
    filename = function() {
        paste("playground-COUNTS.csv", sep="")
    },
    content = function(file) {
        ngs <- inputData()
	gg <- ngs$genes[rownames(ngs$counts),]
	if(class(gg)=="DataFrame") gg <- do.call(cbind, gg@listData)
        df <- data.frame(gg, round(ngs$counts,digits=5))
        write.csv(df, file, row.names=FALSE)
    }
)

output$gx_downloadData <- downloadHandler(
    filename = function() {
        ##ngs <- inputData()
        paste("playground-COMPARISONS-all.csv", sep="")
    },
    content = function(file) {
        ngs <- inputData()
        mx <- NULL
        k=1
        for(k in names(ngs$gx.meta$meta)) {
            colnames(ngs$gx.meta$meta[[k]])
            ff <- ngs$gx.meta$meta[[k]][,c("meta.fx","meta.p","meta.q")]
            colnames(ff) <- paste(c("logFC","p","q"),k,sep=".")
            if(!is.null(mx)) {
                mx <- cbind(mx, ff)
            } else {
                mx <- ff
            }
        }
        mx <- mx[,order(colnames(mx))]
        pp <- rownames(ngs$gx.meta$meta[[1]])
	gg <- ngs$genes[pp,]
	if(class(gg)=="DataFrame") gg <- do.call(cbind, gg@listData)
        mx <- data.frame(gg, mx)
        write.csv(mx, file, row.names=FALSE)
    }
)

output$gs_downloadData <- downloadHandler(
    filename = function() {
        ##ngs <- inputData()
        paste("playground-ENRICHMENT-all.csv", sep="")
    },
    content = function(file) {
        ngs <- inputData()
        mx <- NULL
        for(k in names(ngs$gset.meta$meta)) {
            ff <- ngs$gset.meta$meta[[k]][,c("meta.fx","meta.q")]
            colnames(ff) <- paste(c("logFC","q"),k,sep=".")
            if(!is.null(mx)) {
                mx <- cbind(mx, ff)
            } else {
                mx <- ff
            }
        }
        mx <- mx[,order(colnames(mx))]
        aa <- ngs$gset.meta$meta[[1]][,c("gene.set")]
        mx <- cbind( gene.set=aa, mx)
        write.csv(mx, file, row.names=FALSE)
    }
)

## ------- observe functions -----------

## update filter choices upon change of data set 
observe({
    ngs <- inputData()
    if(is.null(ngs)) return(NULL)

    ## levels for sample filter
    levels = getLevels(ngs$Y)
    updateSelectInput(session, "data_samplefilter", choices=levels)
    genes <- sort(ngs$genes[rownames(ngs$X),]$gene_name)
    sel = genes[1]  ## most var gene
    updateSelectInput(session,'search_gene', choices=genes, selected=sel)
})

```


Col {.tabset data-height=400}
--------------------------------------------------------------------------------

### Plots

```{r echo=FALSE, warning=FALSE, fig.height=5, fig.width=10}
fillCol( flex = c(1.3,1), ## width = 600,
        plotOutput('data_genePlots'), 
        fillRow(flex = c(1,1.3,1.6), 
                htmlOutput('data_geneInfo', class="gene-info-output"),
                plotOutput('data_corplot'),
                plotOutput('data_tissueplot')
                )
        )

output$data_genePlots <- renderPlot({
    require(RColorBrewer)
    
    ngs <- inputData()
    if(is.null(ngs)) return(NULL)

    ##if(is.null(input$search_gene)) return(NULL)
    ##cat("data_genePlots:: is.null(data_samplefilter)=",is.null(input$data_samplefilter),"\n")
    ##if(is.null(input$data_samplefilter)) return(NULL)
    
    gene = "KCNN4"
    gene = ngs$genes$gene_name[1]
    if(!is.null(input$search_gene) && input$search_gene!="") gene <- input$search_gene
    samples = colnames(ngs$X)
    if(!is.null(input$data_samplefilter)) {
        samples <- selectSamplesFromSelectedLevels(ngs$Y, input$data_samplefilter)
    }
    nsamples = length(samples)
        
    grp = factor(ngs$Y[samples,"group"])    
    klr0 = rep(brewer.pal(8,"Set2"),99)
    klr0 = COLORS
    klr = klr0[factor(ngs$Y[samples,"group"])]
    
    ## precompute
    pp=rownames(ngs$genes)[1]
    pp <- rownames(ngs$genes)[match(gene,ngs$genes$gene_name)]
    
    gx = NULL
    ylab = NULL
    if(input$data_type=="counts") {
        gx = ngs$counts[pp,samples]
        ylab="expression (counts)"
    } else if(input$data_type=="CPM") {
        gx = 2**ngs$X[pp,samples]
        ylab="expression (CPM)"
    } else if(input$data_type=="logCPM") {
        gx = ngs$X[pp,samples]
        ylab="expression (log2CPM)"
    }

    ## Layout and margins
    par(mfrow=c(1,4), oma=c(2,0.5,2,0.5))
    layout(matrix(1:4,1,4), widths=c(1,1.3,1.3,0.7))
    par(mar=c(6,3.5,2,1), mgp=c(2.1,0.8,0), oma=c(3,0.5,1.5,0.3))
    
    ##----------------------------------------------------------------------
    ## t-SNE
    ##----------------------------------------------------------------------
    require(RColorBrewer)
    pos <- ngs$tsne2d[samples,]

    cex1 <- 2*c(1.8,1.2,0.6,0.3)[cut(nrow(pos),breaks=c(-1,40,200,1000,1e10))]    
    klrpal = colorRampPalette(c("blue3", "aliceblue", "grey85", "lavenderblush", "red3"))(16)
    klrpal = colorRampPalette(c("grey80", "grey50", "red3"))(16)

    fc1 <- tanh(0.99 * scale(gx)[,1])
    fc1 <- tanh(0.99 * scale(gx,center=FALSE)[,1])
    ##fc1 <- tanh(0.99 * gx/sd(gx))        
    fc2 <- (fc1 - min(fc1))
    klr1 = klrpal[1 + round(15*fc2/max(abs(fc2)))]
    klr1 = paste0(col2hex(klr1),"88")
    
    par(mar=c(5,2,2.2,1), mgp=c(1,0.5,0))
    jj2 <- order(abs(fc1))
    plot( pos[jj2,], pch=20, cex=cex1, col=klr1[jj2], fg = gray(0.6), bty = "o",
         xaxt='n', yaxt='n', xlab="tSNE1", ylab="tSNE2")

    grp <- factor(ngs$samples[samples,]$group)
    ngrp <- length(unique(grp))
    if("cell.type" %in% colnames(ngs$samples) && ngrp>20) grp <- ngs$samples[samples,]$cell.type

    cex2 = ifelse(nrow(pos) < 50, 1.5, 1.1)
    cex2 = ifelse(nrow(pos) > 200, 0.8, cex2)
    if(0 && input$pr_labelmode=="legend") {
        legend("bottomright", legend=levels(grp), fill=klrpal,
               cex=cex2, y.intersp=0.8, bg="white")
    } else {
        ##grp.pos <- apply(pos,2,function(x) tapply(x,grp,mean))
        grp.pos <- apply(pos,2,function(x) tapply(x,grp,median))
        if(length(unique(grp))==1) {
            grp.pos <- matrix(grp.pos,ncol=2)
            rownames(grp.pos) <- unique(grp)
        }
        labels = rownames(grp.pos)
        cex3 <- c(1.4,1.2,1,0.8)[cut(length(labels),breaks=c(-1,5,10,20,999))]
        boxes = sapply(nchar(labels),function(n) paste(rep("\u2588",n),collapse=""))
        text( grp.pos, labels=boxes, cex=0.9*cex3, col="#CCCCCC88")
        text( grp.pos, labels=labels, font=2, cex=0.9*cex3, col="black")
        ##text( grp.pos[,], labels=rownames(grp.pos), font=2, cex=cex1**0.5)
    }
    ##title(gene, cex.main=1, line=0.5, col="grey40")
    title("t-SNE clustering", cex.main=1.2, line=0.8)
    

    ##----------------------------------------------------------------------
    ## Plot margins
    ##----------------------------------------------------------------------    

    ##par(mar=c(6,3.5,2,1), mgp=c(2.1,0.8,0), oma=c(2,0.5,2,0.5) )    
    par(mar=c(10,3.5,3,1), mgp=c(2.1,0.8,0))

    ##----------------------------------------------------------------------
    ## Bar/box plot
    ##----------------------------------------------------------------------    

    bee.cex = ifelse(length(gx)>500,0.1,0.2)
    bee.cex = c(0.3,0.1,0.05)[cut(length(gx),c(0,100,500,99999))]
    ##if(input$data_sampling=="grouped") {
    if(input$data_grouped) {
        ngrp <- length(unique(grp))
        cx1 = ifelse( ngrp < 10, 1, 0.8)
        cx1 = ifelse( ngrp > 20, 0.6, cx1)
        gx.b3plot( gx, grp, las=3, main=gene, ylab=ylab, ## col=klr0[ii], 
                  bar=TRUE, border=NA, ## bee = ifelse(length(gx) < 500,TRUE,FALSE), 
                  bee.cex=bee.cex, ## sig.stars=TRUE, max.stars=5,
                  xlab="", names.cex=cx1, srt=45, cex.main=1.2)
    }  else {
        jj <- 1:length(gx)
        sorting="no"
        ##if(PRO.VERSION) sorting <- input$data_sorting
        if(sorting == "decr")  jj <- order(-gx)
        if(sorting == "inc")  jj <- order(gx)
        tt=""
        barplot(gx[jj], col=klr[jj], las=3, cex.names=0.85,
                ylab=ylab, xlab=tt,
                main=gene, cex.main=1.2, border=NA,
                names.arg=rep(NA,length(gx)) )
        if(length(gx)<100) {
            cx1 = ifelse(length(gx) > 20, 0.85, 1)
            cx1 = ifelse(length(gx) > 40, 0.7, cx1)
            text((1:length(gx)-0.5)*1.2, -0.04*max(gx), names(gx)[jj], 
                 las=3, cex=cx1, pos=2, adj=0, offset=0, srt=60, xpd=TRUE)
        }
    }
    
    ##----------------------------------------------------------------------
    ## Correlation plot 
    ##----------------------------------------------------------------------
    
    ## corr always in log.scale and restricted to selected samples subset
    ## should match exactly the rawtable!!
    rho = cor(t(ngs$X[,samples]), ngs$X[pp,samples], use="pairwise")[,1]   
    rho[is.na(rho)] <- 0
    jj = head(order(-abs(rho)),30)
    jj <- c( head(order(rho),16), head(order(-rho),16))
    jj <- jj[order(-rho[jj])]
    top.rho = rho[jj]

    gx1 <- sqrt(rowSums(ngs$X[names(top.rho),samples]**2,na.rm=TRUE))
    gx1 <- (gx1 / max(gx1))
    klr1 <- rev(grey.colors(16,start=0.2,end=0.9,gamma=0.25))[1+round(15*gx1) ]
    klr1[which(is.na(klr1))] <- "#DDDDDD"
    names(top.rho) = sub(".*:","",names(top.rho))
    offset = min(top.rho)*0.95
    offset = 0
    barplot( top.rho - offset, col=klr1, ## horiz=TRUE,
            las=3, main=paste("top correlated genes\nwith",gene), 
            offset = offset, ylab="correlation (r)",
            ## names.arg=rep(NA,length(top.rho)), 
            cex.names=0.83, cex.main=1.2, border=NA)
    ##text( (1:length(top.rho) - 0.5)*1.2, offset, names(top.rho),
    ##col="black", cex=0.75, srt=90, pos=3, offset=0.4, font=1)
    legend("topright", legend=c("expr high","expr low"),
           fill=c("grey30","grey80"), cex=0.85, y.intersp=0.85)
    
    ##----------------------------------------------------------------------
    ## Waterfall plot
    ##----------------------------------------------------------------------

    if(input$data_type=="counts") {
        mean.fc <- sort(rowMeans(ngs$counts[,samples,drop=FALSE]),decreasing=TRUE)
        ylab="expression (counts)"
    }
    if(input$data_type=="CPM") {
        ##cpm <- edgeR::cpm(ngs$counts[,samples])
        cpm = 2**ngs$X[,samples,drop=FALSE]
        mean.fc <- sort(rowMeans(cpm),decreasing=TRUE)
        ylab="expression (CPM)"
    }
    if(input$data_type=="logCPM") {
        mean.fc <- sort(rowMeans(ngs$X[,samples,drop=FALSE]),decreasing=TRUE)
        ylab="expression (log2CPM)"
    }

    j <- which(sub(".*:","",names(mean.fc))==gene)
    ##j <- which(ngs$genes$gene_name==gene)
    plot( mean.fc, type="h", lwd=0.4, col="grey80", 
         main="average rank", cex.main=1.2,
         ylab=ylab, xlab="ordered genes", xaxt="n")
    points( j, mean.fc[j], type="h", lwd=2, col="black")
    text( j, mean.fc[j], gene, pos=3, cex=0.9)   
    
}, res=110)


output$data_geneInfo  <- renderUI({
    ##----------------------------------------------------------------------
    ## Gene info
    ##----------------------------------------------------------------------
    ##library(rentrez)
    ##genes <- entrez_summary(db="gene", id=c(718,720))
    ##genes$`720`$summary
    require(KEGG.db)
    require(GO.db)
    require(org.Hs.eg.db)
    
    gene="A1BG-AS1"
    gene = "CD4"
    gene <- input$search_gene
    gene = toupper(sub(".*:","",gene))

    eg = "1017"
    eg = names(which(as.list(org.Hs.egSYMBOL)==gene))
    eg <- mget(gene, env=org.Hs.egSYMBOL2EG, ifnotfound=NA)[[1]]
    if(is.na(eg)) eg <- mget(gene, env=org.Hs.egALIAS2EG, ifnotfound=NA)[[1]]
    eg
    eg = eg[1]
    if(is.null(eg) || length(eg)==0) return(NULL)
    
    output = "(gene info not available)"
    if(length(eg)>0 && !is.na(eg)) {
        ##as.list(org.Hs.egSYMBOL)[[eg]]
        info <- getHSGeneInfo(eg)  ## defined in pgx-functions.R
        if(input$data_geneinfo) {
            info <- c(info, getMyGeneInfo(eg, fields="summary"))  ## defined in pgx-functions.R
        }
        output <- c()
        for(i in 1:length(info)) {
            xx <- paste(info[[i]], collapse=", ")
            output[[i]] <- paste0("<b>",names(info)[i],"</b>: ",xx)
        }
        output <- paste(output, collapse="<p>")
    }    
    ##output <- paste0("<div style='background-color: #dde6f0;'>",output,"</div>")
    HTML(output)
})


output$data_corplot <- renderPlot({
    ##----------------------------------------------------------------------
    ## Correlation plot (stacked)
    ##----------------------------------------------------------------------

    require(RColorBrewer)
    ngs <- inputData()
    if(is.null(input$data_type)) return(NULL)
        
    ##samples=colnames(ngs$X);gene="CD4"
    samples <- selectSamplesFromSelectedLevels(ngs$Y, input$data_samplefilter)
    gene <- input$search_gene
    if(is.null(gene)) return(NULL)    
    
    ## corr always in log.scale and restricted to selected samples subset
    zx <- ngs$X
    grp <- ngs$samples$group
    dim(zx)
    if( length(grp) >= 5 && ncol(zx) > 50) {
        zx <- t( apply(ngs$X, 1, function(x) tapply(x,grp,mean)))
    }
    head(zx)
    rownames(zx) <- toupper(sub(".*:","",rownames(zx)))  ## NEED RETHINK!
    
    xref <- list("this_data"=zx, HPA_tissue=as.matrix(TISSUE),
                 ImmProt=as.matrix(IMMPROT))
    gene0 <- toupper(gene)  ## uppercase mouse
    R <- pgx.getGeneCorrelation(gene0, xref=xref)    
    if(is.null(R)) return(NULL)
    
    rho.genes = as.character(ngs$genes$gene_name)
    if("hgnc_symbol" %in% colnames(ngs$genes)) {
        rho.genes = as.character(ngs$genes$hgnc_symbol)
    }
    R <- R[match(rho.genes,rownames(R)),,drop=FALSE]
    rownames(R) <- rho.genes
            
    ## get top correlated genes
    ##jj = head(order(rowSums(R),decreasing=FALSE),35)
    rsum <- rowSums(R,na.rm=TRUE)
    jj = head(order(abs(rsum),decreasing=TRUE),35)
    jj = head(order(-abs(rsum)),30)
    jj <- c( head(order(rsum),20), head(order(-rsum),20))
    jj <- jj[order(-rsum[jj])]
    head(rsum[jj])
    Rtop = R[jj,,drop=FALSE]
    rownames(Rtop) = sub(".*:","",rownames(Rtop))
    offset = min(Rtop, na.rm=TRUE)*0.95
    offset=0
    klr <- grey.colors(ncol(Rtop),start=0.3,end=0.7)
    
    ## plot
    par(mar=c(8,4,2,1), mgp=c(2.2,0.8,0))
    barplot( t(Rtop) - offset, col=klr, border=NA, ##horiz=TRUE, 
            las=3, cex.names=0.80, ##names.arg=rep(NA,nrow(R)),
            offset = offset, ylab="cumulative correlation (r)",            
            cex.main=1.2, main="cumulative correlation\nwith other data sets")
    if(!is.null(colnames(Rtop))) {
        legend("topright", legend=rev(colnames(Rtop)), fill=rev(klr),
               cex=0.8, y.intersp=0.8)
    }

}, res=74)


output$data_tissueplot <- renderPlot({
    ##----------------------------------------------------------------------
    ## Tissue expression plot
    ##----------------------------------------------------------------------
    ngs <- inputData()
    if(is.null(input$data_type)) return(NULL)

    gene <- input$search_gene
    pp <- rownames(ngs$genes)[match(gene,ngs$genes$gene_name)]    
    hgnc.gene = toupper(as.character(ngs$genes[pp,"gene_name"]))
    
    require(RColorBrewer)
    par(mar=c(8,4,2,1), mgp=c(2.2,0.8,0))
    if( hgnc.gene %in% rownames(TISSUE)) {
        tx = TISSUE[hgnc.gene,]
        grp = TISSUE.grp[names(tx)]
        tissue.klr = COLORS[grp]
        ylab="expression (TPM)"
        if(input$data_type=="logCPM") {
            ylab = "expression (log2TPM)"
            tx = log(1 + tx)
        }
        jj <- 1:length(tx)
        sorting="no"
        ##if(PRO.VERSION) sorting=input$data_sorting
        if(sorting=="decr") jj <- order(-tx)
        if(sorting=="inc") jj <- order(tx)
        barplot(tx[jj], las=3, main=hgnc.gene, cex.main=1.2, 
                col = tissue.klr[jj], border=NA,
                ylab=ylab, cex.names=0.9, names.arg=rep(NA,length(tx)) )
        text((1:length(tx)-0.5)*1.2, -0.04*max(tx), names(tx)[jj], las=3,
             cex=0.95, pos=2, adj=0, offset=0, srt=55, xpd=TRUE)
        title(main="tissue expression", line=-0.3, cex.main=1.1)
    } else {
        frame()
    }
    
}, res=74)
```


### Counts 

```{r echo=FALSE, warning=FALSE, fig.height=5, fig.width=10}
renderPlot({
    ngs = inputData()
    if(is.null(ngs)) return(NULL)
    
    validate(need("counts" %in% names(ngs), "no 'counts' in object."))    
    subtt=NULL

    samples = colnames(ngs$X)
    samples <- selectSamplesFromSelectedLevels(ngs$Y, input$data_samplefilter)
    nsamples = length(samples)
    if("counts" %in% names(ngs)) {
        counts = ngs$counts[,samples,drop=FALSE]
    } else {
        cat("WARNING:: no counts table. estimating from X\n")
        counts = pmax(2**ngs$X - 1,0)
        k = grep("lib.size",colnames(ngs$samples))[1]
        if(length(k)>0) {
            libsize = ngs$samples[colnames(counts),k]
            libsize
            counts = t(t(counts) * libsize)
        }
        ##counts <- round(counts)
    }    
    if(sum(is.na(counts))>0) {
        cat("WARNING:: plot counts: counts has missing values!\n")
    }

    ##if(input$data_sampling=="grouped") {
    gr = ngs$Y[samples,"group"]
    grps = sort(unique(gr))
    if(input$data_grouped && length(grps)>1 ) {
        newx = c()
        for(g in grps) {
            mx = rowMeans(counts[,which(gr==g),drop=FALSE], na.rm=TRUE)
            newx = cbind(newx, mx)
        }
        if(NCOL(newx)==1) newx <- matrix(newx,ncol=1)
        rownames(newx) = rownames(counts)
        colnames(newx) = grps
        counts = newx
    }
    
    if(ncol(counts) > 500) {
        kk <- sample( ncol(counts), 400)
        counts <- counts[,kk,drop=FALSE]
        subtt=c(subtt,"random subset")
    }
    colnames(counts) <- substring(colnames(counts),1,24)
    
    gset <- list()
    gg = ngs$genes[rownames(counts),]$gene_name
    tt = ngs$genes[rownames(counts),]$gene_title
    g1 <- gg[grep("^rpl|^rps",gg,ignore.case=TRUE)]
    g2 <- gg[grep("^mrpl|^mrps",gg,ignore.case=TRUE)]
    g3 <- gg[grep("^MT-",gg,ignore.case=TRUE)]
    g4 <- gg[grep("mitochondr",tt,ignore.case=TRUE)]
    gset[["Ribosomal (RPL/RPS)"]] = g1
    gset[["Mitochondrial ribosomal (MRPL/MRPS)"]] = g2
    gset[["Mitochondrial (MT)"]] = g3
    gset[["Other mitochondrial"]] = setdiff(g4,g3)
    jj <- grep("mitochondr|ribosom",names(FAMILIES),invert=TRUE,ignore.case=TRUE)
    gset.other <- lapply( FAMILIES[jj], function(x) setdiff(x, c(g1,g2,g3,g4)))
    gset <- c(gset, gset.other)
    gset <- gset[grep("<all>",names(gset),invert=TRUE)]
    gset <- gset[sapply(gset,length) > 10]
    
    ## Counts per samples, by category
    total.counts = Matrix::colSums(counts,na.rm=TRUE)
    summed.counts = t(sapply(gset, function(f)
        Matrix::colSums(counts[which(gg %in% f),,drop=FALSE], na.rm=TRUE)))
    avg.counts   = t(sapply(gset, function(f)
        Matrix::colMeans(counts[which(gg %in% f),,drop=FALSE], na.rm=TRUE)))
    prop.counts = 100 * t(t(summed.counts) / total.counts)
    
    head(sort(rowSums(prop.counts,na.rm=TRUE),decreasing=TRUE),10)
    head(sort(rowSums(avg.counts,na.rm=TRUE),decreasing=TRUE),10)
    ##jj <- order(-apply(avg.counts,1,sd,na.rm=TRUE))

    jj <- head(order(-rowSums(prop.counts,na.rm=TRUE)),6)
    ##summed.counts <- summed.counts[jj,,drop=FALSE]
    prop.counts <- prop.counts[jj,,drop=FALSE]    
    jj <- head(order(-rowSums(avg.counts,na.rm=TRUE)),6)
    avg.counts  <- avg.counts[jj,,drop=FALSE]
    sorting="no"
    ##if(PRO.VERSION) sorting <- input$data_sorting
    if(sorting=="decr") {
        total.counts <- sort(total.counts, decreasing=TRUE)
        prop.counts  <- prop.counts[,order(-colMeans(prop.counts))]
        avg.counts   <- avg.counts[,order(-colMeans(avg.counts))]
        counts <- counts[,order(-colMeans(counts))]
    }
    if(sorting=="inc") {
        total.counts <- sort(total.counts, decreasing=FALSE)
        prop.counts  <- prop.counts[,order(colMeans(prop.counts))]
        avg.counts   <- avg.counts[,order(colMeans(avg.counts))]
        counts <- counts[,order(colMeans(counts))]
    }
    
    ss <- names(total.counts)
    prop.counts  <- prop.counts[,ss,drop=FALSE]
    avg.counts   <- avg.counts[,ss,drop=FALSE]
    counts <- counts[,ss,drop=FALSE]

    n=1000
    gx.hist <- function(gx, n=1000, main="",ylim=NULL) {
        jj <- 1:nrow(gx)
        if(length(jj)>n) jj <- sample(jj,n)
        h0 <- hist(as.vector(c(gx[jj],min(gx),max(gx))),
                   breaks=120, main=main, border=FALSE,
                   col="grey", freq=FALSE, ## ylim=ylim,
                   xlim=c(min(gx),max(gx)),
                   xlab="expression (log2)")
        i = 1
        for(i in 1:ncol(gx)) {
            h1 <- hist(gx[jj,i], breaks=h0$breaks,plot=FALSE)
            ##lines( h0$mids, h1$density, col=i+1 )
            lines( h0$mids, h1$density, col="black", lwd=0.5 )
        }
    }
        
    log2counts <- log2(1 + counts)
    ##log2counts[which(log2counts==0)] <- NA
    jj <- sample(nrow(counts),100)
    jj <- sample(nrow(counts),1000)

    ## create the plots
    par(mfrow=c(2,3), mar=c(9,4,3,1.5), mgp=c(2.4,0.7,0),
        oma=c(1,1,1,1)*0.2 )    
    cx1=1
    if(length(total.counts)>12) cx1=0.9
    if(length(total.counts)>30) cx1=0.8
    if(length(total.counts)>50) cx1=0.7
    if(length(total.counts)>80) cx1=0.6

    if(1) {
       names(total.counts) <- substring(names(total.counts),1,30)
       colnames(log2counts) <- substring(colnames(log2counts),1,30)
       colnames(prop.counts) <- substring(colnames(prop.counts),1,30)
       colnames(avg.counts) <- substring(colnames(avg.counts),1,30)
    }

    ## ----------- total counts
    ##barplot( summed.counts, las=3, main="cumulative counts")
    subtt0=""
    if(!is.null(subtt)) subtt0 <- paste0("\n(",paste(subtt,collapse=","),")")
    barplot( total.counts/1e6, las=3,
            main=paste("total counts",subtt0),
            col="grey40", cex.names=cx1, ylab="counts (million)",
            ylim=c(0,max(total.counts)/1e6)*1.1 )
    boxplot( log2counts[jj,], col="grey70", main="counts distribution",
            las=3, cex.axis=cx1, ylab="counts (log2)")
    gx.hist( gx=log2counts[jj,], n=2000, main="histogram" )
        
    ## ----------- gene type counts
    ymax = max(colSums(prop.counts, na.rm=TRUE))
    barplot( prop.counts, las=3, main="abundance of major gene types",
            cex.names=cx1, ylim=c(0,ymax)*1.6, ylab="abundance (%)" )   
    legend("topleft", legend=rev(rownames(prop.counts)),
           fill=rev(grey.colors(nrow(prop.counts))),
           cex=0.8, y.intersp=0.8, bty="n")

    ymax = max(colSums(avg.counts, na.rm=TRUE))
    barplot( avg.counts, las=3, main="average count by gene type",
            cex.names=cx1, ylim=c(0,ymax)*1.6, ylab="average count")    
    legend("topleft", legend=rev(rownames(avg.counts)),
           fill=rev(grey.colors(nrow(avg.counts))),
           cex=0.8, y.intersp=0.8, bty="n")

}, res=120)
```

### Gene table

```{r echo=FALSE}
fillRow( flex=c(1),
    ##flex=c(1,0.05,8),
    ##textAreaInput("data_customlist",NULL, rows=10,
    ##              placeholder="Paste your gene list" ),
    ##br(),
    dataTableOutput('data_rawdataTable')
)

observe({
    
})

output$data_rawdataTable <- DT::renderDataTable({
    ## get current view of raw_counts
    ngs = inputData()
    if(is.null(ngs)) return(NULL)

    pp <- rownames(ngs$X)
    if(input$data_type=="counts") {
        x <- ngs$counts[pp,]
    } else if(input$data_type=="CPM") {
        ##x <- 2**ngs$X
        x <- edgeR::cpm(ngs$counts[pp,])
    } else {
        ## log2CPM
        x <- ngs$X[pp,]
    }
    x0=x
    
    ##------------------ select samples
    x <- x[,]
    samples <- colnames(ngs$X)
    samples <- selectSamplesFromSelectedLevels(ngs$Y, input$data_samplefilter)
    samples <- intersect(colnames(x),samples)
    x <- x[,samples,drop=FALSE]
    
    gene = "CD3E"
    gene = "CCR6"
    gene = input$search_gene
    ##xgene = sub(".*:","",rownames(x))

    rho = NULL
    if(1) {
        k=1
        ##k <- which(xgene==gene)
        ##logx <- log2(1 + edgeR::cpm(ngs$counts))
        ##logx <- logx[rownames(x),]
        logx <- ngs$X[rownames(x),]
        xgenes <- ngs$genes[rownames(x),"gene_name"]
        k <- which(xgenes==gene)
        rho = cor( t(logx[,samples]), logx[k,samples], use="pairwise")[,1]
        rho = round(rho[rownames(x)], digits=3)
        sdx = round(apply(logx[,samples],1,sd),digits=3)
    }
    
    ##if(input$data_sampling=="grouped") {
    do.grouped <- input$data_grouped
    if(length(samples)>500) do.grouped <- TRUE
    if(do.grouped) {
        group = ngs$Y[colnames(x),"group"]
        allgroups = sort(unique(group))
        newx = c()
        for(gr in allgroups) {
            mx = rowMeans(x[,which(group==gr),drop=FALSE],na.rm=TRUE)
            newx = cbind(newx, mx)
        }
        rownames(newx) = rownames(x)
        colnames(newx) = paste0("[",allgroups,"]")
        x = newx
    }

    x = round( as.matrix(x), digits=3)
    x95 = quantile(as.vector(x0[which(x0>0)]),probs=0.95)
    x99 = quantile(as.vector(x0[which(x0>0)]),probs=0.99)
    
    if(NCOL(x)==0 || nrow(x)==0) return(NULL)
    ##rownames(x) = sub(".*:","",rownames(x))
    xgenes <- ngs$genes[rownames(x),"gene_name"]
    gene.title <- GENE.TITLE[toupper(xgenes)]
    gene.title <- substring(gene.title,1,50)
    x = data.frame( gene=xgenes, title=gene.title, rho=rho, SD=sdx, as.matrix(x), check.names=FALSE)
    if(!is.null(rho)) {
        x = x[order(-abs(x$rho)),,drop=FALSE]
    } else {
        x = x[order(-x$SD),,drop=FALSE]
    }

    ## put selected gene always on top
    j1 <- which(x$gene==gene)
    jj <- c(j1, setdiff(1:nrow(x),j1))
    x <- x[jj,,drop=FALSE]
    
    DT::datatable( x, rownames=FALSE,
                  class = 'compact cell-border stripe hover',
                  extensions = c('Buttons','Scroller'),
                  selection = list(mode='single', target='row', selected=1),
                  options=list(
                      dom = 'Blfrtip', 
                      buttons = list('copy','csv',
                                     list(extend='pdf',
                                          pageSize="A3", orientation='landscape', 
                                          filename="datatable", title="")),
                      ##pageLength = 60,##  lengthMenu = c(20, 30, 40, 60, 100, 250),
                      scroller=TRUE, scrollX = TRUE, scrollY = 800, 
                      deferRender=TRUE
                  )  ## end of options.list 
                  ) %>%
        DT::formatStyle(0, target='row', fontSize='11px', lineHeight='70%') %>%
            DT::formatStyle(colnames(x),
                            background = styleColorBar(c(0,x99), 'lightblue'),
                            backgroundSize = '98% 88%',
                            backgroundRepeat = 'no-repeat',
                            backgroundPosition = 'center')
})



```

### Sample table

```{r echo=FALSE}
fillRow( flex=c(1,0.05,8),
        radioButtons('data_sampletabletype','type:', ## inline=TRUE,
                     choices=c("sample info","contrasts")),
        br(), 
        dataTableOutput('data_sampleTable')
        )


output$data_sampleTable <- DT::renderDataTable({
    ## get current view of raw_counts
    ngs = inputData()
    if(is.null(ngs)) return(NULL)

    ##if(is.null(input$data_samplefilter)) return(NULL)    
    dt <- NULL
    if(input$data_sampletabletype=="sample info") {
        samples <- selectSamplesFromSelectedLevels(ngs$Y, input$data_samplefilter)
        dt <- ngs$samples[samples,]
    }
    if(input$data_sampletabletype=="contrasts") {
        samples <- selectSamplesFromSelectedLevels(ngs$Y, input$data_samplefilter)
        names(ngs$model.parameters)
        dt <- sign(ngs$model.parameters$exp.matrix[samples,])
        colnames(dt) <- sub("_vs_","\nvs ",colnames(dt))
    }
    
    DT::datatable( dt,
                  class = 'compact cell-border stripe hover',
                  rownames = TRUE,
                  extensions = c('Buttons','Scroller'),
                  selection = list(mode='single', target='row', selected=1),
                  options=list(
                      dom = 'Blfrtip', 
                      buttons = list('copy','csv',
                                     list(extend='pdf',
                                          ##pageSize="A3", orientation='landscape', 
                                          filename="sampletable", title="")),
                      ##pageLength = 60, ##  lengthMenu = c(20, 30, 40, 60, 100, 250),
                      scroller=TRUE, scrollX = TRUE, scrollY = 800,
                      deferRender=TRUE
                  )) %>%
        DT::formatStyle(0, target='row', fontSize='12px', lineHeight='70%') 

}) 
```

`r if(!PRO.VERSION) {"<!--------------------------------------------- "}`

### Resource info

```{r echo=FALSE, warning=FALSE}
fillRow(
    flex = c(5,0.5, 2,0.5, 1.5,0.5, 3), ## width = 600,
    dataTableOutput('timings'), br(),
    dataTableOutput('objectdims'), br(),
    dataTableOutput('objectsize'), br(),
    br()
    )

output$timings <- DT::renderDataTable({
    ngs <- inputData()
    if(is.null(ngs)) return(NULL)
    ##if(is.null(ngs$timings)) return(NULL)
    D <- data.frame()
    if(!is.null(ngs$timings)) {
        D <- round(ngs$timings[,1:3],digits=3)
        D <- apply(D, 2, function(x) tapply(x, rownames(D), sum))
        catg <- gsub("^\\[|\\].*","",rownames(D))
        metd <- gsub("^.*\\]","",rownames(D))
        D <- data.frame(category=catg, method=metd, D)
    }
    DT::datatable( D, rownames=FALSE, caption="TIMINGS",
                  options = list(dom='tp', pageLength = 100),
                  class = 'compact cell-border stripe hover' ) %>%
        DT::formatStyle(0, target='row', fontSize='11px', lineHeight='70%')
})

output$objectdims <- DT::renderDataTable({
    ngs <- inputData()
    if(is.null(ngs)) return(NULL)

    dims1 <- lapply( ngs, dim)
    lens <- lapply( ngs, length)
    dims2 <- t(sapply( ngs[which(!sapply(dims1,is.null)) ], dim))
    kk <- which(sapply(dims1,is.null))
    dims2 <- rbind(dims2, cbind(lens[kk],0))
    colnames(dims2) = c("nrows","ncols")
    D = data.frame( object=rownames(dims2), dims2, check.names=FALSE)
    DT::datatable( D, rownames=FALSE, caption="OBJECT DIMENSIONS",
                  options = list(dom='t', pageLength = 50), 
                  class = 'compact cell-border stripe hover') %>%
        DT::formatStyle(0, target='row', fontSize='11px', lineHeight='70%')
})

output$objectsize <- DT::renderDataTable({
    ngs <- inputData()
    if(is.null(ngs)) return(NULL)
    objsize <- sapply(ngs,object.size)
    objsize <- round( objsize/1e6, digits=2)
    D = data.frame( object=names(ngs), "size.Mb"=objsize, check.names=FALSE)
    DT::datatable( D, rownames=FALSE, caption="OBJECT SIZES",
                  options = list(dom='t', pageLength = 50), 
                  class = 'compact cell-border stripe hover') %>%
        DT::formatStyle(0, target='row', fontSize='11px', lineHeight='70%')
})

```

`r if(!PRO.VERSION) {"----------------------------------------->"}`

