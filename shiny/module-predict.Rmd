Biomarker
================================================================================

Inputs {.sidebar data-width=250}
--------------------------------------------------------------------------------

<br> Feature selection and prediction module.

<br><br>

```{r}
radioButtons('pdx_vartype',NULL,c("contrast","phenotype"),inline=TRUE)
selectInput("pdx_contrast",NULL, choices=NULL)
selectInput("pdx_level","Level:", choices=c("gene","geneset"))
selectInput("pdx_filter","Filter:", choices=NULL)
selectizeInput("pdx_select","Custom select:", choices=NULL, multiple=TRUE)
##checkboxInput('pdx_normalize','normalize',TRUE)
br();br();br();
if(PRO.VERSION) checkboxInput('pdx_showloops','detect loops',FALSE)
if(PRO.VERSION) checkboxInput('pdx_posonly','pos.only',FALSE)
##if(DEV.VERSION) checkboxInput('pdx_multiomics','multi-omics',FALSE)

input_pdx_select <- reactive({
    input$pdx_select
}) %>% debounce(3000)

observe({
    ngs <- inputData()
    if(is.null(ngs)) return(NULL)
    ct <- colnames(ngs$model.parameters$contr.matrix)
    if(input$pdx_vartype=="phenotype") {
        ct <- colnames(ngs$Y)
    }
    cat("<predict::observe1> updating pdx_contrast...\n")
    updateSelectInput(session, "pdx_contrast", choices=ct )
    
})

observe({
    ngs <- inputData()
    if(is.null(ngs)) return(NULL)
    cat("<module-predict:observe2>\n")    
    if(input$pdx_level=="geneset") {
        ft <- names(COLLECTIONS)
        nn <- sapply(COLLECTIONS, function(x) sum(x %in% rownames(ngs$gsetX)))
        ft <- ft[nn >= 10]
    } else {
        ## gene level
        ft <- pgx.getExtendedFamilies(ngs,10)
    }
    cat("<predict::observe2> updating pdx_filter: len.ft=",length(ft),"\n")
    ft <- sort(ft)
    updateSelectInput(session, "pdx_filter", choices=ft )    
})

observe({
    ngs <- inputData()
    if(is.null(ngs)) return(NULL)
    ft <- input$pdx_filter
    ct <- input$pdx_contrast
    if(is.null(ft)) return(NULL)
    if(is.null(ct)) return(NULL)    
    
    cat("<predict:observe3>\n")

    if(ft=="") return(NULL)
    if(ct=="") return(NULL)    
    
    if(input$pdx_level=="geneset") {
        if(!ft %in% names(COLLECTIONS)) return(NULL)
        pp <- COLLECTIONS[[ft]]              
        pp <- intersect(pp, rownames(ngs$gsetX))
        if(input$pdx_vartype=="contrast") {
            if(!ct %in% names(ngs$gset.meta$meta)) return(NULL)    
            ii <- which( ngs$gset.meta$meta[[ct]]$meta.p < 0.05 &
                         abs(ngs$gset.meta$meta[[ct]]$meta.fx) > 0.5 )
            sig <- rownames(ngs$gset.meta$meta[[ct]])[ii]
            pp <- intersect(sig,pp)
        }
    } else {
        xfam <- c(names(ngs$families),names(GSETS))
        if(!ft %in% xfam) return(NULL)
        sel <- ngs$genes$gene_name
        sel <- NULL
        if(ft %in% names(ngs$families)) sel <- ngs$families[[ft]]
        if(ft %in% names(GSETS)) sel <- GSETS[[ft]]
        xgene <- ngs$genes[rownames(ngs$X),"gene_name"]
        sel <- intersect(sel, xgene)
        pp = filterProbes(ngs$genes, sel)
        length(pp)
        if(input$pdx_vartype=="contrast") {
            if(!ct %in% names(ngs$gx.meta$meta)) return(NULL)    
            ii <- which( ngs$gx.meta$meta[[ct]]$meta.p < 0.05 &
                         abs(ngs$gx.meta$meta[[ct]]$meta.fx) > 0.5 )
            sig <- rownames(ngs$gx.meta$meta[[ct]])[ii]
            pp <- intersect(sig,pp)
        }
    }
    pp <- c("",pp)
    updateSelectInput(session, "pdx_select", choices=pp, sel="")    

})

```


Col {.tabset data-width=650}
----------------------------------------------------------------------------------------

### Importance
    
```{r message=FALSE, warning=FALSE, fig.width=4}

fillRow(flex = c(1.2,0.1,1), 
        fillCol(flex = c(0.7,1), 
                plotOutput('pdx_importanceplot'),
                plotOutput('pdx_heatmap')
                ),
        br(), ## spacer
        fillCol(flex = c(1,0.8), 
                ##plotOutput('pdx_decisiontree'),
                uiOutput('pdx_decisiontree'),
                plotOutput('pdx_boxplots')
                )
        )

calcVariableImportance <- reactive({

    ngs <- inputData()
    if(is.null(ngs)) return(NULL)
    
    ct=2
    ct=1
    colnames(ngs$Y)
    ct <- input$pdx_contrast
    if(is.null(ct)) return(NULL)

    NFEATURES=50
    
    cat("calcVariableImportance:: 1\n")
    
    if(input$pdx_vartype=="contrast") {
        cts <- colnames(ngs$model.parameters$exp.matrix)
        if(!(ct %in% cts)) return(NULL)
        y0 <- ngs$model.parameters$exp.matrix[,ct]
        y0 <- y0[which(y0!=0)]
        y <- 1*(y0>0)
        if(1 && grepl("_vs_|_VS_",ct)) {
            cls <- strsplit(ct, split="_vs_|_VS_")[[1]]
            y[which(y==1)] <- cls[1]
            y[which(y==0)] <- cls[2]
        }

    }
    if(input$pdx_vartype=="phenotype") {
        if(!(ct %in% colnames(ngs$Y))) return(NULL)
        y0 <- ngs$Y[,ct]
        names(y0) <- rownames(ngs$Y)
        y <- y0[!is.na(y0)]
    }
    table(y)
    if(length(y)<40) y <- head(rep(y,10),100)  ## augment to 100 samples
    table(y)

    cat("calcVariableImportance:: 2\n")
    
    ##-------------------------------------------
    ## select features
    ##-------------------------------------------
    if(input$pdx_vartype=="contrast") {
        ## contrast prediction
        if(input$pdx_level=="geneset") {
            ii <- which( ngs$gset.meta$meta[[ct]]$meta.p < 0.05 &
                         abs(ngs$gset.meta$meta[[ct]]$meta.fx) > 0.5 )
            sel <- rownames(ngs$gset.meta$meta[[ct]])[ii]
            X <- ngs$gsetX[sel,names(y)]
        } else {
            ii <- which( ngs$gx.meta$meta[[ct]]$meta.p < 0.05 &
                         abs(ngs$gx.meta$meta[[ct]]$meta.fx) > 0.5 )
            sel <- rownames(ngs$gx.meta$meta[[ct]])[ii]
            X <- ngs$X[sel,names(y)]
        }
    } else {
        ## group prediction
        if(input$pdx_level=="geneset") {
            X <- ngs$gsetX[,names(y)]
        } else {
            X <- ngs$X[,names(y)]
        }
    }
    
    ## ----------- filter with selected features
    ft="<all>"
    ft <- input$pdx_filter
    if(is.null(ft)) return(NULL)

    if(input$pdx_level=="geneset") {
        if(!(ft %in% names(COLLECTIONS))) return(NULL)
        pp <- COLLECTIONS[[ft]]
    } else {
        xfam <- c(names(ngs$families),names(GSETS))
        if(!ft %in% xfam) return(NULL)
        gg <- GSETS[[8]]
        gg <- NULL
        if(ft %in% names(ngs$families)) gg <- ngs$families[[ft]]
        if(ft %in% names(GSETS)) gg <- GSETS[[ft]]
        pp = filterProbes(ngs$genes, gg)
    }
    pp <- intersect(pp,rownames(X))
    X <- X[pp,,drop=FALSE]

    ## ------------- filter with user selection
    ##sel <- input$pdx_select
    sel <- input_pdx_select()
    if(!is.null(sel) && length(sel)>0) {
        if(sel[1]!="") {
            pp <- intersect(rownames(X),sel)
            X <- X[pp,,drop=FALSE]
        }
    }
    
    ## ----------- restrict to top 100
    dim(X)
    X <- head(X[order(-apply(X,1,sd)),,drop=FALSE], 10*NFEATURES)  ## top 100
    sdx <- mean(apply(X,1,sd))
    X <- X + 0.25*sdx*matrix(rnorm(length(X)),nrow(X),ncol(X))  ## add some noise
    dim(X)

    ##-------------------------------------------
    ## compute importance values
    ##-------------------------------------------
    if(grepl("survival",ct)) {
        time <- abs(y)
        status <- (y > 0) ## dead is positive time
        methods=c("glmnet","randomforest","boruta","xgboost","pls")
        methods=c("glmnet","randomforest","xgboost","pls")
        P <- pgx.survivalVariableImportance(
            X, time=time, status=status, methods=methods)    
    } else {
        methods=c("glmnet","randomforest","boruta","xgboost","pls")
        methods=c("glmnet","randomforest","xgboost","pls")
        X1=X;y1=y
        names(y1) = colnames(X1) = paste0("x",1:ncol(X))
        P <- pgx.multiclassVariableImportance(X1, y1, methods=methods)    
        ##P <- pgx.variableImportance(X1, y1, methods=methods)
    }
    P <- abs(P)
    head(P)
    
    P[is.na(P)] <- 0
    P[is.nan(P)] <- 0
    P <- t( t(P) / (1e-3+apply(P,2,max,na.rm=TRUE)))
    ##P <- pmax(P,0.1)
    P <- P[order(-rowSums(P,na.rm=TRUE)),,drop=FALSE]
    head(P)

    R <- P
    if(nrow(R)>1) {
        R <- (apply(P,2,rank)/nrow(P))**4
        R <- R[order(-rowSums(R)),,drop=FALSE]
        head(R)
    }
        
    ##------------------------------
    ## create partition tree
    ##------------------------------
    require(rpart)
    sel <- head(rownames(R),100)
    sel <- head(rownames(R),NFEATURES)  ## top50 features
    sel <- intersect(sel,rownames(X))
    tx <- t(X[sel,,drop=FALSE])
    colnames(tx) <- gsub("[: +-.,]","_",colnames(tx))
    colnames(tx) <- gsub("[')(]","",colnames(tx))
    jj <- names(y)
    ##ny <- length(unique(y))
    ##if(length(jj) < ny*20) jj <- c(jj,jj,jj)
    if(grepl("survival",ct)) {
        require(survival)
        time <- abs(y)
        status <- (y>0) ## dead if positive time
        df <- data.frame( time=time+0.001, status=status, tx)
        ##df <- df[jj,]
        rf <- rpart( Surv(time,status) ~ ., data=df)
    } else {
        df <- data.frame( y=y, tx)
        ##df <- df[jj,]
        rf <- rpart( y ~ ., data=df)
    }
    table(rf$where)
    rf$cptable

    rf.nsplit <- rf$cptable[,"nsplit"]
    max(rf.nsplit)
    length(unique(y)) 
    if(grepl("survival",ct)) {
        MAXSPLIT = 4  ## maximum five groups....
    } else {
        MAXSPLIT = 1.5*length(unique(y))  ## maximum N+1 groups
    }
    if( max(rf.nsplit) > MAXSPLIT) {
        cp.idx <- max(which(rf.nsplit <= MAXSPLIT))
        cp0 <- rf$cptable[cp.idx,"CP"]
        ##rf <- prune(rf, cp=0.05)
        rf <- prune(rf, cp=cp0)
    }
    table(rf$where)
    
    cat("calcVariableImportance:: end\n")
    ##y <- y[rownames(ngs$samples)]
    ##tx <- tx[names(y),]
    y <- y[rownames(tx)]
    res <- list(P=P, R=R, y=y, X=t(tx), rf=rf)

    return(res)
})


output$pdx_importanceplot <- renderPlot({
    
    res <- calcVariableImportance()
    if(is.null(res)) return(NULL)
    P <- res$P    
    P <- res$R
    P <- P[order(-rowSums(P,na.rm=TRUE)),,drop=FALSE]
    P <- pmax(P,0.05)

    if(input$pdx_level=="geneset") {
        par(mfrow=c(1,2), oma=c(1,1,1,1)*0.5, mgp=c(2.2,0.8,0))
        par(mar=c(4,8,2,4))
        frame()
        P.top <- head(P,20)
        rownames(P.top) <- tolower(rownames(P.top))
        rownames(P.top) <- substring(rownames(P.top),1,60)
        barplot( t(P.top), las=1, horiz=TRUE,
                cex.names=0.95, xlab="cumulative importance" )
        klr <- grey.colors(ncol(P))
        legend("topright",
               legend = colnames(P), fill=klr,
               cex=0.8, y.intersp=0.85, inset=c(-0.25,0), xpd=NA )

    } else {
        par(mfrow=c(1,1), oma=c(1,1,1,1)*0.5)
        par(mar=c(7,4,2,4))
        P.top <- head(P,50)
        barplot( t(P.top), las=3, horiz=FALSE,
                cex.names=0.9, ylab="cumulative importance" )
        klr <- grey.colors(ncol(P))
        legend("topright",
               legend=rev(colnames(P)), fill=rev(klr),
               cex=0.9, y.intersp=0.85 )
    }
    title("Variable importance", cex.main=1.2, line=1.2, adj=0.3)
    
}, res=70)

output$pdx_decisiontree <- renderUI({

    res <- calcVariableImportance()
    if(is.null(res)) return(NULL)
    is.surv <- grepl("Surv",res$rf$call)[2]
    is.surv
    if(is.surv) {
        plotOutput("pdx_decisiontreeSurv")
    } else {
        ##visNetworkOutput("pdx_decisiontreeClass")
        plotOutput("pdx_decisiontreeClass")
    } 
})
    
output$pdx_decisiontreeSurv <- renderPlot({    
    res <- calcVariableImportance()
    if(is.null(res)) return(NULL)
    
    ##install.packages("rpart.plot")
    require(rpart)
    require(rpart.plot)
    par(mfrow=c(1,1), mar=c(1,0,2,0))
    
    ##ct <- input$pdx_contrast
    ##is.surv <- ( input$pdx_vartype=="phenotype" &
    ##             grepl("survival",ct))
    ##install.packages("partykit")
    require(survival)
    require("partykit")
    (rf <- as.party(res$rf))
    ##(rf <- as.party(prune(res$rf, cp=0.05)))
    plot(rf)
    title("Survival tree",cex=1.2,line=0.9,adj=0.35)
    table(res$rf$where)
})

##output$pdx_decisiontreeClass <- renderVisNetwork({
output$pdx_decisiontreeClass <- renderPlot({    
    res <- calcVariableImportance()
    if(is.null(res)) return(NULL)
    
    ##install.packages("rpart.plot")
    require(rpart)
    ##par(mfrow=c(1,1), mar=c(1,0,2,0))
    require(visNetwork)
    require(rpart.plot)
    if(1) {
        rpart.plot(res$rf)
        title("Classification tree",cex=1.2,line=3,adj=0.35)
    } else {
        visTree(res$rf, main="Classification tree",width="100%",legend=FALSE) %>%
            visInteraction(tooltipStyle='position:fixed;visibility:hidden;padding:5px;white-space:nowrap;font-family:helvetica;font-size:10px;background-color:lightgrey;')
    }
})    

output$pdx_boxplots <- renderPlot({
    res <- calcVariableImportance()
    if(is.null(res)) return(NULL)

    cat("pdx_boxplots:: called\n")    
    vars <- setdiff(res$rf$frame$var,"<leaf>")
    vars
    if(length(vars)==0) return(NULL)
    
    cat("pdx_boxplots:: vars=",vars,"\n")
    vars0 <- setdiff(vars,rownames(res$X))
    cat("pdx_boxplots:: vars0=",vars0,"\n")
    vars <- intersect(vars, rownames(res$X))

    ## add some other variables
    if(1 && length(vars)<8) {
        jj <- order(-rowSums(res$R,na.rm=TRUE))
        top.vars <- rownames(res$R)[jj]
        vars <- head(unique(c(vars,top.vars)),8)
    }
    
    y <- res$y
    is.surv <- grepl("Surv",res$rf$call)[2]
    is.surv
    if(is.surv) 
    {
        y <- paste0("N",res$rf$where)
        ##y <- as.integer(factor(y, levels=sort(unique(y))))
        names(y) <- colnames(res$X)
        table(y)
    }

    ny <- length(unique(y))    
    par(mfrow=c(2,4), mar=c(3.5,3,2,0.5),
        mgp=c(2,0.8,0), oma=c(0.5,1,1,1)*0)
    if(length(vars)>8) par(mfrow=c(3,4), mar=c(2.8,3,2,0.3),)
    i=1
    for(i in 1:min(12,length(vars))) {
        ##g <- rownames(res$R)[i]
        g <- vars[i]
        gx <- res$X[g,]

        boxplot( gx ~ y, col="grey85", ylim = range(gx),
                ylab="expression", cex.axis=0.001)
        axis(2, cex.axis=0.9)
        ##axis(1, at=1:ny, labels=levels(factor(y)), cex.axis=0.6)
        cex1 <- ifelse( ny >= 8, 0.7, 0.85)
        title(g, cex.main=ifelse(nchar(g)>20,0.85,1))
        nchar(y)
        too.big = (max(nchar(y)>6) && ny==2) || (max(nchar(y)>4) && ny>2)
        if(too.big) {
            dy <- min(gx) - 0.16*diff(range(gx))        
            text(1:ny, dy, levels(factor(y)), xpd=NA,
                 cex=cex1, srt=30, adj=1)
        } else {
            mtext(levels(factor(y)), side=1, line=0.7,
                  cex=cex1*0.9, las=1, at=1:ny)
        }

    }

}, res=100)


output$pdx_heatmap <- renderPlot({

    ngs <- inputData()
    if(is.null(ngs)) return(NULL)
    
    res <- calcVariableImportance()
    if(is.null(res)) return(NULL)

    cat("<predict:pdx_heatmap> called\n")
    
    gg <- NULL
    if(input$pdx_level=="geneset") {
        gg <- rownames(res$X)
        gg <- intersect(gg, rownames(ngs$gsetX))
        X <- ngs$gsetX[gg,]
        rownames(X) <- tolower(rownames(X))
    } else {
        gg <- rownames(res$X)
        gg <- intersect(gg, rownames(ngs$X))
        X <- ngs$X[gg,]
    }

    cat("<predict:pdx_heatmap> dim(X)=",dim(X),"\n")
    
    rownames(X) <- substring(rownames(X),1,40)    
    annot <- ngs$Y[colnames(X),]
    gx.splitmap( X, split=NULL, lab.len=50,
                col.annot=annot, annot.ht=2.5, 
                cexRow=0.85, mar=c(2,8))

})    


```

`r if(!DEV.VERSION) {"<!---------------------"}`

### Multi-level
    
```{r message=FALSE, warning=FALSE, fig.width=4}

fillCol(flex = c(NA,1),
        inputPanel(
            selectInput("mix_level1",NULL,choices=NULL),
            selectInput("mix_level2",NULL,choices=NULL),
            selectInput("mix_level3",NULL,choices=NULL),
            cellArgs=list(width='350px')
        ),                
        fillRow(flex = c(1.8,0.07,1),
                fillCol(flex = c(0.9,1),
                        plotOutput('mix_plotLoadings'),
                        fillRow(flex = c(1.2,1),
                                ##plotOutput('mix_plotDiablo'),
                                plotOutput('mix_hivePlot'),
                                ##plotOutput('mix_plotVariates')
                                plotOutput('mix_plotSNF')
                                ##plotOutput('mix_circosPlot')
                                )
                        ),
                br(),
                plotOutput('mix_cimDiablo')
                )
        )

observe({
    ngs <- inputData()
    if(is.null(ngs)) return(NULL)
    ct1 <- c("COMPARTMENTS:Cell_surface", "COMPARTMENTS:Membrane_part",
             "FAMILY:Endogenous ligands (HGNC)",
             "C2:REACTOME_CHEMOKIoNE_RECEPTORS_BIND_CHEMOKINES")
    ct2 <- c("COMPARTMENTS:Cytoplasm", "MSIGDB:PROTEIN_KINASES",
             "C5:GO_KINASE_ACTIVITY","FAMILY:Kinases (KEA)",
             "FAMILY:Micro RNA")
    ct3 <- c("COMPARTMENTS:Nuclear_part","CUSTOM:Transcription factors",
             "FAMILY:Nuclear receptors","MSIGDB:TRANSCRIPTION_FACTORS")
    gs.size <- function(gs) {length(intersect(gs,rownames(ngs$X)))}
    ct1 <- ct1[which(sapply(GSETS[ct1],gs.size)>=3)]
    ct2 <- ct2[which(sapply(GSETS[ct2],gs.size)>=3)]
    ct3 <- ct3[which(sapply(GSETS[ct3],gs.size)>=3)]
    updateSelectInput(session, "mix_level1", choices=ct1)
    updateSelectInput(session, "mix_level2", choices=ct2)
    updateSelectInput(session, "mix_level3", choices=ct3)
})

output$mix_testPlot <- renderPlot({
    require("grid")
    require("HiveR")
    require("igraph")
    test3 <- ranHiveData(nx = 3)
    ## plotHive(test3) # default plot
    print(qplot(1:100,sin((1:100)/4)))
    ##igraph::plot(sample_k_regular(10, 2))
})

mix_computeDiablo <- reactive({
    ngs <- inputData()
    if(is.null(ngs)) return(NULL)
    
    cat("<mix_computeDiablo> called\n")

    comparison=1
    comparison="ABC_vs_GCB"
    comparison="treatment"
    comparison="cell.type"
    comparison <- input$pdx_contrast
    if(is.null(comparison)) return(NULL)
    if(comparison=="") return(NULL)
    cat("<mix_computeDiablo> comparison=",comparison,"\n")

    vartype="contrast"
    vartype="phenotype"
    vartype <- input$pdx_vartype
    is.contrast <- (vartype == "contrast")
    is.contrast

    exp.matrix <- ngs$model.parameters$exp.matrix
    if(is.contrast && is.numeric(comparison[1])) {
        comparison <- colnames(exp.matrix)[comparison]
    }
    if(!is.contrast && is.numeric(comparison[1])) {
        comparison <- colnames(ngs$Y)[comparison[1]]
    }
    
    ##is.contrast <- (comparison %in% colnames(exp.matrix))
    is.contrast
    valid.comparison <- comparison %in% colnames(exp.matrix)
    if(is.contrast && valid.comparison) {
        Y <- as.character(sign(exp.matrix[,comparison]))
        Y[which(Y=='0')] <- NA
    } else if(comparison %in% colnames(ngs$samples)) {
        Y <- ngs$samples[,comparison]
        Y[which(Y %in% c(NA,"","NA"))] <- NA
    } else {
        return(NULL)
    }
    cat("<mix_computeDiablo> 1:table.Y=",table(Y),"\n")    
    
    ##if(!is.contrast) return(NULL) ## only contrast for now...    
    if(is.contrast && grepl("_vs_|_VS_",comparison)) {
        cmp1 <- sub(".*:","",comparison)  ## strip prefix
        vv <- strsplit(cmp1,split="_vs_|_VS_")[[1]]
        vv
        cat("<mix_computeDiablo> 1:vv=",vv,"\n")
        Y[which(Y=='-1')] <- vv[2]
        Y[which(Y=='1')] <- vv[1]
        Y <- relevel(factor(Y), ref=vv[2])
    }
    table(Y)
    cat("<mix_computeDiablo> 2:Y=",table(as.character(Y)),"\n")
    
    ct1 <- "COMPARTMENTS:Cell_surface"
    ct2 <- "MSIGDB:PROTEIN_KINASES"
    ct3 <- "CUSTOM:Transcription factors"
    ct1 <- input$mix_level1
    ct2 <- input$mix_level2
    ct3 <- input$mix_level3
    if(is.null(ct1) || is.null(ct2) || is.null(ct3)) return(NULL)
    
    require(mixOmics)
    cs <- GSETS[[ct1]]
    pk <- GSETS[[ct2]]
    tf <- GSETS[[ct3]]
    gg <- rownames(ngs$X)
    cs.X <- ngs$X[intersect(cs, gg),]
    pk.X <- ngs$X[intersect(pk, gg),]
    tf.X <- ngs$X[intersect(tf, gg),]
    
    data = list(cs.X, pk.X, tf.X)
    names(data) <- c("CS","PK","TF")
    names(data) <- sub(".*:","",c(ct1, ct2, ct3))
    names(data) <- substring(toupper(names(data)),1,30)
    length(data)

    posonly=FALSE
    if(PRO.VERSION) posonly <- input$pdx_posonly
    res <- pgx.makeTriSystemGraph(
        data, Y, nfeat=25, numedge=100, posonly=posonly)    
    return(res)
})


output$mix_plotLoadings <- renderPlot({    

    cat("<predict::mix_plotLoadings> called\n")    
    ngs <- inputData()
    if(is.null(ngs)) return(NULL)
    
    res <- mix_computeDiablo()
    ##plotLoadings(res, comp = 2, contrib = 'max', method = 'median',
    ## size.name = 1, size.title = rel(0.7))	   
    if(is.null(res)) return(NULL)

    showloops=FALSE
    if(PRO.VERSION) showloops <- input$pdx_showloops
    mixPlotLoadings(res, showloops=showloops) 
    
}, res=80)

output$mix_plotDiablo <- renderPlot({
    res <- mix_computeDiablo()
    if(is.null(res)) return(NULL)
    
    ny <- length(unique(res$Y))
    klrpal <- c("blue2","orange2")
    klrpal <- brewer.pal(n=3, name = "RdBu")[c(3,1)]
    if(ny>2) klrpal <- rep(brewer.pal(n=8, "Set2"),10)[1:ny]
    klrpal
    klr1 <- klrpal[factor(res$Y)]
    klr1[is.na(klr1)] <- "grey85"
    k=1
    if(0) {
        plotDiablo(res, ncomp = k)
    } else {             
        ## plot samples
        par(oma=c(1,1,1,1)*0, mar=c(0,0,0,0))
        vx1 <- sapply(res$variates,function(x) x[,k])
        colnames(vx1) <- substring(colnames(vx1),1,4)
        pairs(vx1,cex=1, cex.labels=1.1, pch=19, col=klr1)
    }    
}, res=80)

output$mix_plotVariates <- renderPlot({
    res <- mix_computeDiablo()
    if(is.null(res)) return(NULL)
     
    ny <- length(unique(res$Y))
    klrpal <- c("blue2","orange2")
    klrpal <- brewer.pal(n=3, name = "RdBu")[c(3,1)]
    if(ny>2) klrpal <- rep(brewer.pal(n=8, "Set2"),10)[1:ny]
    klrpal
    klr1 <- klrpal[factor(res$Y)]
    klr1[is.na(klr1)] <- "grey85"
    
    ## plot samples
    par(mfrow=c(2,2), oma=c(1,1,1,1)*0, mar=c(3,3.5,2.5,0))
    par(mgp=c(1.8,0.8,0))
    for(k in 1:3) {
        vx1 <- res$variates[[k]][,1:2]
        plot(vx1, cex=1.5, pch=19, col=klr1,
             xlab="component.1", ylab="component.2")
        title(names(res$variates)[k],cex.main=1, line=0.5)
    }

    ## combining all levels
    V <- do.call(rbind, res$loadings[1:3])
    X <- do.call(cbind, res$X)[,rownames(V)]
    R <- X %*% V
    plot(R[,1:2], cex=1.5, pch=19, col=klr1,
         xlab="component.1", ylab="component.2")
    title("COMBINED",cex.main=1, line=0.5)
    
})

output$mix_plotSNF <- renderPlot({
    res <- mix_computeDiablo()
    if(is.null(res)) return(NULL)
    
    cat("<predict::mix_plotSNF> called\n")

    ##if(!require(SNFtool)) install.packages("SNFtool")
    require(SNFtool)
    M.list <- list()
    i=1
    for(i in 1:3) {
        ##dist1 <- as.matrix(dist(res$X[[i]]))
        dist1 <- as.matrix(as.dist(1 - cor(t(res$X[[i]]))))
        k1 = floor(min(20,0.5*ncol(dist1)))
        M1 <- affinityMatrix(dist1, K=k1, sigma=0.5)
        M.list[[i]] <- M1
    }
    names(M.list) <- names(res$X)[1:3]
    
    prepMatrix <- function(M) {
        ## matrix preprocessing as in displayClustersWithHeatmap()
        normalize <- function(X) X/rowSums(X)
        diag(M) <- median(as.vector(M))
        M <- normalize(M)
        M <- M + t(M)
        return(M)
    }
    Wall <- lapply(M.list, prepMatrix)

    if(0) {
        ##dist1 <- as.matrix(dist(Data1))
        W1 <- affinityMatrix(dist1, K = 20, sigma = 0.5)
        ind <- spectralClustering(W1, K=3)
        displayClustersWithHeatmap(W1, ind)
        
        W1 <- Wall[[1]]
        ind <- order(spectralClustering(W1, K=3))
        heatmap(W1[ind,ind], scale="none", Rowv=NA, Colv=NA)
        heatmap(W1, scale="none")
       
    }

    k1 = floor(min(20,0.5*ncol(Wall[[1]])))
    Wcomb = SNF(Wall, K=k1, t=20)
    Wcomb = prepMatrix(Wcomb)
    estK = estimateNumberOfClustersGivenGraph(Wcomb, NUMC=2:8)
    estK
    ##K=5
    K=-1
    ##K=median(unlist(estK))
    K    

    ind <- hclust(as.dist(1 - cor(Wcomb)))$order
    if(K>0) ind <- order(spectralClustering(Wcomb, K=K))
    
    par(mfrow=c(2,2), mar=c(0.5,1,2,0.5))
    i=1
    for(i in 1:3) {
        ##ind <- hclust(as.dist(1 - cor(Wall[[i]])))$order
        ##if(K>0) ind <- order(spectralClustering(Wall[[i]], K=K))
        ##heatmap(Wall[[i]][ind,ind], scale="none", Rowv=NA, Colv=NA)
        image(Wall[[i]][ind,ind], xaxt='n', yaxt='n')
        title(names(Wall)[i],cex.main=1.1,line=0.5)
    }

    ##displayClustersWithHeatmap(W, spectralClustering(W, K=3))
    ##heatmap(prepMatrix(W), scale="none")
    image(Wcomb[ind,ind], xaxt='n', yaxt='n')
    title("SNF",cex.main=1.1,line=0.5)
    
})

output$mix_circosPlot <- renderPlot({
    res <- mix_computeDiablo()
    if(is.null(res)) return(NULL)
    
    circosPlot(res, cutoff = 0.95, line = TRUE, 
               color.blocks= c('darkorchid', 'brown1', 'lightgreen'),
               color.cor = c("grey30","red3"), size.labels = 1.5)

}, res=60)
    

output$mix_hivePlot <- renderPlot({

    ngs <- inputData()
    if(is.null(ngs)) return(NULL)

    ct="group"
    ct <- input$pdx_contrast
    if(is.null(ct)) return(NULL)

    ##-------------------------------------------------------------
    ## Get the DIABLO results
    ##-------------------------------------------------------------
    res <- mix_computeDiablo()
    if(is.null(res)) return(NULL)

    showloops = FALSE
    if(PRO.VERSION) showloops = input$pdx_showloops
    mixHivePlot(res=res, ngs=ngs, ct=ct, showloops=showloops)

}, res=72)


output$mix_cimDiablo <- renderPlot({
    ngs <- inputData()
    if(is.null(ngs)) return(NULL)

    res <- mix_computeDiablo()
    if(is.null(res)) return(NULL)

    NFEAT=20
    top.features <- lapply(res$loadings[1:3], function(x)
        head(names(sort(-abs(rowMeans(x**2)))),NFEAT)
        )
    X <- do.call(cbind, res$X)
    X <- X[,unlist(top.features)]
    dim(X)
    X <- X[,head(order(-apply(X,2,sd)),60)]
    idx <- as.integer(sub(":.*","",colnames(X)))
    ptype <- names(res$variates)[idx]
    col.annot <- ngs$Y[rownames(X),]
    colnames(X) <- sub(".*[:]","",colnames(X))
    
    gx.splitmap( t(X), split=ptype, splitx=NULL,
                softmax=1, scale="row", 
                col.annot=col.annot, cexRow=0.9, 
                dist.method="pearson",                
                col.dist.method="pearson")
})

```

`r if(!DEV.VERSION) {"--------------------->"}`
