System
================================================================================

Inputs {.sidebar data-width=250}
--------------------------------------------------------------------------------

<br>
**Integrative Analysis**

<br><br>

```{r}

##load("../pgx/geiger2018-arginine-4k.pgx")
##load("../pgx/GSE10846-dlbcl-mRNA-8k.pgx")
##load("../pgx/GSE72056_melanoma-scRNA-vsCLUST-4k.pgx")

require(shinyWidgets)
selectInput("gr_level","Level:", choices=c("gene","geneset"))
selectInput("gr_contrast","Contrast:", choices=NULL)
##sliderTextInput("gr_contrast","Contrast:", choices="", animate=TRUE)
selectInput("gr_features","Features:", choices=NULL)
##selectInput("gr_collection","Collection:", choices=NULL)

checkboxInput('gr_reduce','reduce',TRUE)
checkboxInput('gr_mst','MST',FALSE)
IGRAPH.LAYOUTS=c("<t-SNE>","layout_with_fr","layout_as_tree",
                 "layout_randomly","layout_with_mds","layout_with_graphopt")
selectInput('gr_layout','Layout:',choices=IGRAPH.LAYOUTS)

observe({
    ngs <- inputData()
    if(is.null(ngs)) return(NULL)
    ct <- colnames(ngs$model.parameters$contr.matrix)
    ##ct <- c(ct,"<sd>")
    updateSelectInput(session, "gr_contrast", choices=ct )
})

##observeEvent( input$gr_level, {
observe({
    ngs <- inputData()
    if(is.null(ngs)) return(NULL)
    gr <- ngs$omicsnet
    if(is.null(ngs$omicsnet)) return(NULL)
    fam=sel=NULL
    if(input$gr_level=="gene") {
        ##genes <- toupper(sub(".*\\}","",V(gr)$name[which(V(gr)$level=="gene")]))
        ##fam = names(ngs$families)
        fam <- pgx.getExtendedFamilies(ngs,10)
        sel = fam[grep("transcription factors \\(irb",fam,ignore.case=TRUE)[1]]
    }
    if(input$gr_level=="geneset") {
        fam = names(COLLECTIONS)
        sel = fam[grep("hallmark",fam,ignore.case=TRUE)[1]]
    }
    if(is.null(sel) || length(sel)==0) sel <- fam[1]
    if(!(sel %in% fam)) sel <- fam[1]
    updateSelectInput(session, "gr_features", choices=fam, selected=sel )
    ##updateSelectInput(session, "gr_collection", choices=names(COLLECTIONS),
    ##                  selected="Hallmark collection")
})

```

Col {.tabset data-width=600}
----------------------------------------------------------------------------------------

### Network (genes)
    
```{r message=FALSE, warning=FALSE, fig.width=4}
require(visNetwork)
fillCol(height = "100%", flex = c(NA, 1), 
        inputPanel(
            checkboxInput('gr_labels','show labels',TRUE),
            checkboxInput('gr_colorcluster','color clusters',FALSE),
            cellArgs=list(width='120px')
        ),
        visNetworkOutput("plotGeneNetwork", height = "100%")
        )

observe({
    ngs <- inputData()
    genes = rownames(ngs$X)
    updateSelectInput(session, "gr_gene", choices=genes)
    gsets = rownames(ngs$gsetX)
    updateSelectInput(session, "gr_geneset", choices=gsets)
})

if(0) {
    observe({
        ngs <- inputData()
        genes <- sort(ngs$families[[input$gr_family]])
        updateSelectInput(session, "gr_gene", choices=genes)
    })
}

observeEvent(input$gr_gene, {
    selected <- as.character(input$gr_gene)
    cat("selected gene=",selected,"\n")
    gr <- geneNetwork()
    vmatch = which(sapply(V(gr)$label, function(v) grepl(selected,v)))[1]
    cat("vmatch=",vmatch,"\n")
    ##visNetworkProxy("plotGeneNetwork") %>% visSelectNodes(id=vmatch)
})

observeEvent(input$gr_geneset, {
    selected <- input$gr_geneset
    cat("selected geneset=",selected,"\n")
    gr <- gsetNetwork()
    vmatch = which(sapply(V(gr)$label, function(v) grepl(selected,v)))[1]
    cat("vmatch=",vmatch,"\n")    
    ##visNetworkProxy("plotGenesetNetwork") %>% visSelectNodes(id=vmatch)
})


output$plotGeneNetwork <- renderVisNetwork({
    require(igraph)
    require(visNetwork)
    ngs <- inputData()
    if(is.null(ngs)) return(NULL)
    gr <- geneNetwork()
    if(is.null(gr)) return(NULL)
        
    ## ------------------ plot using visNetwork (zoomable) -----------------
    visdata <- toVisNetworkData(gr, idToLabel=FALSE)
    pos <- gr$layout[V(gr)$name,]
    pos[,2] <- -pos[,2]
    graph <- visNetwork(nodes = visdata$nodes, edges = visdata$edges,
                        height="1200px", width="1600px") %>%
        visNodes(font=list(size=4))  %>%
        visEdges(hidden=FALSE, width=8, color=list(opacity=0.1))  %>%
        visOptions(highlightNearest = list(enabled = T, degree = 1, hover = T)) %>%
        ##visHierarchicalLayout(direction = "LR") %>%
        visInteraction(hideEdgesOnDrag = TRUE) %>%
        visIgraphLayout(layout="layout.norm", layoutMatrix=pos)
    graph
})

geneNetwork <- reactive({
    require(igraph)
    require(visNetwork)
    require(gplots) ## for col2hex
    ## return(NULL)
  
    ngs <- inputData()
    if(is.null(ngs)) return(NULL)

    has.graph <- all(c("omicsnet","omicsnet.reduced") %in% names(ngs))
    has.graph
    if(!has.graph) return(NULL)
    
    ##gr <- ngs$genes_tsne_graph$graph
    gr <- ngs$omicsnet.reduced
    gr <- ngs$omicsnet
    gr <- ngs$omicsnet.reduced
    
    gr_level = "gene"
    gr_level = input$gr_level
    gr <- induced_subgraph(gr, which(V(gr)$level==gr_level))
    gr
    if(is.null(gr)) return(NULL)
        
    ## ------------- get fold-change for node color and size ------------------
    fc0 <- gr$foldchange[V(gr)$name,,drop=FALSE]
    comp=1
    comp = input$gr_contrast
    if(is.null(comp)) return(NULL)
    
    if(comp=="<sd>") {
        fc <- rowMeans(fc0**2,na.rm=TRUE)**0.5
    } else {
        fc <- fc0[,comp]
    }
    fc[is.na(fc)] <- 0
    fc <- (fc / (1e-8+max(abs(fc),na.rm=TRUE)))
    fc.cex <- 0.1 + abs(fc)**0.66
    
    ## defaults graph parameters
    vlabel <- V(gr)$name
    if("label" %in% vertex_attr_names(gr)) vlabel <- V(gr)$label
    vlabel0 = vlabel
    vklr = c("blue3","grey70","red3")[2+sign(fc)]
    do.colorcluster = input$gr_colorcluster
    if(is.null(do.colorcluster)) return(NULL)
    if(do.colorcluster) {
        vklr <- rep(rainbow(16),99)[V(gr)$cluster]
    }
    lab.cex = 1

    ##ee <- get.edgelist(gr)
    ee <- get.edges(gr, E(gr))    
    dim(ee)
    head(ee)
    ##ew = rep(3,nrow(ee))
    ew = 1 + 5 * sqrt(fc.cex[ee[,1]]*fc.cex[ee[,2]])
    ew = 1 + 5 * abs(E(gr)$weight)
    vsel <- rep(0,length(fc))
    esel <- rep(0,nrow(ee))    

    ## ------------------ highlight selection with labels
    ft=10
    ft="<all>"
    ft="CD molecules (HGNC)"
    ft <- input$gr_features
    if(is.null(ft)) return(NULL)

    if(!(ft %in% c("<all>","*",""))) {
        ##vv  <- ngs$genes_tsne_graph$members
        vv <- V(gr)$name
        if(!is.null(gr$members)) {
            vv <- gr$members[V(gr)$name]
        }
        vv <- sapply(vv, function(s) sub(".*\\}","",s))
        if(input$gr_level=="gene") {
            ##ff <- ngs$families[[ft]]
            ff <- GSETS[[ft]]
            ff <- toupper(ff)  ## handle mouse genes
            vv <- sapply(vv,toupper)  ## handle mouse genes
        } else {
            ff <- COLLECTIONS[[ft]]
        }
        vlabel <- sapply( vv, function(x) intersect(x,ff))
        vlabel <- sapply( vlabel, paste, collapse="\n")
        head(vlabel,10)
        table(vlabel!="")
        
        sel <- which(vlabel!="")
        length(sel)
        if(length(sel)>0) {
            vsel[sel] <- 1
            lab.cex[sel] <- 1 + 18*(fc.cex[sel]/max(fc.cex[sel],na.rm=TRUE))
        }
        
        jj <- which( vsel[ee[,1]]==1 | vsel[ee[,2]]==1 )
        esel[jj] <- 1
        ew[jj] <- 2.4 * ew[jj] 

        nnb <- unique(unlist(sapply(sel, neighbors, graph=gr)))
        is.nb <- (1:length(sel) %in% nnb)
        vlabel[which(vsel==0)] <- NA
        ##vklr[which(vsel==0 & !is.nb)] <- "grey70"
        vklr[which(vsel==0)] <- "grey60"
        lab.cex[which(vsel==0)] <- 1
    }

    vklr = substring(col2hex(vklr),1,7)
    names(vklr) <- V(gr)$name
    V(gr)$label <- vlabel ## filtered labels
    V(gr)$title <- gsub("\n","<br>",vlabel0)  ## tooltip has complete names
    V(gr)$label.cex <- 0.12 * lab.cex
    V(gr)$size <- 40 * fc.cex
    V(gr)$color <- paste0(vklr,ifelse(vsel==1,"99","55"))
    if(input$gr_labels==FALSE) V(gr)$label <- NA
    ##E(gr)$color <- paste0(vklr[ee[,1]],ifelse(esel==1,"33","22"))
    E(gr)$color <- paste0(vklr[ee[,1]],ifelse(esel==1,"99","55"))
    E(gr)$width <- 1 * (2 + 5 * (ew / max(ew)))

    do.mst = FALSE
    do.mst = input$gr_mst
    if(do.mst==TRUE) {
        gr <- mst(gr)
    }

    ##pos <- as.matrix(gr$layout)    
    if(input$gr_layout!="<t-SNE>") {
        input.layout = "layout_with_fr"
        input.layout = as.character(input$gr_layout)
        layout.fun <- match.fun(input.layout)
        tmp.gr = gr
        E(tmp.gr)$weight = abs(E(tmp.gr)$weight)**0.2
        ##E(tmp.gr)$weight = 1
        gr$layout <- layout.fun(tmp.gr)
        remove(tmp.gr)
        ##gr$layout <- layout.fun(gr, weights=abs(E(gr)$weight))
        rownames(gr$layout) <- V(gr)$name
    }

    cat("updating geneNetwork:: done\n")
    
    return(gr)
})    

```


### OmicsNet 3D
    
```{r message=FALSE, warning=FALSE, fig.width=4}
require(threejs)
fillCol(height = "100%", flex = c(NA, 1), 
        inputPanel(
            ##selectInput("gr_family", "", choices=NULL, width='100%'),
            ##selectInput("n3d_level", "Level:", choices=c("multilayer","gene","geneset"), width='100%'),
            sliderInput("n3d_threshold","threshold:", min=0, max=1, step=0.05, value=0.5),
            checkboxGroupInput('n3d_options1',"",choices=c("beside","extrude","spectral filter"),
                               selected=c("extrude","spectral filter"), inline=TRUE),
            ##checkboxGroupInput('n3d_options2',"",c("prune.edges")),
            radioButtons('n3d_scoretype',"",c("pathscore","FC"),inline=TRUE),
            radioButtons('n3d_graphtype',"",c("full","reduced"),inline=TRUE),
            checkboxInput('n3d_shortestpath',"SP"),
            cellArgs=list(width='120px')
        ),
        scatterplotThreeOutput("plotOmicsNet3D", height = "100%")
        )

output$plotOmicsNet3D <- renderScatterplotThree({
    require(igraph)
    require(visNetwork)
    ngs <- inputData()
       
    ##-----------------------------------------------------------
    ## validate
    ##-----------------------------------------------------------
    if(!("omicsnet" %in% names(ngs))) return(NULL)
    if(is.null(input$gr_features)) return(NULL)

    has.fc <- ("foldchange" %in% names(ngs$omicsnet))
    has.ps <- ("pathscores" %in% names(ngs))
    if(!has.fc && !has.ps) {
        validate(need(has.fc,"no omicsnet has no foldchange!"))
        validate(need(has.ps,"no omicsnet has no pathscores!"))        
        return(NULL)
    }

    ##-----------------------------------------------------------
    ## get graph object
    ##-----------------------------------------------------------
    is.reduced=FALSE
    is.reduced=TRUE
    is.reduced <- (input$n3d_graphtype=="reduced")
    g <- NULL
    if(is.reduced) {
        g <- ngs$omicsnet.reduced
    } else {
        g <- ngs$omicsnet
    }
    names(ngs$gx.meta$meta)

    if(!is.reduced && input$gr_level=="gene" && input$gr_features != "<all>") {
        ##gset <- ngs$families[[11]]
        ##gset <- ngs$families[[input$gr_features]]
        gset <- GSETS[[11]]
        gset <- GSETS[[input$gr_features]]
        g <- pgx.createVipGeneLayer(g, genes=gset, reconnect=40) 
        table(g$layout[,3])
    }

    ##-----------------------------------------------------------
    ## get foldchange/pathscore values from graph object
    ##-----------------------------------------------------------
    contrast=1
    contrast=colnames(g$foldchange)[1]
    contrast = input$gr_contrast
    fx <- NULL
    if(input$n3d_scoretype=="pathscore") {
        vv <- rownames(g$foldchange)
        if(!is.reduced) fx <- ngs$pathscores[vv,contrast] * sign(g$foldchange[vv,contrast])
        if(is.reduced)  fx <- ngs$pathscores.reduced[vv,contrast] * sign(g$foldchange[vv,contrast])
    } else {
        fx <- g$foldchange[,contrast]
    }
    
    ##-----------------------------------------------------------
    ## match and assign scores to vertices
    ##-----------------------------------------------------------
    vv <- intersect(names(fx), V(g)$name)
    fx <- fx[vv]    
    g1 <- induced_subgraph(g, vv)
    table(V(g1)$name %in% names(fx))
    g1$layout <- g$layout[V(g1)$name,]
    dim(g1$layout)    
    fx <- fx[match(V(g1)$name,names(fx))]
    table(is.na(fx))
    fx[which(is.na(fx))] <- 0

    ##-----------------------------------------------------------
    ## smoothen with spectral filter
    ##-----------------------------------------------------------
    if("spectral filter" %in% input$n3d_options1) {
        M <- g1[,]
        sum(is.na(M))
        ##M[is.na(M)] <- 0
        fx1 <- fx
        for(i in 1:5) {
            fx1 <- (M %*% fx1)[,1]
            fx1 <- fx + 0.5*fx1
            fx1 <- fx1 / sum(fx1**2) * sum(fx**2)
        }
        fx <- fx * abs(fx1)
    }

    ##-----------------------------------------------------------
    ## normalize scores per level
    ##-----------------------------------------------------------
    glevels <- unique(V(g1)$level)
    for(s in glevels) {
        j1 <- which(V(g1)$level==s)
        if(length(j1)>0) {
            ##fx[j1] <- scale(fx[j1],center=FALSE)
            fx[j1] <- fx[j1] / max(abs(fx[j1]))
        }
    }

    ##-----------------------------------------------------------
    ## determine top scoring terms
    ##-----------------------------------------------------------
    cat("plotOmicsNet3D:: 3\n")    
    V(g1)$score <- fx
    n=5    
    top.vv <- c()
    if(input$n3d_shortestpath) {
        sp <- pgx.computeShortestPath(
            g1, contrast, niter=10, r=0.03, output="vpath")
        head(sp$vfreq)
        top.vv <- head(names(sp$vfreq),2*n)
    } else {
        s="gene"
        for(s in glevels) {
            j1 <- which(V(g1)$level==s)
            v1 <- c(head(names(sort(-fx[j1])),n),head(names(sort(fx[j1])),n))  ## symmetric??
            top.vv <- c(top.vv, v1)            
        }
    }
    top.vv
    
    ##-----------------------------------------------------------
    ## remove and prune intralayer edges
    ##-----------------------------------------------------------
    if(1) {
        top.idx <- match(top.vv, V(g1)$name)
        ee <- get.edges(g1, E(g1))
        ##top.ee <- ( ee[,1] %in% top.idx | ee[,2] %in% top.idx)
        lv1 <- V(g1)$level[ee[,1]]
        lv2 <- V(g1)$level[ee[,2]]
        ee.type <- c("intralayer","interlayer")[1 + 1*(lv1!=lv2)]
        table(ee.type)
        ##ee <- ee[ee.type=="interlayer",]
        thr=0.3
        thr <- input$n3d_threshold
        vv <- unique(as.vector(ee))
        fx.min = thr * max(abs(fx[vv]))
        top.ee <- ( (ee[,1] %in% top.idx & abs(fx[ee[,2]]) > fx.min ) |
                    (ee[,2] %in% top.idx & abs(fx[ee[,1]]) > fx.min ) )
        link.dist <- abs(g1$layout[ee[,1],3] - g1$layout[ee[,2],3])    
        summary(link.dist)
        ii <- which(ee.type=="interlayer")
        ##ee.delete <- (ee.type=="interlayer" & (!top.ee | link.dist>1.1))
        ee.delete <- (ee.type=="interlayer" & !top.ee)
        table(ee.delete)
        g1 <- delete_edges(g1, which(ee.delete))
    } else {
        
        sp <- pgx.computeShortestPath(
            g1, contrast, niter=10, r=0.01, output="both")
        

        
    }
    cat("plotOmicsNet3D:: 4\n")
        
    ##-----------------------------------------------------------
    ## set layout
    ##-----------------------------------------------------------
    if(input$gr_layout!="<t-SNE>") {
        input.layout = "layout_with_fr"
        input.layout = as.character(input$gr_layout)
        layout.fun <- match.fun(input.layout)
        v1 <- which(V(g1)$level=="gene")
        v2 <- which(V(g1)$level=="geneset")
        if(length(v1)>0) g1$layout[v1,1:2] <- layout.fun(induced_subgraph(g1,v1))
        if(length(v2)>0) g1$layout[v2,1:2] <- layout.fun(induced_subgraph(g1,v2))
    }    

    uscale <- function(x) 2*(x-min(x))/(1e-8+max(x)-min(x)) - 1*(max(x)!=min(x))   
    g1$layout <- apply(g1$layout,2,uscale)

    ## ---------------- layout beside each other 
    if("beside" %in% input$n3d_options1) {
        zlevels <- sort(unique(g1$layout[,3]))
        table(g1$layout[,3])
        i=1
        for(i in 1:length(zlevels)) {
            v1 <- which(g1$layout[,3]==zlevels[i])
            g1$layout[v1,1:2] <- g1$layout[v1,1:2] + 1.66*i
            g1$layout[v1,3] <- 0
        }
    }

    ## --------------- give z-axis value according to FC
    if("extrude" %in% input$n3d_options1) {
        fx1 <- fx / max(abs(fx))
        fx1[is.na(fx1)] = 0
        vv <- names(fx1)
        g1$layout[vv,3] <- g1$layout[vv,3] + 0.33*sign(fx1)*abs(fx1)**1
    }
    ##g1$layout <- apply(g1$layout,2,uscale)

    ## ----------------------normalize space, add axis anchors
    if(1) {
        ## add corners
        axis.points <- apply(g1$layout,2,range)
        rownames(axis.points) <- paste0("axis.points",1:2)
        if(diff(axis.points[,3])==0) axis.points[,3] = c(-1,1)
        g1 <- add_vertices(g1,2, name=rownames(axis.points) )
        g1$layout <- rbind(g1$layout, axis.points)
    }
    ##uscale <- function(x) 2*(x-min(x))/(1e-8+max(x)-min(x)) - 1*(max(x)!=min(x))   
    ##g1$layout <- apply(g1$layout,2,uscale)
    
    ##-----------------------------------------------------------
    ## labels and colors
    ##-----------------------------------------------------------
    fx1 <- V(g1)$score
    fx1[is.na(fx1)] = 0
    ##nfx1 <- fx1 / max(abs(fx1))
    nfx1 <- tanh( fx1 / sd(fx1))
    klrpal = colorRampPalette(c("blue3", "aliceblue", "grey70", "lavenderblush", "red3"))(17)
    klr <- klrpal[9 + round(8*nfx1)]
    ##klr <- c("blue","red")[1 + 1*(sign(fx1)>0)]

    vtx <- rep("@",length(V(g1)))
    jj <- which(V(g1)$name %in% top.vv)
    vtx[jj] <- V(g1)$name[jj]
    vtx[grep("axis",V(g1)$name)] <- "x"
    vtx.label <- V(g1)$name
    if(is.reduced) {
        vtx.label <- g1$members[V(g1)$name]
        j0 <- which(V(g1)$level=="gene")
        j1 <- which(V(g1)$level=="geneset")
        vtx.label[j0] <- sapply(vtx.label[j0], function(v) paste(v,collapse=" "))
        vtx.label[j1] <- sapply(vtx.label[j1], function(v) paste(v,collapse="<br>"))
        vtx.label <- as.character(vtx.label)
    }
    
    cat("plotOmicsNet3D:: calling graphjs\n")
    
    ##-----------------------------------------------------------
    ## Call graphJS
    ##-----------------------------------------------------------
    require(threejs)
    vcex = 1    
    graph <- graphjs(g1, vertex.size=0.12*vcex, vertex.color=klr,
                     vertex.label=vtx.label, vertex.shape=vtx, 
                     edge.alpha=0.20, edge.width=2,
                     use.orbitcontrols=TRUE, main=contrast)
    graph

})
```


### Projection plot
    
```{r message=FALSE, warning=FALSE, fig.width=4}
renderPlot({
    ngs = inputData()
    if(is.null(ngs)) return(NULL)
    scores = featureScores()    
    if(is.null(scores)) return(NULL)
    sel = input$feature_score_table_rows_selected
    if(is.null(sel)) return(NULL)

    gene = geneset = NULL
    if(!is.null(sel) && input$gr_level=="gene") {
        gene = rownames(scores)[sel]
    }
    if(!is.null(sel) && input$gr_level=="geneset") {
        geneset = rownames(scores)[sel]
    }

    gr = ngs$omicsnet
    if(is.null(gr)) return(NULL)

    comp <- input$gr_contrast
    fx = gr$foldchange[,comp]

    par(mfrow=c(1,1), mar=c(10,0,10,0))
    pgx.plotDualProjection(gr, gene=gene, geneset=geneset,
                           cex=1, fx=fx, main=NULL )
    
})
```


### PCSF

```{r eval=TRUE}

    
####################################################################
############### DISABLED ###########################################
####################################################################


##renderPlot({
require(visNetwork)
renderVisNetwork({
    ##devtools::install_github("IOR-Bioinformatics/PCSF", repos=BiocInstaller::biocinstallRepos(),
    ##                         dependencies=TRUE, type="source", force=TRUE)
    library(PCSF)
    require(visNetwork)    
    ngs <- inputData()
    if(is.null(ngs)) return(NULL)
    data("STRING")
    ##data("Tgfb_phospho")
    ppi <- construct_interactome(STRING)

    cmp=1
    cmp = input$gr_contrast
    fx = ngs$gx.meta$meta[[cmp]]$meta.fx
    names(fx) = sub(".*:","",rownames(ngs$gx.meta$meta[[cmp]]))
    terminals <- head(sort(abs(fx),decreasing=TRUE),50)
           
    ##subnet <- PCSF(ppi, terminals, w = 2, b = 1, mu = 0.0005)
    subnet <- PCSF_rand(ppi, terminals, n=5, r=0.1, w=2, b=1, mu=0.0005)
    plot(subnet)
    
    ##res <- enrichment_analysis(subnet)
    ##plot(res$subnet)
})    
```

### neighborhood

```{r message=FALSE, warning=FALSE, fig.width=4}
fillCol(height = "100%", flex = c(NA, 1), 
        inputPanel(
            ##selectInput("gr_nbgene", "", choices=NULL, width='100%'),
            sliderInput("gr_nbthreshold","Threshold:", min=0, max=1, value=0.01),
            ##selectInput("gr_nborder", "", choices=c(1,2,3), width='30%'),
            checkboxGroupInput("gr_nboptions", "options:", c("MST","pcor"), inline=TRUE),
            ##checkboxGroupInput('n3d_options2',"",c("prune.edges")),
            ##radioButtons('n3d_dim',"",c("2D","3D"),inline=TRUE),
            cellArgs=list(width='120px')
        ),
        visNetworkOutput("gr_nbgraph", height = "100%")
        )

output$gr_nbgraph <- renderVisNetwork({
    require(igraph)
    require(visNetwork)
    ngs <- inputData()
    if(is.null(ngs)) return(NULL)

    gr0 <- ngs$omicsnet
    if(is.null(gr0)) return(NULL)

    gene = "TBX21"
    gene = "AKNA"
    ##gene = input$gr_nbgene
    scores = featureScores()    
    sel = input$feature_score_table_rows_selected
    if(is.null(sel)) return(NULL)
    gene <- rownames(scores)[sel]
    gene = paste0("{gene}",toupper(gene))
    gene %in% V(gr0)$name

    ## ------------- make neigbourhood graph
    ##nbb <- c( V(gr0)[gene], neighbors(gr0,gene) )
    ##gr <- induced_subgraph(gr0, nbb )
    order=1
    ##order <- input$gr_nborder
    gr <- make_ego_graph(gr0, order=order, gene)[[1]]
    gr
    max.wt <- round(max(E(gr)$weight), digits=2)
    updateSliderInput(session, "gr_nbthreshold", max=max.wt)
        
    ft <- input$gr_features
    if(FALSE &&  !is.null(ft) && !(ft %in% c("<all>","*",""))) {
        if(input$gr_level=="gene") {
            ##sel <- toupper(ngs$families[[ft]])
            sel <- toupper(GSETS[[ft]])
        } else {
            sel <- COLLECTIONS[[ft]]
        }
        vname = sub(".*\\}","",V(gr)$name)
        gr <- induced_subgraph(gr, which(vname %in% sel))
    }

    cat("gr_nbgraph:: sum.isna.E.weight=", sum(is.na(E(gr)$weight)),"")
    
    ## --------------- invert correlation matrix if requested
    if("pcor" %in% input$gr_nboptions) {
        ##install.packages("qgraph")
        ##install.packages("QUIC")
        ##install.packages("glasso")
        ##require(qgraph)
        ##require(corpcor)
        require(QUIC)
        ##require(glasso)
        corMat <- as.matrix(gr[,])
        dim(corMat)
        ##pcorMat <- cor2pcor(corMat)
        ##pcorMat <- glasso(corMat, rho=0.5)
        cat("gr_nbgraph:: sum.isna.corMat=", sum(is.na(corMat)),"\n")
        pcorMat <- QUIC(corMat, rho=0.5)$X

        cat("gr_nbgraph:: sum.isna.pcorMat=", sum(is.na(pcorMat)),"\n")
        cat("gr_nbgraph:: max.pcorMat=", max(pcorMat),"\n")
        cat("gr_nbgraph:: min.pcorMat=", min(pcorMat),"\n")
        ee <- get.edges(gr, E(gr))
        E(gr)$weight <- pcorMat[ee]
    }
   
    ## ------------ apply threshold on edges
    thr=0.1
    thr <- as.numeric(input$gr_nbthreshold)
    if(is.null(thr)) return(NULL)
    max.wt <- max(abs(E(gr)$weight))
    if(thr > max.wt) thr <- 0.99*max.wt
    gr <- subgraph.edges(gr, which(abs(E(gr)$weight) >= thr))

    if(("MST" %in% input$gr_nboptions)) {
        gr <- mst(gr)
    }

    ## get original expression matrices for variance (node size)
    x1 = ngs$X
    x2 = ngs$gsetX
    rownames(x1) = paste0("{gene}",toupper(rownames(x1)))
    rownames(x2) = paste0("{geneset}",rownames(x2))
    xx = rbind(x1,x2)
    table(V(gr)$name %in% rownames(xx))
    xx = xx[V(gr)$name,]
    varx = apply(xx,1,var)
    
    ## ------------ set node/edges 
    contr = 1
    contr <- input$gr_contrast
    fc0 <- gr0$foldchange[V(gr)$name,]
    ##fc.var <- rowMeans(fc0**2)
    ##fc.var <- fc.var / max(abs(fc.var))
    fc  <- gr0$foldchange[V(gr)$name,contr] 
    fc <- fc / max(abs(fc))
    V(gr)$size <- 2 + 40*(varx/max(varx))**1
    vv.palette <- paste0(col2hex(c("blue3","grey60","red3")),"DD")
    vv.palette = colorRampPalette(c("blue3", "grey80", "red3"))(16)
    V(gr)$color <- vv.palette[8 + 7*fc]
    V(gr)$label <- sub(".*\\}","",V(gr)$name)
    
    require(gplots)
    gr <- induced_subgraph(gr, V(gr)$level=="gene")
    gr
    summary(E(gr)$weight)
    ##ee.col <- paste0(col2hex(c("blue3","grey60","red3")),"22")
    ##E(gr)$color <- ee.col[2+sign(E(gr)$weight)]
    ee.palette = colorRampPalette(c("darkorchid4", "grey90", "black"))(16)
    ee.palette = colorRampPalette(c("darkgreen", "grey90", "black"))(16)
    ee.palette = colorRampPalette(c("blue4", "grey90", "black"))(16)
    max.wt0 = max(abs(E(gr0)$weight))
    max.wt = max(abs(E(gr)$weight))
    ee.wt = E(gr)$weight / (0.8*max.wt + 0.2*max.wt0)
    E(gr)$width <- 1 + 6*abs(ee.wt)**2
    E(gr)$color <- "#88888888"
    E(gr)$color <- paste0(col2hex(ee.palette[round(8+7*ee.wt)]),"44")
    E(gr)$label <- round(E(gr)$weight,digits=4)
    
    if(0) {
        rho = gr[,]
        gene
        sort(rho[gene,])
        cor( ngs$X["ITK",], ngs$X["ZAP70",] )
        jj = order(ngs$X["ITK",])
        plot( ngs$X["ITK",], ngs$X["ZAP70",] )         
    }
    
    visdata <- toVisNetworkData(gr, idToLabel=FALSE)
    pos <- gr$layout[V(gr)$name,]
    pos[,2] <- -pos[,2]
    ## ------------------ plot using visNetwork (zoomable) -----------------
    graph <- visNetwork(nodes = visdata$nodes, edges = visdata$edges,
                        height="800px", width="1200px") %>%
        visNodes(size=18, font=list(size=20))  %>%
        visEdges(width=2, hidden=FALSE, color=list(opacity=0.01),
                 scaling=list(min=3,max=5), font=list(size=6) )  %>%
        visOptions(highlightNearest = list(enabled = T, degree = 1, hover = T)) %>%
        ##visHierarchicalLayout(direction = "LR") %>%
        ##visInteraction(hideEdgesOnDrag = TRUE) %>%
        visIgraphLayout(layout="layout_with_fr")
    graph

   
    
})
```


Col {.tabset data-width=300}
----------------------------------------------------------------------------------------

### Score

```{r}
fillCol(flex = c(1,0.1,1), 
        ##plotOutput("feature_score_plot"),
        ##plotOutput("projection_plot"), br(),
        dataTableOutput('feature_score_table'),
        br(), 
        dataTableOutput('target_score_table')
        )

featureScores <- reactive({
    ngs = inputData()
    if(is.null(ngs)) return(NULL)
    if(is.null(input$gr_level)) return(NULL)
    if(is.null(input$gr_contrast)) return(NULL)
    if(is.null(ngs$omicsnet)) return(NULL)
    
    level="gene";comp=3
    gr = ngs$omicsnet
    level = input$gr_level
    comp = input$gr_contrast
    
    fc = gr$foldchange
    fc <- fc[which(V(gr)$level==level),comp]
    ps <- ngs$pathscores[,comp]
    nodes <- V(gr)$name[which(V(gr)$level==level)]
    fc <- fc[nodes]
    ps <- ps[nodes]
    scores <- data.frame(logFC=fc, pathscore=ps)
    rownames(scores) = sub(".*\\}","",rownames(scores))

    fam = FAMILIES[[10]]
    ##if(level=="gene")    fam <- ngs$families[[input$gr_features]]
    if(level=="gene")    fam <- GSETS[[input$gr_features]]
    if(level=="geneset") fam <- COLLECTIONS[[input$gr_features]]
    scores = scores[which(toupper(rownames(scores)) %in% toupper(fam)),,drop=FALSE]
    rnk <- rowMeans(apply(abs(scores),2,rank))
    scores = scores[order(-rnk),,drop=FALSE]
    scores = round(scores, digits=3)
    return(scores)
})

output$feature_score_table <- renderDataTable({

    ngs = inputData()
    if(is.null(ngs)) return(NULL)
    if(is.null(ngs$omicsnet)) {
        validate(need(!is.null(ngs$omicsnet),"no omicsnet in ngs object"))
        return(NULL)
    }

    scores = featureScores()
    feature = substring(rownames(scores),1,40)
    score_table = data.frame( feature=feature, scores )
    
    DT::datatable( score_table,
                  class = 'compact cell-border stripe hover',
                  rownames=FALSE,
                  ##rownames=TRUE,
                  extensions = c('Buttons','Scroller'),
                  selection=list(mode='single', target='row', selected=c(1)),
                  options=list(
                      dom = 'frti', 
                      ##dom = 'Blfrtip', 
                      scrollX = TRUE, scrollY = 280, scroller=TRUE ## deferRender=TRUE
                  )  ## end of options.list 
                  ) %>%
        DT::formatStyle(0, target='row', fontSize='11px', lineHeight='70%')  %>%
            DT::formatStyle( "logFC",
                            ##background = styleColorBar(c(0,3), 'lightblue'),
                            background = color_from_middle(scores$logFC, 'lightblue', '#f5aeae'),
                            backgroundSize = '98% 88%',
                            backgroundRepeat = 'no-repeat',
                            backgroundPosition = 'center')


})

output$target_score_table <- renderDataTable({

    ngs = inputData()
    if(is.null(ngs)) return(NULL)
    gr = ngs$omicsnet
    if(is.null(gr)) return(NULL)

    scores = featureScores()
    sel = input$feature_score_table_rows_selected
    if(is.null(sel)) return(NULL)
    sel.feature = rownames(scores)[sel]
    gene = "IRF4"
    gene = geneset = NULL
    if(input$gr_level=="gene")  gene = sel.feature
    if(input$gr_level=="geneset") geneset = sel.feature

    cat("target_score_table:: gene=",gene,"\n")
    cat("target_score_table:: geneset=",geneset,"\n")
    
    targets = pgx.plotDualProjection(
        gr, gene=gene, geneset=geneset, plot=FALSE )
    cat("target_score_table:: head.targets=",head(targets),"\n")

    score = gr$foldchange[targets,,drop=FALSE]
    comp = 3
    comp = input$gr_contrast
    if( comp == "<sd>") {
        score = rowMeans(score**2)**0.5
    } else {
        score = score[,comp]
    }
    score = round(score, digits=3)
    names(score) = sub(".*\\}","",names(score))
    score = score[order(-abs(score))]
    target = substring(names(score),1,40)
    score_table = data.frame( target=target, logFC=score )
    
    DT::datatable( score_table,
                  class = 'compact cell-border stripe hover',
                  rownames=FALSE,
                  ##rownames=TRUE,
                  ##extensions = c('Buttons','Scroller'),
                  extensions = c('Scroller'),
                  selection=list(mode='none'),
                  options=list(
                      dom = 'frti',
                      ##dom = 'Blfrtip', 
                      ##pageLength = 20,##  lengthMenu = c(20, 30, 40, 60, 100, 250),
                      scrollX = TRUE, scrollY = 280, scroller=TRUE, deferRender=TRUE
                  )  ## end of options.list 
                  ) %>%
        DT::formatStyle(0, target='row', fontSize='11px', lineHeight='70%')  %>%
            DT::formatStyle( "logFC",
                            ##background = styleColorBar(c(0,3), 'lightblue'),
                            background = color_from_middle(score, 'lightblue', '#f5aeae'),
                            backgroundSize = '98% 88%',
                            backgroundRepeat = 'no-repeat',
                            backgroundPosition = 'center')

})

```


### Overview
    
```{r message=FALSE, warning=FALSE, fig.width=4}
renderPlot({
    ngs = inputData()
    if(is.null(ngs)) return(NULL)

    level="gene"
    level="geneset"
    gr = ngs$omicsnet
    if(is.null(gr)) {
        cat("WARNING:: omicsnet missing in ngs object!!\n")
        return(NULL)
    }
    level = input$gr_level
    fc = gr$foldchange
    table(V(gr)$level)
    sel = which(V(gr)$level==level)
    fc = fc[sel,,drop=FALSE]
    pos = gr$layout[,]
    fc = fc[match(rownames(pos),rownames(fc)),,drop=FALSE]
    head(fc)
    head(pos)
    
    par(mfrow=c(4,3), mar=c(1,0.3,3,0.3))
    if(ncol(fc)>12) par(mfrow=c(5,4), mar=c(1,0.2,3,0.2))
    i=1
    for(i in 1:min(20,ncol(fc))) {
        fx1 = fc[,i]
        fx1 = fx1 / max(abs(fx1),na.rm=TRUE)
        klr = cut(fx1, breaks=c(-99,-0.1,0.1,99),
                  label=c("blue","grey50","red") )
        klr = as.character(klr)
        table(is.na(klr))
        klr[is.na(klr)] = "grey80"
        j0 = grep("grey80",klr)
        j1 = grep("grey80",klr,invert=TRUE)
        j0 = sample(j0, min(5000,length(j0)))
        plot( pos[j0,1:2], pch=".", cex=2, col=klr[j0],
             xaxt="n", yaxt="n",
             xlim=1.1*range(pos[,1]), ylim=1.05*range(pos[,2]) )
        points( pos[j1,1:2], pch=".", cex=2, col=klr[j1])
        title( colnames(fc)[i], cex.main=1.5, line=1)
    }
    

})    
```




