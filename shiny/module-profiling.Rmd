Profiling
================================================================================

Inputs {.sidebar data-width=250}
--------------------------------------------------------------------------------

<br> **Cell Profiling**. Visualize the distribution of (inferred)
immune cell types, expressed genes and pathway activation.

<br><br>

```{r}
##source("../R/pgx-deconv.R")
selectInput("pr_samplefilter","Filter samples:", choices=NULL, multiple=TRUE)

br()
br()
radioButtons('pr_clustmethod',NULL,c("tsne","pca"), inline=TRUE, selected="tsne")
##radioButtons('pr_labelmode',NULL,c("label","legend"), inline=TRUE)
checkboxInput("pr_rowscale", "scale rows", TRUE)
if(PRO.VERSION) checkboxInput("pr_group", "group", FALSE)

##if(PRO.VERSION) radioButtons('pr_binoptions','bin',c(0,10,20), inline=TRUE)
##if(PRO.VERSION) selectInput("pr_dcmethod","Method:", choices=NULL, multiple=FALSE)
##if(PRO.VERSION) selectInput("pr_refset", "Reference:", choices=NULL, width='80%')

## update filter choices upon change of data set 
observe({
    ngs <- inputData()
    if(is.null(ngs)) return(NULL)
    ## levels for sample filter
    levels <- getLevels(ngs$Y)
    updateSelectInput(session, "pr_samplefilter", choices=levels)
})

observe({
    ngs <- inputData()
    if(is.null(ngs)) return(NULL)

    refsets = "LM22"
    ##if(PRO.VERSION) refsets <- sort(names(ngs$deconv))
    ##if(PRO.VERSION) updateSelectInput(session,"pr_refset",choices=refsets, selected="LM22")
    refsets <- sort(names(ngs$deconv))
    refsel <- grep("LM22",refsets,value=TRUE)
    updateSelectInput(session,"pr_refset",choices=refsets, selected=refsel)
       
    dcmethods <- names(ngs$deconv[[1]])
    dcsel <- intersect(c("meta.prod","meta"),dcmethods)[1]
    updateSelectInput(session, "pr_dcmethod", choices=dcmethods, selected=dcsel)
})


```


Col {.tabset data-width=625}
----------------------------------------------------------------------------------------

### Cell type

```{r}
fillCol(flex = c(NA,1), 
        inputPanel(
            ##radioButtons('pr_view',NULL,c("distribution","dotmap","heatmap"), inline=TRUE),
            selectInput("pr_view","plot type:", choices=c("distribution","dotmap","heatmap")),
            selectInput("pr_refset", "reference:", choices=NULL),
            selectInput("pr_dcmethod","method:", choices=NULL),
            cellArgs=list(width='40%')
        ),
        plotOutput("pr_icpplot", height = "100%", width = "100%")
        )

getDeconvResults <- reactive({
    ngs <- inputData()
    if(is.null(ngs)) return(NULL)
    method = "meta"
    method <- input$pr_dcmethod
    if(is.null(method)) return(NULL)
    
    refset = "LM22"
    ##if(PRO.VERSION) refset <- input$pr_refset
    refset <- input$pr_refset
    if(!("deconv" %in% names(ngs))) return(NULL)
    results <- ngs$deconv[[refset]][[method]]
    ## threshold everything (because DCQ can be negative!!!)
    results <- pmax(results,0)
    
    return(results)
})

output$pr_icpplot <- renderPlot({
    require(RColorBrewer)
    
    ngs <- inputData()
    if(is.null(ngs)) return(NULL)
    
    clust <- pfGetClusterPositions()
    if(is.null(clust)) return(NULL)
    pos <- ngs$tsne2d
    pos <- clust$pos
    
    score <- ngs$deconv[["LM22"]][["meta"]]
    score = getDeconvResults()
    if(is.null(score) || length(score)==0  ) return(NULL)
    
    ## normalize
    score <- score[rownames(pos),,drop=FALSE]
    score[is.na(score)] <- 0
    score <- pmax(score,0)
    ##score <- score - min(score,na.rm=TRUE) + 0.01 ## subtract background??
    ##score <- score / (1e-20 + sqrt(rowMeans(score**2,na.rm=TRUE)))
    score <- score / (1e-20 + rowSums(score))
    score <- tanh(score/mean(abs(score)))
    score <- score / max(score,na.rm=TRUE)
    summary(as.vector(score))

    ## take top10 features
    jj.top <- unique(as.vector(apply(score,1,function(x) head(order(-x),10))))
    score <- score[,jj.top]
    score <- score[,order(-colMeans(score**2))]    
    score <- score[,1:min(50,ncol(score))]
    ii <- hclust(dist(score))$order
    jj <- hclust(dist(t(score)))$order
    score <- score[ii,jj]
    score0 <- score
    pos <- pos[rownames(score),]
    
    if(PRO.VERSION && input$pr_group && input$pr_view!="distribution") {
        grp <- ngs$samples[rownames(score),"group"]
        pos <- apply(pos,2,function(x) tapply(x,grp,median))
        score <- apply(score,2,function(x) tapply(x,grp,mean))
        ii <- hclust(dist(score))$order
        jj <- hclust(dist(t(score)))$order
        score <- score[ii,jj]        
    }    
    b0 <- 1 + 0.85*pmax(30 - ncol(score), 0)

    if(input$pr_view=="dotmap") {
        require(corrplot)
        ##gx.heatmap(score)
        par(mfrow=c(1,1), mar=c(0,0,8,1), oma=c(1,1,1,1)*0.5 )
        score3 <- score**1.5
        rownames(score3) <- paste("",rownames(score3),"  ")
        tl.srt=90
        tl.cex=ifelse(nrow(score)>60,0.7,0.85)
        if(max(sapply(rownames(score3),nchar))>30) tl.srt=45
        corrplot( t(score3), mar=c(b0,1,4,1),
                 cl.lim = c(0,max(score3)), cl.pos = "n",
                 tl.cex = tl.cex, tl.col = "grey20",
                 tl.srt = tl.srt )
    }

    if(input$pr_view=="heatmap") {

        if(PRO.VERSION) {            

            kk <- head(colnames(score)[order(-colMeans(score**2))],18)
            kk <- intersect(colnames(score),kk)
            all.scores <- ngs$deconv[["LM22"]]
            all.scores <- ngs$deconv[[input$pr_refset]]
            if(input$pr_group && input$pr_view!="distribution") {
                grp <- ngs$samples[rownames(all.scores[[1]]),"group"]
                for(i in 1:length(all.scores)) {
                    all.scores[[i]] <- apply(all.scores[[i]],2,
                                             function(x) tapply(x,grp,mean))
                    ii <- rownames(score)
                    all.scores[[i]] <- all.scores[[i]][ii,kk]
                }
            }    

            nm <- length(all.scores)
            m=3;n=2
            if(nm>6) {m=3;n=3}
            if(nm>9) {m=4;n=3}
            rr <- 2+max(nchar(colnames(score)))/2
            par(mfrow=c(m,n), mar=c(0,0.3,2,0.3), oma=c(10,0,0,rr), xpd=TRUE)
            k=1
            for(k in 1:length(all.scores)) {
                ii <- rownames(score)
                score1 <- all.scores[[k]][ii,kk]
                ##score1 <- score1[rownames(score0),kk]
                if(k%%n!=0) colnames(score1) <- rep("",ncol(score1))
                if((k-1)%/%n!=(nm-1)%/%n) rownames(score1) <- rep("",nrow(score1))
                score1 <- score1 / (1e-8+rowSums(score1))
                if(nrow(score1) > 100)  rownames(score1) <- rep("",nrow(score1))
                gx.imagemap( t(score1**1), cex=0.85, main="", clust=FALSE)
                title(main=names(all.scores)[k], cex.main=1.1, line=0.4, font.main=1)
            }
            
        } else {
            score1 <- score
            score1 <- score1 / (1e-8+rowSums(score1))            
            if(nrow(score1) > 100)  rownames(score1) <- rep("",nrow(score))
            gx.heatmap( t(score1**2), scale="none", 
                       cexRow=1, cexCol=0.6, col=heat.colors(16),
                       mar=c(b0,15), key=FALSE, keysize=0.5)
        }
        
    }    
    
    if(input$pr_view=="distribution") {
        
        cex1 = 1.2
        cex1 <- 0.9*c(2.2,1.1,0.6,0.3)[cut(nrow(pos),breaks=c(-1,40,200,1000,1e10))]
        klrpal = colorRampPalette(c("grey90", "grey50", "red3"))(16)
        ##klrpal = paste0(col2hex(klrpal),"AA")    
        klrpal = paste0(col2hex(klrpal),"66")
        
        par(mfrow=c(5,5), mar=c(0.2,0.2,1.8,0.2), oma=c(1,1,1,1)*0.8 )
        par(mfrow=c(5,5), mar=c(0,0.2,0.5,0.2), oma=c(1,1,1,1)*0.8)
        if(ncol(score)>25) par(mfrow=c(6,6), mar=c(0,0.2,0.5,0.2)*0.6)
        i=1    
        
        jj <- head(order(-colMeans(score**2)),36)
        jj <- jj[order(colnames(score)[jj])]
        colnames(score)[jj]
        for(j in jj) {
            gx = pmax(score[,j],0)
            gx = 1+round(15*gx/(1e-8+max(score)))
            klr0 = klrpal[gx]
            ii <- order(gx)
            ## ii <- sample(nrow(pos))
            plot( pos[ii,], pch=19, cex=1*cex1, col=klr0[ii],
                 xlim=1.2*range(pos[,1]), ylim=1.2*range(pos[,2]),
                 fg = gray(0.8), bty = "o", xaxt='n', yaxt='n',
                 xlab="", ylab="")
            legend( "topleft", legend=colnames(score)[j], bg="#AAAAAA88",
                   cex=1.2, text.font=1, y.intersp=0.8, bty="n",
                   inset=c(-0.05,-0.0) )
        }

    }

}, res=90)
```

### Markers

```{r}

fillCol(height = "100%", flex = c(NA, 1), 
        inputPanel(
            selectInput("pr_level",NULL, choices=c("gene","geneset")),
            selectInput("pr_features",NULL, choices=NULL, multiple=FALSE),
            textInput("pr_search",NULL),
            cellArgs=list(width='100%')
        ),
        ##scatterD3Output("pcaplot", height = "100%")
        plotOutput("pr_markersplot", height = "100%")
        )

observe({
    ngs <- inputData()
    if(is.null(ngs)) return(NULL)
    choices <- names(ngs$families)
    selected = grep("^CD",choices,ignore.case=TRUE,value=TRUE)[1]
    if(input$pr_level=="geneset") {
        choices <- names(COLLECTIONS)
        selected = grep("HALLMARK",names(COLLECTIONS),ignore.case=TRUE,value=TRUE)
    }
    updateSelectInput(session, "pr_features", choices=choices, selected=selected)
})

output$pr_markersplot <- renderPlot({
    ##if(!input$tsne.all) return(NULL)
    require(RColorBrewer)
    
    ngs <- inputData()
    if(is.null(ngs)) return(NULL)
    
    clust <- pfGetClusterPositions()
    if(is.null(clust)) return(NULL)
    pos <- ngs$tsne2d
    pos <- clust$pos
    
    ##markers <- ngs$families[["CD family"]]
    if(is.null(input$pr_features)) return(NULL)
    if(input$pr_features=="") return(NULL)
    
    if(input$pr_level=="gene") {
        markers <- ngs$families[["Transcription factors (ChEA)"]]
        if(input$pr_search!="") {
            term = input$pr_search
            jj <- grep(term, ngs$genes$gene_name, ignore.case=TRUE )
            markers <- ngs$genes$gene_name[jj]
        } else if(input$pr_features %in% names(ngs$families)) {
            markers <- ngs$families[[input$pr_features]]
        } else {
            markers <- ngs$genes$gene_name
        }
        ##markers <- intersect(markers, rownames(ngs$X))       
        markers <- intersect(markers,ngs$genes$gene_name)
        jj <- match(markers,ngs$genes$gene_name)
        pmarkers <- intersect(rownames(ngs$genes)[jj],rownames(ngs$X))
        gx <- ngs$X[pmarkers,rownames(pos),drop=FALSE]
    } else if(input$pr_level=="geneset") {
        ##markers <- ngs$families[["Immune checkpoint (custom)"]]
        markers <- COLLECTIONS[[1]]
        if(is.null(input$pr_features)) return(NULL)
        ft <- input$pr_features
        if(input$pr_search=="" && ft %in% names(COLLECTIONS)) {
            markers <- COLLECTIONS[[input$pr_features]]
            markers <- intersect(markers, rownames(ngs$gsetX))
        } else if(input$pr_search!="") {
            term = input$pr_search
            jj <- grep(term, rownames(ngs$gsetX), ignore.case=TRUE )
            markers <- rownames(ngs$gsetX)[jj]
        } else {
            markers <- rownames(ngs$gsetX)
        }
        gx <- ngs$gsetX[markers,rownames(pos),drop=FALSE]
    } else {
        cat("fatal error")
        return(NULL)
    }
    
    ## prioritize gene with large variance (groupwise)
    grp <- as.character(ngs$samples[rownames(pos),"group"])
    zx <- t(apply(gx,1,function(x) tapply(x,grp,mean)))
    gx <- gx[order(-apply(zx,1,sd)),,drop=FALSE]
    gx <- gx - min(gx,na.rm=TRUE) + 0.01 ## subtract background??    
    rownames(gx) = sub(".*:","",rownames(gx))
       
    ##gx <- tanh(gx/sd(gx) ) ## softmax
    cex1 = 1.0
    cex1 <- 0.8*c(2.2,1.1,0.6,0.3)[cut(nrow(pos),breaks=c(-1,40,200,1000,1e10))]
    klrpal <- colorRampPalette(c("grey90", "grey80", "grey70", "grey60","red4", "red3"))(16)
    klrpal = colorRampPalette(c("grey90", "grey60", "red3"))(16)
    klrpal = paste0(col2hex(klrpal),"66")

    NP=25
    if(input$pr_level=="gene") NP=36
    top.gx = head(gx,NP)  ## match number of plot below!
    top.gx = top.gx[order(rownames(top.gx)),,drop=FALSE]
    top.gx = pmax(top.gx,0)
    ##top.gx <- tanh(top.gx/mean(top.gx))

    plevel="gene"
    plevel <- input$pr_level
    
    ## plot(0, type="n")  %>% withSpinner(color="#0dc5c1")  
    par(mfrow=c(1,1)*sqrt(NP), mar=c(0,0.2,0.5,0.2)*0.6, oma=c(1,1,1,1)*0.5)
    ##par(mfrow=c(6,6), mar=c(0,0.2,0.5,0.2), oma=c(1,1,1,1)*0.5)
    i=1    
    for(i in 1:min(NP,nrow(top.gx))) {

        colvar = pmax(top.gx[i,],0) 
        colvar = 1+round(15*(colvar/(0.7*max(colvar)+0.3*max(top.gx))))
        klr0 = klrpal[colvar]

        ii <- order(colvar)
        ##ii <- sample(nrow(pos))
        plot( pos[ii,], pch=19, cex=cex1, col=klr0[ii],
             xlim=1.1*range(pos[,1]), ylim=1.1*range(pos[,2]),
             fg = gray(0.8), bty = "o",
             xaxt='n', yaxt='n', xlab="tSNE1", ylab="tSNE2")

        if(plevel=="gene") {
            gene <- sub(".*:","",rownames(top.gx)[i])
            ##title( gene, cex.main=1.0, line=0.3, col="grey40", font.main=1)
            legend( "topleft", legend=gene, bg="#AAAAAA88",
                   cex=1.1, text.font=1, y.intersp=0.8,
                   bty="n", inset=c(-0.05,-0.0) )
        } else {
            gset <- sub(".*:","",rownames(top.gx)[i])
            gset1 <- breakstring(substring(gset,1,80),24,force=TRUE)
            gset1 <- tolower(gset1) 
            ##title( gset1, cex.main=0.9, line=0.4, col="grey40", font.main=1)
            legend( "topleft", legend=gset1, cex=0.95, bg="#AAAAAA88",
                   text.font=2, y.intersp=0.8, bty="n",
                   inset=c(-0.05,-0.0) )
        }
    }

    
}, res=100)
```


### CNV (alpha)

```{r}

fillCol(height = "100%", flex = c(NA, 1), 
        inputPanel(
            selectInput("pr_cna_annotvar",label="annotate with:", choices=NULL, multiple=FALSE),
            ##checkboxGroupInput('pr_cnaoptions','',c("bin20"), inline=TRUE),
            ##radioButtons('pr_cnaplottype',NULL,c("image","heatmap","splitmap"), inline=TRUE),
            radioButtons('pr_cna_orderby',"order by",c("clust","pc1"), inline=TRUE),            
            cellArgs=list(width='80px')
        ),
        plotOutput("pr_cnaplot", height = "100%")
        )

observe({
    ngs <- inputData()
    if(is.null(ngs)) return(NULL)
    ## levels for sample filter
    annotvar <- c(colnames(ngs$Y),"<none>")
    updateSelectInput(session, "pr_cna_annotvar", choices=annotvar)
})

getCNAfromExpression <- reactive({
    ngs <- inputData()
    if(is.null(ngs)) return(NULL)
    ##source("../R/pgx-cna.R");source("../R/gx-heatmap.r")
    res <- pgx.CNAfromExpression(ngs, nsmooth=40, downsample=10) 
    return(res)
})

output$pr_cnaplot <- renderPlot({
    require(RColorBrewer)
    ##return(NULL)    
    ngs <- inputData()
    if(is.null(ngs)) return(NULL)
    res <- getCNAfromExpression()
    if(is.null(res)) return(NULL)
    annotvar=NA
    annotvar <- input$pr_cna_annotvar
    if(annotvar=="<none>") annotvar <- NULL
    order.by <- input$pr_cna_orderby
    pgx.plotCNAHeatmap(ngs, res, annot=annotvar, order.by=order.by)

}, res=110)
```


```{r, eval=FALSE}
####################################################################
############### DISABLED ###########################################
####################################################################

### Correlate
fillCol(height = "100%", flex = c(NA, 1), 
        inputPanel(
            selectInput("pr_corvar1",label="gene:", choices=NULL, multiple=FALSE),
            selectInput("pr_corvar2",label="proportion:", choices=NULL, multiple=FALSE),
            selectInput("pr_coravg",label="average by:", choices=NULL, multiple=FALSE),
            ##br(),
            cellArgs=list(width='80px')
        ),
        plotOutput("pr_corplot1", height = "100%")
        )

observe({
    ngs <- inputData()
    if(is.null(ngs)) return(NULL)
    ##if(is.null(input$pr_statoptions)) return(NULL)
    var1 <- sort(rownames(ngs$X))
    var2 <- sort(colnames(ngs$Y))

    sel2 = sel3 =  NULL
    ##sel2 = "cell.type";sel3 = "patient"
    ##var2 = getLevels(ngs$Y)
    var2 = grep("group|sample|donor|group",colnames(ngs$Y),invert=TRUE,value=TRUE)
    var2 = colnames(ngs$Y)
    var2 = c("<cell type>",var2)
    grpvar  <- sort(colnames(ngs$Y))
    grpvar = grep("patient|sample|donor|group",colnames(ngs$sample),value=TRUE)
    grpvar = c("<bin>",grpvar)
    var2 = setdiff(var2, grpvar)
    ##grpvar = intersect(colnames(ngs$sample),grpvar)
    updateSelectInput(session, "pr_corvar1", choices=var1)
    updateSelectInput(session, "pr_corvar2", choices=var2)
    updateSelectInput(session, "pr_coravg",  choices=grpvar)
    ##updateSelectInput(session, "pr_cory", choices=ypheno)
})

output$pr_corplot1 <- renderPlot({
    ##if(!input$tsne.all) return(NULL)
    require(RColorBrewer)
    ngs <- inputData()
    if(is.null(ngs)) return(NULL)
    
    if(is.null(input$pr_corvar1)) return(NULL)
    if(is.null(input$pr_corvar2)) return(NULL)
    if(is.null(input$pr_coravg)) return(NULL)

    kk <- 1:nrow(ngs$Y)
    kk <- selectSamplesFromSelectedLevels(ngs$Y, input$pr_samplefilter)
    
    grp <- ngs$sample[kk,"patient"]
    grp <- NULL
    if(input$pr_coravg!="<bin>") {
        grp <- ngs$sample[kk,input$pr_coravg]
    } else {
        ##grp <- 1:kk
    }
    
    xvar="P2RX7"
    xvar="CD4"
    xvar="CD8A"
    yvar="<cell type>"
    xvar <- input$pr_corvar1
    yvar <- input$pr_corvar2

    gx <- ngs$X[xvar,kk]
    scores <- ngs$deconv[[1]][["meta"]]
    scores <- getDeconvResults()
    if(is.null(scores)) return(NULL)
    scores <- pmax(scores,0) ## ??
    maxscoring <- colnames(scores)[max.col(scores)]
    names(maxscoring) <- rownames(scores)
    
    if(yvar=="<cell type>") {
        yvalues <- unique(maxscoring[kk])
        y1 <- maxscoring[kk]
    } else {
        yvalues <- unique(as.character(ngs$samples[kk,yvar]))
        y1 <- as.character(ngs$sample[kk,yvar])
    }

    bin <- as.integer(input$pr_binoptions)
    if(PRO.VERSION && !is.null(grp) && bin!=0) {
        ## divide groups in smaller subgroups
        subgrp <- tapply(as.character(grp), grp, function(a) paste0(a,".",1:(length(a)/bin)))
        grp <- unlist(subgrp)
    }
    if(PRO.VERSION && is.null(grp) && bin!=0) {
        ## divide groups in smaller subgroups
        ##subgrp <- rep(1:bin,length(kk)/bin+1)[1:length(kk)]
        subgrp <- as.vector(sapply(1:(1+length(gx)/bin),rep,bin))[1:length(gx)]
        grp <- unlist(subgrp)
    }

    if(!is.null(grp)) {
        ## check minimum group size
        grp <- as.character(grp)
        grp1 <- names(which(table(grp) >= 2))  ## at least 2?
        if(length(kk)>500)  grp1 <- names(which(table(grp) >= 5))  ## at least 2?
        jj <- which(grp %in% grp1)
        ngrp <- length(unique(grp[jj]))
        ngrp
        if(ngrp < 3) {
            validate(need(ngrp >= 3, "too few groups. cannot calculate proportions."))
            cat("pr_corplot1:: warning: too few groups. bailing out.")
            return(NULL)
        }
        gx <- tapply(gx[jj], grp[jj], mean)
        Y = sapply(yvalues, function(a) 100*tapply( 1*(y1[jj]==a), grp[jj], mean, na.rm=TRUE))
        Y <- as.matrix(Y)
        colnames(Y) <- yvalues

    } else {
        ##Y = sapply(yvalues, function(a) 100*mean(y1==a))
        y1[is.na(y1)] <- "_"
        Y = 100*model.matrix( ~ 0 + y1)
        Y <- as.matrix(Y)
        colnames(Y) <- yvalues
    }
    
    rho <- cor(Y, gx)[,1]
    ##Y <- Y[,order(-apply(Y,2,max,na.rm=TRUE)),drop=FALSE]
    Y <- Y[,order(-abs(rho))]
        
    ##par(mar = c(4,6,2,3))
    ##layout(matrix(c(1,2,3), 3, 1), heights=c(1.4,3,2.5))
    par(mfrow=c(4,4), mar = c(3,4,1.6,1), mgp=c(1.8,0.7,0) )
    for(i in 1:min(16,ncol(Y))) {
        plot(gx, Y[,i], pch=19, cex=1, xlab=xvar,
             ylab="proportion (%)", ylim=c(0,100) )
        abline( lm( Y[,i] ~ gx), col="red")
        ##title(paste0(yvar,"=",colnames(Y)[i]),cex.main=1,line=0.5)
        title(colnames(Y)[i],cex.main=1,line=0.5)
        pv <- cor.test(Y[,i] , gx)$p.value
        r <- cor.test(Y[,i] , gx)$estimate
        tt <- c(paste("r=", round(r,digits=3)),
                paste("p=", round(pv, digits=3)))
        legend("topright", legend=tt, bty="n", cex=0.85, y.intersp=0.8)
    }
    ##x <- log10(1+grp.counts[colnames(grp.score)])
    
}, res=95)
```


Col {.tabset data-width=375}
----------------------------------------------------------------------------------------

### Phenotypes 

```{r}
fillCol(flex = c(NA,1), 
        inputPanel(
            radioButtons('pr_labelmode',NULL,c("label","legend"), inline=TRUE),
            cellArgs=list(width='40%')
        ),
        plotOutput("pr_phenoplot", height = "100%", width = "100%")
        )

output$pr_phenoplot <- renderPlot({
    ##if(!input$tsne.all) return(NULL)
    require(RColorBrewer)
    ngs <- inputData()
    if(is.null(ngs)) return(NULL)
    
    clust <- pfGetClusterPositions()
    if(is.null(clust)) return(NULL)
    
    pos <- ngs$tsne2d
    pos <- clust$pos
    sel <- rownames(pos)
    pheno = colnames(ngs$Y)

    ## layout
    par(mfrow = c(3,2), mar=c(0.3,0.7,2.8,0.7))
    if(length(pheno)>6) par(mfrow = c(4,3), mar=c(0.3,0.4,2.8,0.4)*0.8)
    if(length(pheno)>12) par(mfrow = c(5,4), mar=c(0.2,0.2,2.5,0.2)*0.8)
    
    cex1 <- 1.6*c(1.8,1.3,0.8,0.5)[cut(nrow(pos),breaks=c(-1,40,200,1000,1e10))]    
    cex1 = cex1 * ifelse(length(pheno)>6, 0.8, 1)
    cex1 = cex1 * ifelse(length(pheno)>12, 0.8, 1)

    is.num <- function(y) {
        suppressWarnings(numy <- as.numeric(as.character(y)))
        t1 <- !all(is.na(numy)) && is.numeric(numy)
        t2 <- length(unique(y)) > 0.33*length(y)
        (t1 && t2)
    }
    
    i=6    
    for(i in 1:min(20,length(pheno))) {

        px=4
        px=pheno[i]
        y = ngs$Y[sel,px]
        y[which(y %in% c(NA,""," ","NA","na"))] <- NA
        if(sum(!is.na(y))==0) next

        if(is.num(y)) {
            klrpal = colorRampPalette(c("grey90", "grey50", "red3"))(16)
            y = rank(as.numeric(y))
            ny <- round(1 + 15*(y - min(y))/(max(y)-min(y)))
            klr0 = klrpal[ny]
        } else {
            y = factor(as.character(y))
            klrpal = COLORS
            klrpal <- paste0(col2hex(klrpal),"99")
            klr0 = klrpal[y]
        }

        jj = which(is.na(klr0))
        if(length(jj)) klr0[jj] <- "#AAAAAA22"
        plot( pos, pch=19, cex=cex1, col=klr0,fg = gray(0.5), bty = "o",
             xaxt='n', yaxt='n', xlab="tSNE1", ylab="tSNE2")

        if(!is.num(y)) {
            if(input$pr_labelmode=="legend") {
                legend("bottomright", legend=levels(y), fill=klrpal,
                       cex=0.9, y.intersp=0.8, bg="white")
            } else {
                grp.pos <- apply(pos,2,function(x) tapply(x,y,mean,na.rm=TRUE))
                grp.pos <- apply(pos,2,function(x) tapply(x,y,median,na.rm=TRUE))
                nvar <- length(setdiff(y,NA))
                if(nvar==1) {
                    grp.pos <- matrix(grp.pos,nrow=1)
                    rownames(grp.pos) <- setdiff(y,NA)[1]
                }
                
                labels = rownames(grp.pos)
                ## title("\u2591\u2592\u2593") 
                boxes = sapply(nchar(labels),function(n) paste(rep("\u2588",n),collapse=""))
                boxes = sapply(nchar(labels),function(n) paste(rep("█",n),collapse=""))
                ##boxes = sapply(nchar(labels),function(n) paste(rep("#",n),collapse=""))
                cex2 <- c(1.4,1.2,1,0.8)[cut(length(labels),breaks=c(-1,5,10,20,999))]    
                text( grp.pos, labels=boxes, cex=cex2, col="#CCCCCC99")
                text( grp.pos, labels=labels, font=2, cex=1.1*cex2, col="white")
                text( grp.pos, labels=labels, font=2, cex=cex2)
                ##text( grp.pos[,], labels=rownames(grp.pos), font=2, cex=cex1**0.5)
            }
        }
        title(tolower(pheno[i]), cex.main=1.3, line=0.5, col="grey40")
    }
}, res=90)
```

### Proportions

```{r}
fillCol(height = "100%", flex = c(NA, 1), 
        inputPanel(
            ##fillRow( flex=c(1,1,NA,1),
            selectInput("pr_statvar",label="x-axis:", choices=NULL, multiple=FALSE),
            selectInput("pr_statpheno",label="y-axis:", choices=NULL, multiple=FALSE),
            selectInput("pr_statgene",label="gene:", choices=NULL, multiple=FALSE)
            ##checkboxGroupInput('pr_statoptions','',c("gene"), inline=TRUE, width='50px')
            ##selectInput("pr_statgene",label=NULL, choices=NULL, multiple=FALSE),
            ##br(), cellArgs=list(width='80px')
        ),
        plotOutput("statsplot", height = "100%")
        )

observe({
    ngs <- inputData()
    if(is.null(ngs)) return(NULL)
    ##if(is.null(input$pr_statoptions)) return(NULL)
    pheno0 <- grep("group|sample|donor|id|batch",colnames(ngs$samples),invert=TRUE,value=TRUE)
    kk <- selectSamplesFromSelectedLevels(ngs$Y, input$pr_samplefilter)
    nphenolevel <- apply(ngs$samples[kk,pheno0],2,function(v) length(unique(v)))
    pheno0 = pheno0[which(nphenolevel>1)]
    genes <- sort(as.character(ngs$genes$gene_name))
    pheno1 <- c("<cell type>",pheno0)
    genes1 <- c("<none>",genes)
    updateSelectInput(session, "pr_statvar", choices=pheno1)
    updateSelectInput(session, "pr_statpheno", choices=pheno1)
    updateSelectInput(session, "pr_statgene", choices=genes1)
})

output$statsplot <- renderPlot({
    ##if(!input$tsne.all) return(NULL)
    require(RColorBrewer)
    ngs <- inputData()
    if(is.null(ngs)) return(NULL)
    if(is.null(input$pr_statpheno)) return(NULL)
    if(is.null(input$pr_statvar)) return(NULL)
    ##if(is.null(input$pr_statoptions)) return(NULL)
    if(is.null(input$pr_statgene)) return(NULL)

    scores = ngs$deconv[[1]][[1]]  ## just an example...
    if(input$pr_statvar == "<cell type>") {
        scores <- getDeconvResults()
        if(is.null(scores)) return(NULL)
        scores <- pmax(scores,0) ## ??
    } else {
        x <- as.character(ngs$Y[,1])
        x <- as.character(ngs$Y[,input$pr_statvar])
        x[is.na(x)] <- "_"
        scores <- model.matrix( ~ 0 + x )
        rownames(scores) <- rownames(ngs$Y)
        colnames(scores) <- sub("^x","",colnames(scores))
    }
    dim(scores)

    ## restrict to selected sample set
    kk <- head(1:nrow(scores),1000)
    kk <- 1:nrow(scores)
    kk <- selectSamplesFromSelectedLevels(ngs$Y, input$pr_samplefilter)
    scores <- scores[kk,,drop=FALSE]
    scores <- scores[,which(colSums(scores)>0),drop=FALSE]
    scores[which(is.na(scores))] <- 0    
    dim(scores)

    ## expected counts per stat level
    ##kk.counts <- colSums(ngs$counts[,kk,drop=FALSE])  ## total count of selected samples
    kk.counts <- colSums(2**ngs$X[,kk,drop=FALSE])  ## approximate counts from log2X
    grp.counts <- ( t(scores / rowSums(scores)) %*% matrix(kk.counts,ncol=1))[,1]  
    
    getProportionsTable <- function(pheno, is.gene=FALSE) {    
        y <- NULL
        ##if("gene" %in% input$pr_statoptions) {
        if( is.gene ) {
            xgene <- ngs$genes[rownames(ngs$X),]$gene_name
            gx <- ngs$X[which(xgene == pheno),kk,drop=FALSE]
            gx.highTH <- mean(gx, na.rm=TRUE)
            y <- paste(pheno,c("low","high"))[ 1 + 1*(gx >= gx.highTH)]
            table(y)
        } else if(pheno %in% colnames(ngs$samples)) {
            y <- ngs$samples[kk,1]
            y <- ngs$samples[kk,pheno]
            pheno <- tolower(pheno)
        } else if(pheno == "<cell type>") {
            res1 <- getDeconvResults()
            res1 <- pmax(res1,0) ## ??
            res1 <- res1[kk,,drop=FALSE]
            ##res1 <- res1[,which(colSums(res1)>0),drop=FALSE]
            y <- colnames(res1)[max.col(res1)]  ## take maximum col??
            remove(res1)
            pheno <- "<cell type>"
        } else {
            return(NULL)
        }   
        
        ## calculate proportions by group
        grp <- factor(as.character(y))
        ngrp <- length(levels(grp))
        grp.score <- apply(scores, 2, function(x) tapply(x,grp,mean,na.rm=TRUE))
        ngrp
        if(ngrp==1) {
            grp.score <- matrix(grp.score,nrow=1)
            rownames(grp.score) <- y[1]
            colnames(grp.score) <- colnames(scores)
        }
        
        ## weighted counts
        grp.score[is.na(grp.score)] <- 0
        grps <- levels(grp)
        grp.score
        fy <-  (table(y) / sum(!is.na(y)))
        jj <- match(rownames(grp.score),names(fy))
        grp.score <-  grp.score * as.vector(fy[jj])
        ## normalize to total 100% 
        grp.score <- grp.score / (1e-20+sum(grp.score))
        
        ## reduce to maximum number of items (x-axis)
        if(0) {
            ##jj <- which(colSums(grp.score) > 0.001)
            jj <- order(-colSums(grp.score))
            j1 <- head(jj, 25)  ## define maximum number of items
            j0 <- setdiff(jj, j1)
            grp.score0 <- grp.score[,j1,drop=FALSE]
            grp.counts0 <- grp.counts[j1]
            if(length(j0)>0) {
                grp.score0 <- cbind( grp.score0, "other"=rowSums(grp.score[,j0,drop=FALSE]))
                grp.counts0 <- c(grp.counts0, "other"=sum(grp.counts[j0]))
            }
            grp.score <- grp.score0
            grp.counts <- grp.counts0
            grp.score <- t( t(grp.score) / (1e-20+colSums(grp.score)))  ##
        }
        
        ## normalize to total 100% and reduce to maximum number of items (y-axis)
        jj <- order(-rowSums(grp.score))
        j1 <- head(jj, 10)  ## define maximum number of items
        j0 <- setdiff(jj, j1)
        grp.score0 <- grp.score[j1,,drop=FALSE]
        if(length(j0)>0) {
            grp.score0 <- rbind( grp.score0, "other"=colSums(grp.score[j0,,drop=FALSE]))
        }
        grp.score <- grp.score0
        grp.score <- t( t(grp.score) / (1e-20+colSums(grp.score)))  ##

        ## cluster columns??
        ##dist1 <- dist(t(scale(grp.score)))
        dist1 <- dist(t(grp.score))
        dist1[is.na(dist1)] <- mean(dist1,na.rm=TRUE)
        jj <- hclust(dist1)$order
        grp.score <- grp.score[,jj,drop=FALSE]
        return(grp.score)
    }

    ## select phenotype variable
    head(ngs$samples)
    pheno=1
    pheno="cluster"
    pheno="activated"
    pheno="cell.type"
    pheno="<cell type>"
    pheno <- input$pr_statpheno
    if(is.null(pheno)) return(NULL)

    ##pheno="cluster"
    grp.score1 <- getProportionsTable(pheno, is.gene=FALSE)
    
    grp.score2 <- NULL
    gene = rownames(ngs$X)[1]
    gene = input$pr_statgene
    if(gene != "<none>") {
        grp.score2 <- getProportionsTable(pheno=gene, is.gene=TRUE)
        kk <- colnames(grp.score2)[order(grp.score2[1,])]
        grp.score2  <- grp.score2[,match(kk,colnames(grp.score2))]
        grp.score1  <- grp.score1[,match(kk,colnames(grp.score1))]
    }
    
    jj <- match(colnames(grp.score1),names(grp.counts))
    grp.counts <- grp.counts[jj] / 1e6  ## per million
    names(grp.counts) = colnames(grp.score1)

    ##-------------- plot by estimated cell.type ----------------------
    
    ##par(mar = c(4,6,2,3))
    layout(matrix(c(1,2,3), 3,1), heights=c(2,4,3))
    if(!is.null(grp.score2)) {
        layout(matrix(c(1,2,3,4), 4,1), heights=c(2.2,1,4,2))
    }
    
    ## top bar with counts
    par(mar = c(0,5,5.3,3), mgp=c(2.0,0.8,0) )
    xlim <- c(0,1.2*length(grp.counts))  ## reserves space for legend
    barplot( grp.counts, col="grey50", ylab="counts (M)", cex.axis=0.8,
            cex.lab=0.8, names.arg=NA, xpd=NA, xlim=1.3*xlim, ## log="y", 
            ylim=c(0.01, max(grp.counts)), yaxs="i" )
    ## title(pheno, cex.main=1.2, line=2, col="grey40")
    
    ## middle plot (gene)
    if(!is.null(grp.score2)) {
        klrpal2 = COLORS[1:nrow(grp.score2)]
        klrpal2 = rev(grey.colors(nrow(grp.score2),start=0.45))
        par(mar = c(0,5,0.3,3), mgp=c(2.4,0.9,0) )
        barplot( 100*grp.score2, col=klrpal2, las=3, srt=45,
                xlim=1.3*xlim, ylim=c(0,99.99),
                names.arg = rep(NA, ncol(grp.score2)),
                ylab="(%)", cex.axis=0.90)
        legend(1.02*xlim[2], 100, legend=rownames(grp.score2),
               fill=klrpal2, xpd=TRUE, cex=0.8, y.intersp=0.8,
               bg="white", bty="n")
    }

    if(1) {
        ## main proportion graph
        klrpal1 = COLORS[1:nrow(grp.score1)]
        par(mar = c(4,5,0.3,3), mgp=c(2.4,0.9,0) )
        barplot( 100*grp.score1, col=klrpal1, las=3, srt=45, xlim=1.3*xlim,
                ylim=c(0,99.99), ylab="proportion (%)", cex.axis=0.90)
        legend(1.02*xlim[2], 100, legend=rev(rownames(grp.score1)),
               fill=rev(klrpal1), xpd=TRUE, cex=0.8, y.intersp=0.8,
           bg="white", bty="n")
    }
    
}, res=120)
```

### CytoPlot (alpha)

```{r}
fillCol(flex = c(NA, 1), 
        inputPanel(
            ##fillRow( flex=c(1,1,NA,1),
            selectInput("pr_cytovar1",label="x-axis:", choices=NULL, multiple=FALSE),
            selectInput("pr_cytovar2",label="y-axis:", choices=NULL, multiple=FALSE)
            ##br(), cellArgs=list(width='80px')
        ),
        plotOutput("pr_cytoplot", height = "100%")
        )

observe({
    ngs <- inputData()
    if(is.null(ngs)) return(NULL)
    xgenes <- ngs$genes[rownames(ngs$X),]$gene_name
    genes <- sort(as.character(xgenes))
    g1 <- grep("^CD4|^CD8",genes,value=TRUE)[1]
    g2 <- grep("^CD79|^CD3[DEG]|^CD37",genes,value=TRUE)[1]
    updateSelectInput(session, "pr_cytovar1", choices=genes, selected=g1)
    updateSelectInput(session, "pr_cytovar2", choices=genes, selected=g2)
})

output$pr_cytoplot <- renderPlot({
    ##if(!input$tsne.all) return(NULL)
    require(RColorBrewer)
    ngs <- inputData()
    if(is.null(ngs)) return(NULL)
    if(is.null(input$pr_cytovar1)) return(NULL)
    if(is.null(input$pr_cytovar2)) return(NULL)

    kk <- selectSamplesFromSelectedLevels(ngs$Y, input$pr_samplefilter)    
    gene1 <- input$pr_cytovar1
    gene2 <- input$pr_cytovar2
    ##if(gene1 == gene2) return(NULL)
    par(mfrow=c(1,1), mar=c(12,4,6,2))
    pgx.cytoPlot( ngs, gene1, gene2, samples=kk, cex=0.8,
                 col="grey60", cex.names=1)
    
}, res=80)
```


```{r}
pfGetClusterPositions <- reactive({
    ngs <- inputData()
    if(is.null(ngs)) return(NULL)
    
    ##zx <- filtered_matrix1()
    zx = ngs$X
    kk <- selectSamplesFromSelectedLevels(ngs$Y, input$pr_samplefilter)
    if(length(kk)==0) return(NULL)
    
    zx <- zx[,kk,drop=FALSE]
    zx = head(zx[order(-apply(zx,1,sd)),],1000)
    zx = t(scale(t(zx)))  ## scale??

    if(FALSE && input$pr_group) {
        grp = ngs$Y[colnames(zx),"group"]
        zx = t(apply( zx, 1, function(x) tapply(x, grp, mean)))
    }

    pos = NULL
    if(input$pr_clustmethod=="tsne") {
        require(Rtsne)
        tsne.dim = 3
        ##do3d <- grepl("3D", as.character(input$pr_clustmethod))
        do3d <- ("3D" %in% input$pca.options)
        tsne.dim = c(2,3)[ 1 + 1*do3d]
        force.compute = FALSE
        ## force.compute = TRUE        
        if(!force.compute && tsne.dim==2 && !is.null(ngs$tsne2d) ) {
            pos <- ngs$tsne2d[colnames(zx),]
        } else if(!force.compute && tsne.dim==3 && !is.null(ngs$tsne3d) ) {
            pos <- ngs$tsne3d[colnames(zx),]
        } else {
            perplexity = max(min(30,ncol(zx)/4),1)
            perplexity = min((ncol(zx)-1)/3, 30)
            perplexity
            pos <- Rtsne( t(zx), dim=tsne.dim, check_duplicated=FALSE,
                         num_threads=100, ##Y_init=Y_init, 
                         perplexity=perplexity )$Y
        }
    } else {
        ##cat("pfGetClusterPositions:: computing PCA/SVD...\n")
        require(irlba)
        ##pos <- cmdscale(dist(t(zx)), k=3)
        ##pos = svd(zx,nv=3)$v
        pos = irlba(zx,nv=3)$v        
    }
    
    pos = scale(pos) ## scale 
    colnames(pos) = paste0("dim",1:ncol(pos))
    rownames(pos) = colnames(zx)    

    if(0) {
        tt = factor(ngs$sample$tissue.type)
        ct = factor(ngs$sample$cell.type)
        jj = which(tt %in% c("HCC","nonHCC"))
        jj = which(tt %in% c("Blood","nonHCC"))
        fc = gx.limma( zx[,jj], as.character(tt[jj]), fdr=1)        
        fc = gx.limma( zx[,], 1*(tt=="Blood"), fdr=1)
        gg = head(rownames(fc),100)
        ## gg = tail(rownames(fc),20)

        require(Rtsne.multicore)
        pos = svd(zx[gg,],nv=3)$v
        ##pos = Rtsne.multicore( t(zx[gg,]) )$Y
        par(mfrow=c(2,2))
        scatterD3(pos[,1], pos[,2], col_var=tt, symbol_var=ct,
                  point_size=150 )

        
    }

    ##if(input$pca.gx=="<cluster>")
    require(igraph)
    dist = as.dist(dist(pos))
    gr = graph_from_adjacency_matrix(
        1.0/dist, diag=FALSE, mode="undirected")
    clust <- cluster_louvain(gr)$membership

    ##cat("pfGetClusterPositions:: done!\n")
    return( list(pos=pos, clust=clust) )
})

```


