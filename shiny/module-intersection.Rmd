Intersection
================================================================================

Input {.sidebar data-width=250}
--------------------------------------------------------------------------------

<br>**Intersection analysis**. Compare experiments by intersecting
their signature genes. The main goal is to identify contrasts showing
similar profiles. Find genes that are commonly up/down regulated
between two contrasts.


```{r}
tipify( actionLink("cmp_info", "Info", icon = icon("info-circle")),
       "Show more information about this module")

cmp_infotext =
    "The <strong>Intersection analysis module</strong> enables users to compare multiple contrasts by intersecting the genes of profiles. The main goal is to identify contrasts showing similar profiles.

<br><br>For the selected contrasts, the platform provides volcano plots and pairwise correlation plots between the profiles in the <strong>Pairs</strong> panel. Simultaneously, a Venn diagram with the number of intersecting genes between the profiles is plotted in <strong>Venn diagram</strong> panel. Details of intersecting genes are also reported in an interactive table. A more detailed scatter plot of two profiles is possible under the <strong>Two-pairs</strong> panel. Users can check the pairwise correlations of the contrasts under the <b>Contrast heatmap</b> panel. Alternatively, the <strong>Connectivity Map (CMap)</strong> shows the similarity of the contrasts profiles as a t-SNE plot.

<br><br><center>
<iframe width='500' height='333' src='https://www.youtube.com/embed/KoS1y8xridY' frameborder='0' allow='accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture' allowfullscreen></iframe></center>

"

observeEvent( input$cmp_info, {
    showModal(modalDialog(
        title = HTML("<strong>Intersection Analysis Module</strong>"),
        HTML(cmp_infotext),
        easyClose = TRUE, size="l" ))
})


```


```{r}
##======================================================================
## Left side-bar general options
##======================================================================
br();hr();

tipify( selectInput('cmp_comparisons','Contrasts:', choices=NULL, multiple=TRUE),
       "Select the contrasts that you want to compare. If you select N=2 contrast a single scatterplot will be drawn. For N>=3 a scatterplot matrix will be drawn.",
       placement="top")

## delayed input
input_cmp_comparisons <- reactive({
    input$cmp_comparisons
}) %>% debounce(500)

tipify( selectInput("cmp_filter","Filter:", choices=NULL, multiple=FALSE),
       "Select feature filter", placement="top")

conditionalPanel(
    "input.cmp_filter == '<custom>'",
    tipify( textAreaInput("cmp_customlist", NULL, value = NULL,
                          rows=5, placeholder="Paste your custom gene list"),
           "Paste a custom list of genes to highlight.", placement="bottom")
)

##conditionalPanel(
##  "input.main_usermode == 'expert'",
    tagList(
        tipify( selectInput("cmp_level","Level:", choices=c("gene","geneset")),
               "Select feature level: gene or geneset", placement="top")
    )
##)

if(DEV.VERSION) {
    tagList(
	hr(),
        h5("Developer options:"),
        radioButtons('cmp_featuretype','Feature type:',
                     choices=c("logFC","logCPM"), inline=TRUE)
    )
}

## update choices upon change of data set 
observe({
    ngs <- inputData()
    req(ngs)    
    comparisons <- colnames(ngs$model.parameters$contr.matrix)
    comparisons <- sort(comparisons)
    updateSelectInput(session, "cmp_comparisons", choices=comparisons,
                      selected=head(comparisons,3))
})

## update choices upon change of feature level
##observeEvent( input$cmp_level, {
observe({
    ngs <- inputData()
    req(ngs,input$cmp_level)
    ##flt.choices = names(ngs$families)
    cat("[intersection:observeEvent] input.cmp_level=",input$cmp_level,"\n")
    if(input$cmp_level=="geneset") {
        ft <- names(COLLECTIONS)
        nn <- sapply(COLLECTIONS, function(x) sum(x %in% rownames(ngs$gsetX)))
        ft <- ft[nn >= 10]
    } else {
        ## gene level
        ft <- pgx.getFamilies(ngs,nmin=10,extended=FALSE)
    }
    ft <- sort(ft)
    ##if(input$cmp_level=="gene") ft = sort(c("<custom>",ft))
    ft = sort(c("<custom>",ft))

    cat("[intersection:observeEvent] head.ft=",head(ft),"\n")       
    updateSelectInput(session, "cmp_filter", choices=ft, selected="<all>")

    cat("[intersection:observeEvent] done!\n")       
    
})

observe({
    splom.sel <- plotly::event_data("plotly_selected", source="splom")
    sel.keys <- as.character(splom.sel$key)
    if(length(sel.keys)>0) {
        updateSelectInput(session, "cmp_filter", selected="<custom>")
        sel.keys = paste(sel.keys, collapse=" ")
        updateTextAreaInput(session, "cmp_customlist", value=sel.keys)
    }
})

```


```{r warnings=FALSE, message=FALSE}

cmpGetFoldChangeMatrix <- reactive({
    ## 
    ## Get full foldchange matrix from ngs object.
    ##
    ##
    ##
    cat("<module-intersect:cmpGetFoldChangeMatrix> reacted\n")

    fc0 = NULL
    qv0 = NULL
    ngs <- inputData()
    req(ngs)
    
    sel = names(ngs$gset.meta$meta)
    ##sel = input_cmp_comparisons()
    ##sel = intersect(sel, names(ngs$gset.meta$meta))
    ##if(length(sel)==0) return(NULL)

    dbg("<module-intersect:cmpGetFoldChangeMatrix> level=",isolate(input$cmp_level),"\n")
    
    if(input$cmp_level=="geneset") {
        gsetmethods <- c("gsva","camera","fgsea")
        gsetmethods <- selected_gsetmethods()
        if(length(gsetmethods)<1 || gsetmethods[1]=="") return(NULL)
        
        ##fc0 = sapply(ngs$gset.meta$meta[sel], function(x)
        ##    rowMeans(unclass(x$fc)[,gsetmethods,drop=FALSE]))
        fc0 = sapply(ngs$gset.meta$meta[sel], function(x) x$meta.fx)
        rownames(fc0) <- rownames(ngs$gset.meta$meta[[1]])
        qv0 = sapply(ngs$gset.meta$meta[sel], function(x)
            apply(unclass(x$q)[,gsetmethods,drop=FALSE],1,max))
        rownames(qv0) <- rownames(ngs$gset.meta$meta[[1]])

        gsets = rownames(fc0)
        if(input$cmp_filter == "<custom>") {
            gsets = strsplit( input$cmp_customlist, split="[, ;]")[[1]]
            if(length(gsets)>0) {
                gsets = intersect(rownames(ngs$gsetX), gsets)
            }
        } else if(input$cmp_filter != "<all>") {
            gsets = unique(unlist(COLLECTIONS[input$cmp_filter]))
        }
        gsets = intersect(gsets, rownames(fc0))
        fc1 = fc0[gsets,,drop=FALSE]
        qv1 = qv0[gsets,,drop=FALSE]
    } else {
        
        ## Gene
        ##
        gxmethods <- "trend.limma"
        gxmethods <- c("trend.limma","edger.qlf","deseq2.wald")
        gxmethods <- selected_gxmethods()  ## reactive object from EXPRESSION section
        
        dbg("<module-intersect:cmpGetFoldChangeMatrix> gxmethods=",gxmethods,"\n")
        
        if(length(gxmethods)<1 || gxmethods[1]=="") return(NULL)
        
        fc0 = sapply(ngs$gx.meta$meta[sel], function(x) x$meta.fx)
        rownames(fc0) <- rownames(ngs$gx.meta$meta[[1]])
        qv0 = sapply(ngs$gx.meta$meta[sel], function(x)
            apply(unclass(x$q)[,gxmethods,drop=FALSE],1,max))
        rownames(qv0) <- rownames(ngs$gx.meta$meta[[1]])
        dim(fc0)
        dim(qv0)

        dbg("<module-intersect:cmpGetFoldChangeMatrix> dim(fc0)=",dim(fc0),"\n")
        
        sel.probes = rownames(fc0) ## default to all probes
        if(input$cmp_filter == "<custom>") {
            genes = strsplit( input$cmp_customlist, split="[, ;]")[[1]]
            if(length(genes)>0) {
                sel.probes = filterProbes(ngs$genes, genes)
            }
        } else  if(input$cmp_filter != "<all>") {
            sel.probes = filterProbes(ngs$genes, GSETS[[input$cmp_filter]])
        }
        sel.probes = intersect(sel.probes, rownames(fc0))

        dbg("<module-intersect:cmpGetFoldChangeMatrix> head.sel.probes=",head(sel.probes),"\n")
        
        fc1 = fc0[sel.probes,,drop=FALSE]
        qv1 = qv0[sel.probes,,drop=FALSE]
    }    
    fc1 <- fc1[,!duplicated(colnames(fc1)),drop=FALSE]
    qv1 <- qv1[,!duplicated(colnames(qv1)),drop=FALSE]

    dbg("<module-intersect:cmpGetFoldChangeMatrix> done!\n")
    
    res = list(fc=fc1, qv=qv1, fc.full=fc0, qv.full=qv0)
    return(res) 
})

cmpGetCPMMatrix <- reactive({
    ## 
    ## Get full foldchange matrix from ngs object.
    ##
    ##
    ##
    dbg("<module-intersect:cmpGetCPMMatrix> reacted\n")

    ngs <- inputData()
    req(ngs)
    
    if(input$cmp_level=="geneset") {
        grp <- ngs$samples$group
        mx = tapply(colnames(ngs$gsetX), grp, function(k) rowMeans(ngs$gsetX[,k,drop=FALSE]))
        mx = do.call(cbind, mx)
        mx0 = mx
        gsets = rownames(mx)
        if(input$cmp_filter != "<all>") {
            gsets = unique(unlist(COLLECTIONS[input$cmp_filter]))
        }
        gsets = intersect(gsets, rownames(mx))
        mx = mx[gsets,,drop=FALSE]
    } else {
        grp <- ngs$samples$group
        mx = tapply(colnames(ngs$X), grp, function(k) rowMeans(ngs$X[,k,drop=FALSE]))
        mx = do.call(cbind, mx)
        mx0 = mx
        sel.probes = rownames(mx) ## default to all probes
        if(input$cmp_filter == "<custom>") {
            genes = strsplit( input$cmp_customlist, split="[, ;]")[[1]]
            if(length(genes)>0) {
                sel.probes = filterProbes(ngs$genes, genes)
            }
        } else if(input$cmp_filter %in% names(GSETS)) {
            sel.probes = filterProbes(ngs$genes, GSETS[[input$cmp_filter]])
        }
        sel.probes = intersect(sel.probes, rownames(mx))
        mx = mx[sel.probes,,drop=FALSE]
    }    
    mx <- mx[,!duplicated(colnames(mx)),drop=FALSE]
    res = list(mx=mx, mx.full=mx0)
    return(res) 
})


getSignificanceCalls <- reactive({
    ## Gets the matrix of significance calls.
    ##
    ngs <- inputData()
    contr.matrix <- ngs$model.parameters$contr.matrix
    sel = names(ngs$gset.meta$meta)
    sel = input_cmp_comparisons()
    sel = intersect(sel, names(ngs$gset.meta$meta))
    if(length(sel)==0) return(NULL)
    fdr=0.05;lfc=0.2
    fdr = as.numeric(input$cmp_fdr)
    lfc = as.numeric(input$cmp_lfc)
    
    res <- cmpGetFoldChangeMatrix()    
    fc <- res$fc[,sel,drop=FALSE]
    qv <- res$qv[,sel,drop=FALSE]

    dt = sign(fc) * (qv <= fdr & abs(fc) >= lfc)
    dt[is.na(dt)] = 0
    ## add label of venn intersection region
    dt.labels = LETTERS[1:ncol(dt)]
    venn.intersection = apply( 1*(dt!=0), 1, function(x)
        paste(dt.labels[which(x==1)],collapse=""))
    dt = data.frame( intersection=venn.intersection, dt, check.names=FALSE )
    return(dt)
})


getSignificantFoldChangeMatrix <- reactive({
    ####################################################################
    ## Filters FC matrix with significance and user-defined
    ## intersection region.
    ####################################################################
    dt <- getSignificanceCalls()
    req(dt, input$intersection)
    ## if(is.null(dt) || nrow(dt)==0) return(NULL)
    ##if(is.null(input$intersection)) return(NULL)

    isect = input$intersection
    dbg("getSignificantFoldChangeMatrix:: input$intersection = ",isect)
    dbg("getSignificantFoldChangeMatrix:: length.intersection = ",length(isect))
    dbg("getSignificantFoldChangeMatrix:: dim(dt) = ",dim(dt))

    fc0 = cmpGetFoldChangeMatrix()$fc  
    dbg("getSignificantFoldChangeMatrix:: dim(fc0) = ",dim(fc0))
    
    if( length(isect) == 0) {
        fc1 = fc0
    } else {
        ## only gene at least significant in one group
        jj = which(rowSums(dt[,2:ncol(dt),drop=FALSE]!=0)>0)
        if(length(jj)==0) return(NULL)
        dt = dt[jj,,drop=FALSE]

        ## check same sign 
        kk = 1 + match(c("B","C"),LETTERS[1:10])
        kk = 1 + match(isect,LETTERS[1:10])
        kk <- intersect(kk, 1:ncol(dt))
        
        dt1 = dt[,kk,drop=FALSE]    
        jj = which( rowMeans(sign(dt1)== +1)==1 |
                (rowMeans(sign(dt1)== -1)==1) )    
        dt = dt[jj,,drop=FALSE]    
        remove(dt1)
    
        ## only genes in the selected intersection
        intersection="ABC"
        intersection = paste0(input$intersection,collapse="")
        dt = dt[which(dt$intersection == intersection),,drop=FALSE]

    }
    
    ## filtered by family/collection
    fc1 = fc0[intersect(rownames(dt),rownames(fc0)),,drop=FALSE]
    if(nrow(dt)==1) {
        fc1 = matrix(fc1,nrow=1)
        rownames(fc1) <- rownames(dt)
        colnames(fc1) <- colnames(fc0)
    }
    
    ## only active/selected comparisons
    sel = colnames(dt)[-1]
    kk = match(sel,gsub(" \\(-\\)","",colnames(fc1)))
    fc1 = fc1[,kk,drop=FALSE]
    
    return(fc1)
})



```

Col {.tabset data-width=600}
----------------------------------------------------------------------------------------


### Pairs

```{r warnings=FALSE, message=FALSE}
##======================================================================
## Scatterplot matrix in plotly
##
## From: https://plot.ly/r/splom/
##======================================================================

cmp_scatterPlotMatrix.PLOT <- reactive({
    require(ggplot2)
    require(plotly)
    ##require(GGally)

    featuretype = "logFC"
    if(DEV.VERSION) {
        req(input$cmp_featuretype)
        featuretype <- input$cmp_featuretype
    }
    
    if(featuretype=="logCPM") {
        ##res = pgx.getMetaFoldChangeMatrix(ngs, what="meta")
        res = cmpGetCPMMatrix()
        ##if(is.null(res)) return(NULL)
        req(res)    
        fc0 = res$mx.full
        fc1 = res$mx
    } else if(featuretype=="logFC") {
        ##res = pgx.getMetaFoldChangeMatrix(ngs, what="meta")
        res = cmpGetFoldChangeMatrix()
        ##if(is.null(res)) return(NULL)
        req(res)    
        fc0 = res$fc.full
        fc1 = res$fc

        ## match with selection filter
        comp = head(colnames(fc0),3)
        comp = input_cmp_comparisons()
        ##comp = isolate(input$cmp_comparisons)  ## res is already reactive???
        kk = match(comp, colnames(fc0))
        if(length(kk)==0) return(NULL)
        if(length(kk)==1) kk = c(kk,kk)
        fc0 = fc0[,kk,drop=FALSE]
        ##rownames(fc0) = sub(".*:","",rownames(fc0))

    }
    dim(fc0)
        
    ##fc0 <- fc0[order(-rowSums(fc0**2)),]
    fc0 <- fc0[order(-apply(abs(fc0),1,max)),]
    fc0 <- fc0[order(-rowMeans(abs(fc0**2))),]
    
    ## selected genes
    sel.genes = grep("^CD",rownames(fc0),value=TRUE)
    sel.genes = head(rownames(fc0),100)  ## top100
    sel.genes = intersect(rownames(fc0),rownames(fc1))
    sel.genes = intersect(sel.genes, rownames(fc0))
    head(sel.genes)

    ## subsample for speed: take top1000 + 1000
    df <- data.frame(fc0)
    if(1) {
        ntop = 99999
        ##ntop <- input$cmp_splom_ntop        
        
        jj <- match(sel.genes, rownames(df))
        jj <- c(jj, 1:min(ntop,nrow(df)))
        if(nrow(df)>ntop) {
            nremain = setdiff(1:nrow(df),jj)
            jj = c(jj, sample(nremain,min(1000,length(nremain))))  ## add 1000 random
        }
        jj <- unique(jj)
        ##df <- data.frame(head(fc0,ntop))
        df <- data.frame(df[jj,])
    }
    dim(df)

    ## resort selection so that selected genes are drawn last to avoid
    ## covering them up.
    is.sel = (rownames(df) %in% sel.genes)
    if(input$cmp_splom_highlight) {
        df.color = c("#00000033","#0066FF")[1 + is.sel]
        df.color = c("#AAAAAA","#1e60BB")[1 + is.sel]
        df.color = c("#AAAAAA66","#1e60BBCC")[1 + is.sel]
    } else {
        df.color = rep("#00000088",nrow(df))
    }
    
    ## Labels for top 50 
    label.text = head(rownames(df)[which(is.sel)],50)
    label.text <- sub("","",label.text)  ## strip prefix??
    label.text <- shortstring(label.text,30)
    if(sum(is.na(label.text))) label.text[is.na(label.text)] <- ""
    
    ## reorder so the selected genes don't get overlapped
    jj <- order(is.sel)
    df <- df[jj,]
    df.color <- df.color[jj]
    sel1 <- match(label.text, rownames(df))  ## index for labeled

    ## Tooltip text for all 
    tt <- rownames(df)  ## strip prefix
    ## tt <- sub("","",tt)  ## strip prefix??
    if(input$cmp_level == "gene") {
        ngs <- inputData()
        g <- rownames(df)
        tt <- paste0("<b>",g,"</b> ", ngs$genes[g,"gene_title"])
    }
    tt <- gsub("_"," ",tt)
    tt <- sapply(tt,breakstring2,50,brk="<br>")

    ## plotly
    ##   
    axis = list( showline=TRUE,
                zeroline=TRUE,
                gridcolor='#dddf',
                ticklen=4
                )
    
    if(ncol(df)>=3) {
        dimensions = lapply(colnames(df), function(a) list(label=a, values = df[,a]))

        ## compute correlations 
        rho = cor(df)
        rho.text = paste("r=",as.vector(round(rho,digits=3)))
        n = ncol(df)

        ## annotation positions (approximated by eye...)
        xann = 1.02*(as.vector(mapply(rep,seq(0,0.98,1/n),n)) + 0.05*1/n)
        ##xann = as.vector(mapply(rep,seq(0,1,1/(n-1)),n))
        yann = 1.08*(as.vector(rep(seq(1,0.02,-1/n),n)) - 0.15*1/n - 0.04)
        ##yann = as.vector(rep(seq(1,0.0,-1/(n-1)),n))
                
        p <- plot_ly(df, source="splom", key=rownames(df) ) %>%
            add_trace(
                type = 'splom',
                dimensions = dimensions,
                text = tt,
                hovertemplate = paste0("<br>%{text}<br>x: %{x}<br>y: %{y}<extra></extra>"),
                marker = list(
                    color = df.color,
                    ## colorscale = pl_colorscale,
                    size = 5,
                    line = list(
                        width = 0.3,
                        ##color = 'rgb(230,230,230)'
                        color = 'rgb(0,0,0)'
                    )
                )
            ) %>%
            add_annotations(
                x = xann,
                y = yann,
                text = rho.text,
                font = list(size=11),
                xanchor = "left",
                align = 'left',
                showarrow = FALSE,
                xref = 'paper',
                yref = 'paper',
                borderpad = 3, 
                bordercolor = 'black',
                borderwidth = 0.6) %>%
            layout(
                ##title= 'Scatterplot matrix',
                hovermode='closest',
                dragmode= 'select',
                ##annotations = annot,
                ## plot_bgcolor='rgba(240,240,240, 0.95)',
                ## template = "plotly_dark",
                xaxis = c( domain=NULL, axis),
                yaxis = c( domain=NULL, axis),
                xaxis2=axis, xaxis3=axis, xaxis4=axis, xaxis5=axis, xaxis6=axis, xaxis7=axis,
                yaxis2=axis, yaxis3=axis, yaxis4=axis, yaxis5=axis, yaxis6=axis, yaxis7=axis
            )
        ## %>% style(diagonal = list(visible = F))

    } else {

        rho = cor(df[,1], df[,2])        
        annot.rho <- list(
            text = paste("r=",round(rho,4)),
            font = list(size=14),
            align = 'left',
            showarrow = FALSE,
            xref = 'paper',
            yref = 'paper',
            x = 0.03,
            y = 0.97,
            borderpad = 8, 
            bordercolor = 'black',
            borderwidth = 0.6)

        p <- plot_ly( data=df[,1:2], x = df[,1], y= df[,2],
                     type = 'scattergl', mode = 'markers',
                     source='splom', key = rownames(df),
                     ##type = 'scatter', mode = 'markers',
                     text = tt,
                     hovertemplate = paste0("<br>%{text}<br>x: %{x}<br>y: %{y}<extra></extra>"),
                     marker = list(
                         color = df.color,
                         size = 8,
                         line = list(
                             width = 0.3,
                             ##color = 'rgb(230,230,230)'
                             color = 'rgb(0,0,0)'
                         ))
                     ) %>%
            add_annotations(
                x = df[sel1,1],
                y = df[sel1,2],
                text = as.character(label.text),
                ##text = rep("mylabel",length(sel1)),
                ##xanchor = 'left',
                xanchor = 'center',
                yanchor = 'top',
                font = list(size=14),
                xref = "x",
                yref = "y",
                showarrow = FALSE,
                ax = 20,
                ay = -40
            ) %>%
            layout(
                ## title= 'Scatterplot',
                annotations = annot.rho,
                hovermode = 'closest',
                dragmode= 'select',
                ##plot_bgcolor='rgba(240,240,240, 0.95)',
                ## template = "plotly_dark",
                xaxis = c(title = paste(colnames(df)[1],"   (logFC)"), axis),
                yaxis = c(title = paste(colnames(df)[2],"   (logFC)"), axis)
            ) 
    }

    p <- p %>%
        event_register('plotly_selected')
    ## config(displayModeBar = FALSE)  ## disable buttons

    dbg("cmp_scatterPlotMatrix:: done\n")
    p    
})

cmp_scatterPlotMatrix.opts = tagList(
    tipify( checkboxInput("cmp_splom_highlight","Highlight genes",TRUE),
            "Enable highlighting genes on the plots. Users can highlight points by selecting them with the mouse, using the box selection or the lasso selection tool.")
    ##tipify( selectInput("cmp_splom_ntop","Number of top genes",c(100,500,1000,2500,999999),selected=1000),
    ##        "Number of top genes ")
)
cmp_scatterPlotMatrix_module <- plotModule(
    "cmp_scatterPlotMatrix", cmp_scatterPlotMatrix.PLOT, plotlib="plotly",
    title = "Scatterplot matrix (pairs)",
    info.text = "For the selected contrasts, the <strong>Pairs</strong> panel provides pairwise scatterplots for the differential expression profiles corresponding to multiple contrasts. The main purpose of this panel is to identify similarity or dissimilarity between selected contrasts. When K >= 3 contrasts are selected, the figure shows a KxK scatterplot matrix. When K <= 2, The Pairs panel provides an interactive pairwise scatterplots for the differential expression profiles of the two selected contrasts. The pairs plot is interactive and shows information of each gene with a mouse hover-over. Users can also select a number points by selecting points with the mouse, using the box selection or the lasso selection tool. Note that the selected genes will appear in input panel on the left sidebar as '<custom>' selection.
    ",
    options = cmp_scatterPlotMatrix.opts,
    ##  download.fmt = c("pdf","html"),  ## scatterGL does not work for PDF
    download.fmt = c("html"),
    pdf.width=8, pdf.height=8, res=95
)
output <- attachModule(output, cmp_scatterPlotMatrix_module)

fillCol(
    moduleWidget(cmp_scatterPlotMatrix_module, outputFunc="plotlyOutput")
)

```

> **Pairwise scatterplots for two or more differential expression profiles for multiple selected contrasts.** Similar profiles will show high correlation with points close to the diagonal. For *N>=3*, also volcano plots are shown on the diagonal with points in blue if significant with respect to the chosen `FDR` (significance) and `logFC` thresholds.



`r if(!DEV.VERSION) {"<!---------------------"}`

### Pairs (old)

```{r warnings=FALSE, message=FALSE}

cmp_mpairs.RENDER <- reactive({

    cat("<module-intersect:cmp_mpairs.RENDER> reacted\n")
    res = cmpGetFoldChangeMatrix()
    if(is.null(res)) return(NULL)
    fc0 = res$fc.full
    qv0 = res$qv.full
    
    cat("<module-intersect:cmp_mpairs.RENDER> dim(fc0)=",dim(fc0),"\n")
    cat("<module-intersect:cmp_mpairs.RENDER> dim(qv0)=",dim(qv0),"\n")

    ##-----------------------------------------------------
    ## match with selected contrasts 
    ##-----------------------------------------------------
    ##comp = head(colnames(fc0),2)
    comp = input_cmp_comparisons()
    if(length(comp)<2) return(NULL)
    kk = match(comp, colnames(fc0))
    fc0 = fc0[,kk,drop=FALSE]
    qv0 = qv0[,kk,drop=FALSE]
    rownames(fc0) = sub(".*:","",rownames(fc0))
    rownames(qv0) = sub(".*:","",rownames(qv0))
    fdr = as.numeric(input$cmp_fdr)
    lfc = as.numeric(input$cmp_lfc)
    if(is.null(fdr)) return(NULL)
    if(is.null(lfc)) return(NULL)
    
    ## set color
    is.sel <- (rownames(res$fc.full) %in% rownames(res$fc))
    if(nrow(res$fc.full) == nrow(res$fc)) {
        klr = rep("black",nrow(fc0))
        klr = rep("#1e60bb",nrow(fc0))
    } else {
        klr = c("grey80","#1e60bb")[1 + 1*is.sel]
        klr = c("#88888844","#1E60BBCC")[1 + 1*is.sel]
    }
        
    ##-----------------------------------------------------
    ## Start plotting
    ##-----------------------------------------------------
    ##plot(0,0)
    cex1 = 0.9*(1 + 1*is.sel)
    panel.function = function(i, j, ...) {
        z = order(cex1)
        x = fc0[z,j]
        y = fc0[z,i]
        plot(x, y, pch=19, cex=0.3*cex1[z], col=klr[z]);
        abline(h=0, v=0, lty=1, lwd=0.5)
        rho = cor.test(y,x,use="pairwise")
        abline(a=0, b=1, lty=2)
        legend("topleft", bty="n", cex=1.2, y.intersp=0.8, inset=c(-0.02,0),
               legend=c(paste("R=",round(rho$estimate,digits=3))))
    }

    diagpanel.function = function(i, fdr, lfc, ...) {

        x = fc0[,i]
        qval = qv0[,i]
        xlim = c(-1,1)*max(abs(x),na.rm=TRUE)
        ylim = c(0,12)
        ylim = c(0, max(12, 1.1*max(-log10(qval),na.rm=TRUE)))
        ##fdr = 0.05
        ##lfc = 0.1
        fc.genes = rownames(res$fc.full)
        sel.genes = rownames(res$fc)
        hi.col = "#1E60BB"
        hi.col = "#1E60BBCC"  ## some alpha

        ii = order(cex1)
        x = x[ii]
        qval = qval[ii]
        fc.genes = fc.genes[ii]
        cex1 = cex1[ii]
        
        comp1 = colnames(fc0)[i]
        ##par(mfrow=c(1,1), mar=c(3.2,4,2,2), mgp=c(2,0.8,0) )    
        gx.volcanoPlot.XY(
            x=x, pv=qval, gene=fc.genes,
            render="canvas", n=5000, nlab=0, 
            xlim=xlim, ylim=ylim, hi.col=hi.col,
            use.fdr=TRUE, p.sig=fdr, lfc=lfc,
            cex=0.6*cex1, lab.cex=1.0, cex.main=1.5,
            xlab="fold change (log2)",
            ylab="significance (log10q)",
            highlight=sel.genes)
        title(main=comp1, line=-1.5, cex=1.8)
    }

    fcmax = 1.05*max(abs(fc0))
    par(mfrow=c(ncol(fc0),ncol(fc0)), mar=c(1.5,1.5,0.5,0.5)*1.3)
    par( oma=c(1,1,1,1)*1)
    for(i in 1:ncol(fc0)) {
        for(j in 1:ncol(fc0)) {
            if(i==j) {
                diagpanel.function(i, fdr=fdr, lfc=lfc)
            } else {
                panel.function(i, j)
            }
        }
    }

})

cmp_scatter.RENDER <- reactive({

    require(plotly)

    cat("cmp_scatter.RENDER: 0\n")
        
    ##res = pgx.getMetaFoldChangeMatrix(ngs, what="meta")
    res = cmpGetFoldChangeMatrix()   
    if(is.null(res)) return(NULL)
    fc0 = res$fc.full
    fc1 = res$fc
    dim(fc0)

    cat("cmp_scatter.RENDER: 1\n")
    
    ## match with selection filter
    comp = head(colnames(fc0),3)
    comp = input_cmp_comparisons()
    ## if(length(comp)<2) return(NULL)
    kk = match(comp, colnames(fc0))
    fc0 = fc0[,kk,drop=FALSE]
    rownames(fc0) = sub(".*:","",rownames(fc0))

    ## order on max FC to make things easier
    ##fc0 <- fc0[order(-rowSums(fc0**2)),]
    fc0 <- fc0[order(-apply(abs(fc0),1,max)),]


    cat("cmp_scatter.RENDER: 2\n")
    
    ## selected genes
    sel.genes = grep("^CD",rownames(fc0),value=TRUE)
    sel.genes = head(rownames(fc0),100)  ## top100
    sel.genes = intersect(rownames(fc0),rownames(fc1))
    sel.genes = intersect(sel.genes, rownames(fc0))
    head(sel.genes)

    ## subsample for speed: take top1000 + 1000
    df <- data.frame(fc0)
    if(1) {
        ntop = 1000
        ## ntop = 99999
        ## ntop <- input$cmp_splom_ntop

        jj <- match(sel.genes, rownames(df))
        jj <- c(jj, 1:min(ntop,nrow(df)))
        if(nrow(df)>ntop) {
            nremain = setdiff(1:nrow(df),jj)
            jj = c(jj, sample(nremain,min(1000,length(nremain))))  ## add 1000 random
        }
        jj <- unique(jj)
        ##df <- data.frame(head(fc0,ntop))
        df <- data.frame(df[jj,])
    }
    dim(df)

    cat("cmp_scatter.RENDER: 3\n")
    
    ## resort selection so that selected genes are drawn last to avoid
    ## covering them up.
    is.sel = (rownames(df) %in% sel.genes)
    df.color = c("#00000033","#0066FF")[1 + is.sel]
    df.color = c("#AAAAAA","#0066FF")[1 + is.sel]
    df.color = c("#AAAAAA","#1e60BB")[1 + is.sel]
    df.color = c("#AAAAAA66","#1e60BBBB")[1 + is.sel]
    
    ## top 50 for labels
    label.text = rownames(df)[head(which(is.sel),50)]

    cat("cmp_scatter.RENDER: 4\n")
    
    ## reorder so the selected genes don't get overlapped
    jj <- order(is.sel)
    df <- df[jj,]
    df.color <- df.color[jj]
    sel1 <- match(label.text, rownames(df))  ## index for labeled
    
    ## plotly
    ##   
    axis = list(showline=TRUE,
                zeroline=TRUE,
                gridcolor='#dddf',
                ticklen=4)
    
    tt <- rownames(df)
    if(input$cmp_level == "gene") {
        ngs <- inputData()
        g <- rownames(df)
        tt <- paste0("<b>",g,"</b> ", ngs$genes[g,"gene_title"])
        tt <- sapply(tt,breakstring2,50,brk="<br>")
    }

    cat("cmp_scatter.RENDER: 5\n")
    
    rho = cor(df[,1], df[,2])
    annot.rho <- list(
        text=paste("r=",round(rho,4)),
        font=list(size=14),
        align='left',
        showarrow=FALSE,
        xref='paper',
        yref='paper',
        x=0.03,
        y=0.97,
        borderpad=8, 
        bordercolor='black',
        borderwidth=0.6)

    cat("cmp_scatter.RENDER: 6\n")
    
    p <- plot_ly( data=df[,1:2], x = df[,1], y= df[,2],
                 type = 'scattergl',  ## scatterGL is faster
                 mode = 'markers',
                 text = tt,
                 hovertemplate = paste0("<br>%{text}<br>x: %{x}<br>y: %{y}<extra></extra>"),
                 marker = list(
                     color = df.color,
                     size = 7,
                         line = list(
                             width = 0.2,
                             ##color = 'rgb(230,230,230)'
                             color = 'rgb(30,30,30)'
                         ))
                 ) %>%
        add_annotations(
            x = df[sel1,1],
            y = df[sel1,2],
            text = label.text,
            xanchor = 'left',
            font = list(size=14),
            xref = "x",
            yref = "y",
            showarrow = FALSE,
            ax = 20,
            ay = -40) %>%
        layout(
            ## title= 'Scatterplot',
            annotations = annot.rho,
            hovermode='closest',
            ## dragmode= 'select',
            ##plot_bgcolor='rgba(240,240,240, 0.95)',
            ## template = "plotly_dark",
            xaxis = c(title = paste(colnames(df)[1],"   (logFC)"), axis),
            yaxis = c(title = paste(colnames(df)[2],"   (logFC)"), axis)
        )
    p    
    
})


cmp_pairs.SWITCH <- reactive({
    req(input$cmp_comparisons)
    if(length(input_cmp_comparisons())<=1) return(NULL)
    p = NULL
    if(length(input_cmp_comparisons())==2) {
        p = plotlyOutput("cmp_scatter")
    } else {
        ##renderPlot(cmp_mpairs.RENDER())
        p = plotOutput("cmp_mpairs")
    }
    return(p)
})

##cmp_pairs.opts = tagList()
cmp_pairs_module <- plotModule(
    "cmp_pairs", func=cmp_pairs.SWITCH,
    title = "Scatterplot matrix (pairs)",
    ##plotlib="renderUI", ## renderFunc=NULL,
    plotlib="generic", renderFunc="renderUI",
    info.width = 400, download.fmt=c("pdf","html"),
    info.text = "The <strong>Pairs panel</strong> shows pairwise scatter plots of the differential expression profiles for <I>N>=2</I> selected contrasts. Differential expression profiles that are 'similar' will show high correlation with points scattered close to the diagonal. <br><br>Notice, that for <I>N=2</I> the plot is interactive and for <I>N>=3</I> static. For <I>N>=3</I>, volcano plots are also shown on the diagonal with points in blue if significant with respect to the chosen `FDR` (significance) and `logFC` thresholds.",
    ##options = cmp_pairs.opts,
    pdf.width=10, pdf.height=10, res=95
)
output <- attachModule(output, cmp_pairs_module)

## Special render functions for switching UI
##
output$cmp_scatter <- renderPlotly({
    p <- cmp_scatter.RENDER()
    ## export(p, file=PDFFILE)
    HTMLFILE = cmp_pairs_module$.tmpfile["html"]  ## from above!
    PDFFILE  = cmp_pairs_module$.tmpfile["pdf"]   ## from above!
    cat("<module_intersect::cmp> renderScatterD3 : PDFFILE=",PDFFILE,"\n")
    cat("<module_intersect::cmp> renderScatterD3 : HTMLFILE=",HTMLFILE,"\n")

    ## webGL so cannot use export
    p$width = 800
    p$height = 800
    htmlwidgets::saveWidget(p, HTMLFILE) 
    webshot(HTMLFILE,vwidth=800,vheight=800,PDFFILE)
    
    return(p)
})

output$cmp_mpairs  <- renderPlot({
    cmp_mpairs.RENDER()
    HTMLFILE = cmp_pairs_module$.tmpfile["html"]  ## from above!
    PDFFILE  = cmp_pairs_module$.tmpfile["pdf"]  ## from above!
    cat("<module_intersect::cmp_mpairs> renderScatterD3 : PDFFILE=",PDFFILE,"\n")
    ## if(file.exists(PDFFILE)) unlink(PDFFILE)
    ## dev.copy(pdf, file=PDFFILE, width=8, height=8)    
    dev.print(pdf, file=PDFFILE, width=9, height=9)
    write("<body>HTML error</body>",file=HTMLFILE)
}, res=90)

fillCol(
    moduleWidget(cmp_pairs_module, outputFunc="uiOutput")
)

## observe({
##     ngs <- inputData()
##     req(ngs)
##     var1 <- var2 <- names(ngs$gx.meta$meta)
##     other <- ""
##     ##other <- input$cmp_othersets
##     if(!is.null(other) && other!="") {
##         var2 <- colnames(PROFILES$FC)
##     }
##     updateSelectInput(session, "cmp_scattervar1",
##                       choices=var1, selected=var1[1] )
##     updateSelectInput(session, "cmp_scattervar2",
##                       choices=var2, selected=var2[2] )
## })

```

> **Pairwise scatterplots for two or more differential expression profiles for multiple selected contrasts.** Similar profiles will show high correlation with points close to the diagonal. For *N>=3*, also volcano plots are shown on the diagonal with points in blue if significant with respect to the chosen `FDR` (significance) and `logFC` thresholds.


`r if(!DEV.VERSION) {"--------------------->"}`


### Contrast heatmap 

```{r warnings=FALSE, message=FALSE}

cmp_ctheatmap.PLOT <- reactive({

    dbg("cmp_ctheatmap.RENDER:: reacted")
    
    ngs <- inputData()
    req(ngs)
    req(input$cmp_comparisons)

    dbg("cmp_ctheatmap.RENDER:: 1")
    
    res <- pgx.getMetaFoldChangeMatrix(ngs, what="meta")
    res = cmpGetFoldChangeMatrix()
    if(is.null(res)) return(NULL)
    fc0 = res$fc
    qv0 = res$qv

    dbg("cmp_ctheatmap.RENDER:: 2")

    ntop <- input$cmp_ctheatmap_ntop
    if(ntop=="all") ntop <- 999999
    ntop <- as.integer(ntop)
    
    dbg("cmp_ctheatmap.RENDER:: 3")

    allfc <- input$cmp_ctheatmap_allfc
    if(!allfc) {
        comp = input_cmp_comparisons()
        if(length(comp)<2) return(NULL)
        kk = match(comp, colnames(fc0))
        fc0 <- fc0[,kk,drop=FALSE]
    }

    dbg("cmp_ctheatmap.RENDER:: 4")
    
    ##R.full <- cor(fc0[,], use="pairwise", method="spearman")
    R.full <- cor(apply(fc0,2,rank), use="pairwise")
    jj <- head(order(-rowMeans(fc0**2)),ntop)
    ##R <- cor(fc0[jj,], use="pairwise", method="spearman")
    R <- cor(apply(fc0[jj,],2,rank), use="pairwise")
    R <- round(R,digits=2)
    
    notecex=0.001
    notecex=1.1; cex=1.3
    if( nrow(R) > 8)  {notecex=0.95; cex=1.2}
    if( nrow(R) > 20) {notecex=0.75; cex=1.05}
    if( nrow(R) > 50) {notecex=0.65; cex=0.9}
    if( nrow(R) > 80) {notecex=0.0001; cex=0.6}

    mar1 <- c(16,18)*1.2
    if(nrow(R) <= 8) { mar1=c(16,18)*2 }
    if(nrow(R) > 30) { mar1=c(16,18)*0.9 }
    if(nrow(R) > 80) { mar1=c(16,18)*0.6 }    
    
    col <- BLUERED(16)
    col <- colorpanel(64,"royalblue3","grey90","indianred3")
    ##col <- tail(BLUERED(16),8)
    if(min(R,na.rm=TRUE)>=0) col <- tail(col,32)
    if(max(R,na.rm=TRUE)<=0) col <- head(col,32)

    dbg("cmp_ctheatmap.RENDER:: 5")
    
    gx.heatmap(R, values=NULL, col=col,
               scale="none", mar=mar1, cexRow=cex, cexCol=cex,
               cellnote=R, notecex=notecex, notecol="black",
               dist.method="euclidean", col.dist.method="euclidean",
               keysize=0.35, key=FALSE, zlim=c(-1,1) )

    dbg("cmp_ctheatmap.RENDER:: done")

    ##return(R)
})

cmp_ctheatmap.PLOTLY <- reactive({

    dbg("cmp_ctheatmap.PLOTLY:: reacted")

    ## install.packages("heatmaply")
    require(heatmaply)
    
    ngs <- inputData()
    req(ngs)
    ##req(input$cmp_comparisons)

    dbg("cmp_ctheatmap.PLOTLY:: 1")
    
    ##res <- pgx.getMetaFoldChangeMatrix(ngs, what="meta")
    res = cmpGetFoldChangeMatrix()
    if(is.null(res)) return(NULL)
    fc0 = res$fc
    qv0 = res$qv

    dbg("cmp_ctheatmap.PLOTLY:: 2")

    ntop=2000
    ntop <- input$cmp_ctheatmap_ntop
    if(ntop=="all") ntop <- 999999
    ntop <- as.integer(ntop)
    
    dbg("cmp_ctheatmap.PLOTLY:: 3")

    allfc <- input$cmp_ctheatmap_allfc
    if(!allfc) {
        comp = input_cmp_comparisons()
        if(length(comp)<2) return(NULL)
        kk = match(comp, colnames(fc0))
        fc0 <- fc0[,kk,drop=FALSE]
    }

    dbg("cmp_ctheatmap.PLOTLY:: 4")
    
    ##R.full <- cor(fc0[,], use="pairwise", method="spearman")
    R.full <- cor(apply(fc0,2,rank), use="pairwise")
    jj <- head(order(-rowMeans(fc0**2)),ntop)
    ##R <- cor(fc0[jj,], use="pairwise", method="spearman")
    R <- cor(apply(fc0[jj,],2,rank), use="pairwise")
    R <- round(R,digits=2)
        
    col <- BLUERED(16)
    col <- colorpanel(64,"royalblue3","grey90","indianred3")
    ##col <- tail(BLUERED(16),8)
    if(min(R,na.rm=TRUE)>=0) col <- tail(col,32)
    if(max(R,na.rm=TRUE)<=0) col <- head(col,32)

    dbg("cmp_ctheatmap.PLOTLY:: 5")

    bluered.pal <- colorRampPalette(colors = c("royalblue3","grey90","indianred3"))
    cellnote <- NULL
    if(input$cmp_ctheatmap_showrho) cellnote <- R

    plt <- heatmaply(
        R, margins = c(250, 200, NA, 0),
        ## k_col = 5, k_row = 5,
        cellnote = cellnote, cellnote_size = 11,
        cellnote_textposition = "middle center", 
        colors = bluered.pal,
        limits = c(-1,1))        

    dbg("cmp_ctheatmap.PLOTLY:: done")    
    plt
})


cmp_ctheatmap.opts = tagList(
    tipify( checkboxInput('cmp_ctheatmap_showrho', "show correlation values", FALSE),
           "Show correlation values in cells."),
    tipify( checkboxInput('cmp_ctheatmap_allfc', "show all contrasts", TRUE),
           "Show all contrasts or just the selected ones."),
    ##tipify( checkboxInput('cmp_ctheatmap_fixed', "fix heatmap", FALSE),
    ##       "Fix heatmap layout when changing number of top genes"),
    tipify( radioButtons('cmp_ctheatmap_ntop', "number of top genes",
                         c("100","1000","all"),
                         selected="1000", inline=TRUE),
           "Number of top genes to compute correlation values.") 
)

cmp_ctheatmap_info = "<strong>Constrast heatmap.</strong> Similarity of the contrasts visualized as a clustered heatmap. Contrasts that are similar will be clustered close together. The numeric value in the cells correspond to the Pearson correlation coefficient between contrast signatures. Red corresponds to positive correlation and blue to negative correlation."

cmp_ctheatmap_module <- plotModule(
    "cmp_ctheatmap", 
    ##cmp_ctheatmap.PLOT, plotlib="base",
    cmp_ctheatmap.PLOTLY, plotlib="plotly",
    ##cmp_ctheatmap.PLOTLY, plotlib="generic", renderFunc="renderPlotly",
    info.text = cmp_ctheatmap_info,
    options = cmp_ctheatmap.opts,
    download.fmt = c("pdf","html"),
    pdf.width=11, pdf.height=10, res=85
)
output <- attachModule(output, cmp_ctheatmap_module)

fillCol(
    ##moduleWidget(cmp_ctheatmap_module)
    moduleWidget(cmp_ctheatmap_module, outputFunc="plotlyOutput")
)

```

> **Constrast heatmap.** Similarity of the contrasts visualized as a clustered heatmap. The numeric value in the cells correspond to the Pearson correlation coefficient. Red corresponds to positive correlation and blue to negative correlation.



### Connectivity map 
    
```{r message=FALSE, warning=FALSE, fig.width=4}

##================================================================================
## CONNECTIVITY MAP
##================================================================================

##ntop=1000;nb=100
pgx.getExternalSignaturesFC <- function(fc, nb, sets="<all>", ntop=-1)
{
    ## 
    ## requires: PROFILES (from global env)
    ##
    if(0) {
        fc <- cbind(ngs$gx.meta$meta[[1]]$meta.fx)
        rownames(fc) <- rownames(ngs$gx.meta$meta[[1]])
    }
    if(is.null(fc)) return(NULL)
    
    fc0 <- fc
    rownames(fc0) <- toupper(sub(".*:","",rownames(fc0)))
    allFC <- PROFILES$FC
    allFC <- allFC[match(rownames(fc0), rownames(allFC)),]
    rownames(allFC) <- rownames(fc0)
    dim(allFC)
    
    ##sets=c("<all>");ntop=100
    extFC <- allFC
    if(sets[1]!="<all>") {
        db <- gsub("\\].*","]",colnames(extFC))
        table(db)
        kk <- which(db %in% sets)
        extFC <- extFC[,kk,drop=FALSE]
    }
    
    ## get top SD fold-changing genes
    if(ntop > 0) {
        sd0=sd1=1
        sd0 <- Matrix::rowMeans(extFC**2, na.rm=TRUE)
        sd1 <- Matrix::rowMeans(fc0**2, na.rm=TRUE)
        sd0[which(is.na(sd0))] <- 0.0
        sd1[which(is.na(sd1))] <- 0.0
        sd2 <- sd0 * sd1
        table(sd2!=0)
        jj <- order(-abs(sd2))
        jj <- head(jj[which(sd2[jj]!=0)],ntop)
        fc0 <- fc0[jj,,drop=FALSE]
        extFC <- extFC[jj,,drop=FALSE]
    }
    dim(extFC)
    dim(fc0)
    
    ## determine most similar experiment by fold-change correlation
    suppressWarnings(
        xrho <- cor( apply(fc0,2,rank,na.last="keep"),
                    apply(extFC,2,rank,na.last="keep"),
                    use="pairwise")
    )
    dim(xrho)
    
    nn <-  ceiling( nb / nrow(xrho) )
    ii <- as.vector(apply(xrho,1,function(x) head(order(-x),nn)))
    bb <- colnames(extFC)[sort(unique(ii))]
    length(bb)
    
    ## add to original FC/Q
    gg <- toupper(sub(".*:","",rownames(fc0)))
    jj <- match(gg, rownames(allFC))
    fcx <- as.matrix(allFC)[jj,bb,drop=FALSE]
    return(fcx)
}

getNeighbourhoodFoldChangeMatrix <- reactive({

    ngs <- inputData()
    res = pgx.getMetaFoldChangeMatrix(ngs, what="trend.limma")
    ##fc0 = sapply(ngs$gx.meta$meta, function(x) unclass(x$fc)[,"trend.limma"])
    fc0 <- res$fc
    rownames(fc0) <- toupper(gsub(".*:","",rownames(fc0)))

    others <- input$cmp_cmapsets
    others <- setdiff(others,c("<this dataset>",""))
    if("<all>" %in% others) others <- "<all>"

    cat("getNeighbourhoodFoldChangeMatrix:: others=",others,"\n")
    cat("getNeighbourhoodFoldChangeMatrix:: len.others=",length(others),"\n")
    
    if(TRUE && length(others)>0) {
        fc1 <- res$fc[,,drop=FALSE]
        ntop <- 200
        if(!is.null(input$cmp_topgenes)) ntop <- as.integer(input$cmp_topgenes)
        nnb = 500
        if(!is.null(input$cmp_neighbours)) nnb <- as.integer(input$cmp_neighbours)
        fcx <- pgx.getExternalSignaturesFC(fc1, nb=nnb, ntop=ntop, sets=others)
        gg <- intersect(rownames(fc0),rownames(fcx))
        length(gg)
        fc0 <- cbind( fc0[gg,], fcx[gg,] )        
    }
    if(NCOL(fc0)<2) return(NULL)

    ## normalize???
    fc0 <- scale(fc0, center=TRUE)

    ## set missing values are set to nearly zero
    fc0[is.na(fc0)] <- 1e-4 * rnorm(sum(is.na(fc0)))

    ngenes = 200
    ngenes = as.integer(input$cmp_topgenes)
    fc0 = head(fc0[order(-apply(fc0,1,sd,na.rm=TRUE)),,drop=FALSE],ngenes)
    
    ## --------- compute correlation distance 
    fc0 <- apply(fc0,2,rank,na.last="keep")  ## rank correlation??
    rho <- cor(fc0, use="pairwise")

    res <- list(fc=fc0, rho=rho)
    return(res)
})

cmp_connectivitymap.RENDER <- reactive({

    ##======================================================================
    ## Fold-change t-SNE
    ##======================================================================
    ngs <- inputData()
    req(ngs)
    
    ## get the fold-changes of selected comparison and neighbourhood
    res <- getNeighbourhoodFoldChangeMatrix()
    fc  <- res$fc
    fc[is.na(fc)] <- 0
    
    add.negative=FALSE
    ##add.negative <- ("add negative" %in% input$fc_cmap_options)
    if(add.negative) {
        comparisons=1
        comparisons = input_cmp_comparisons()
        if(is.null(comparisons)) return(NULL)
        ## add NEGATIVE phenotype node
        kk <- which(colnames(fc) %in% comparisons)
        neg.fc <- -fc[,kk]
        colnames(neg.fc) <- paste0("NEG:",colnames(neg.fc))
        fc <- cbind(fc, neg.fc)
        ##k <- which(rownames(pos)==comparison)
        ##rho <- cor(fc[,], fc[,k])[,1]  ## correlation to QUERY node
    }
    
    ## -------- compute t-SNE
    if(input$cmp_cmapclust=="tsne") {
        ##require(Rtsne.multicore)
        require(Rtsne)
        perplexity <- pmax(min(ncol(fc)/5,30),2)
        perplexity

        sfc <- scale(fc)
        if(ncol(sfc)<=6) sfc <- cbind(sfc,sfc,sfc,sfc)
        sfc <- sfc + 1e-2*matrix(rnorm(length(sfc)),nrow(sfc),ncol(sfc))
        pos <- Rtsne( t(sfc), is_distance=FALSE, check_duplicates=FALSE,
                     perplexity=perplexity, num_threads=4)$Y
        pos <- pos[1:ncol(fc),]
        xlab="tSNE-x"
        ylab="tSNE-y"
    } else {
        require(irlba)
        sfc <- scale(fc)
        if(ncol(sfc)<=3) sfc <- cbind(sfc,sfc,sfc)
        pos <- irlba(sfc, nv=2)$v
        pos <- pos[1:ncol(fc),]
        xlab="PC1"
        ylab="PC2"
    }
    rownames(pos) = colnames(fc)
    dim(pos)
    pos = scale(pos) ## scale 
   
    ## prepare plotting
    lab <- rownames(pos)
    ##if(input$fc_cmapshownames) lab <- rownames(pos)
    ##if(!("show names" %in% input$fc_cmap_options)) lab <- rep("",nrow(pos))
    jj <- grep("\\]",rownames(pos))
    grp <- rep("[this_data]",nrow(pos))
    grp[jj] <- sub("].*","]",rownames(pos)[jj])
    table(grp)
    ##rr <- abs(rho)**2
    ##sign<- c("-","+")[1 + 1*(sign(rho)>0)]
    ##sign[k] <- "*"
    ##tt <- paste0(rownames(pos)," (",sign,")")
    tt <- rownames(pos)
    stype <- (1 + 1*(grp=="[this_data]"))
    labels_size <- ifelse( nrow(pos) < 20, 20, 15)
    labels_size <- ifelse( nrow(pos) > 400, 12, labels_size)
        
    require(scatterD3)
    scatterD3( pos[,1], pos[,2], transitions=TRUE,
              xlab=xlab, ylab=ylab,
              legend_width=0, tooltip_text=tt,
              lab=lab, labels_size=labels_size, point_opacity = 0.8,
              size_var=stype, size_range = c(50,200), size_lab="type",
              ## size_var=rr, size_range = c(20,200)*2.2,
              ## size_lab="connectivity score",
              ## symbol_var=sign, symbol_lab="type",
              col_var=grp, col_lab="data set")

})

cmp_connectivitymap.opts = tagList(
    tipify( selectInput('cmp_cmapsets',"Dataset:", choices=NULL, multiple=TRUE),
           "Select datasets to compare with external contrast profiles."),
    tipify(radioButtons('cmp_cmapclust',"Layout:",c("tsne","pca"),inline=TRUE),
           "Choose the plot layout: t-SNE or PCA"),
    tipify(radioButtons('cmp_topgenes','Top genes:',c(50,200,1000),inline=TRUE,selected=200),
           "Specify the number of top genes for computations."),
    tipify(radioButtons('cmp_neighbours','Neighbours:',c(100,500,2000),inline=TRUE,selected=500),
           "Set the number of neighbours two show in the t-SNE or PCA.")    
    ##checkboxGroupInput('fc_cmap_options',NULL,c('show names','add negative'),
    ##                   selected=c('show names'),inline=TRUE),
)

cmp_connectivitymap.module <- plotModule(
    "cmp_connectivitymap", cmp_connectivitymap.RENDER, plotlib="scatterD3",
    info.text = "The Connectivity Map (CMap) shows the similarity of the contrasts profiles as a t-SNE plot. Contrasts that are similar will be clustered close together, contrasts that are different are placed farther away. For comparison with external signatures, users can select multiple public datasets in the settings under 'Dataset'.",
    options = cmp_connectivitymap.opts,
    pdf.width=8, pdf.height=8, res=90
)
output$cmp_connectivitymap     <- cmp_connectivitymap.module$render
output$cmp_connectivitymap_pdf <- cmp_connectivitymap.module$pdf
observe({
    cmapsets <- c(sort(unique(gsub("\\].*","]",colnames(PROFILES$FC)))))
    cmapsets <- c("<this dataset>",cmapsets,"<all>")
    updateSelectInput(session, "cmp_cmapsets", choices=cmapsets, selected="<this dataset>")
})

moduleWidget(cmp_connectivitymap.module, outputFunc="scatterD3Output")

```

> **Connectivity Map (CMap).** The CMap shows the similarity of the contrasts as a t-SNE plot. Contrasts that are similar will be clustered close together, contrasts that are different are placed farther away. Note that the order of the groups in a comparison greatly influences calculation of pairwise distances.



Col  {.tabset data-width=375}
----------------------------------------------------------------------------------------

### Venn diagram

```{r warnings=FALSE, message=FALSE}

cmp_venndiagram.RENDER <- reactive({
    
    dt = getSignificanceCalls()
    if(is.null(dt) || nrow(dt)==0) return(NULL)
    
    dt1 = dt[,2:ncol(dt),drop=FALSE]
    label = LETTERS[1:ncol(dt1)]
    colnames(dt1) = label
    if(ncol(dt1)==1) {
        dt1 <- cbind(dt1, dt1)
    }
    include = "both"
    if(input$cmp_include=="up/down") {
        include = c("up","down")
    }    
    dt1 = dt1[,1:min(5,ncol(dt1))]
    
    par(mfrow=c(1,1), mar=c(1,1,3,1)*0, bty="n")
    par(oma=c(0.0,0,0,0))
    limma::vennDiagram(
               dt1,  main="", cex.main=1.2, cex=1.2, mar=c(0,0,2,0),
               include=include, bty="n", fg=grey(0.7),
               circle.col=c("turquoise", "salmon","lightgreen","orange") )
    tt = paste(label,"=",colnames(dt)[-1])
    legend("topleft", legend=tt, bty='n', cex=1.0, y.intersp=0.95,
           inset=c(0.04,-0.01), xpd=TRUE)

})

##output$intersection_table <- DT::renderDataTable({
cmp_venntable.RENDER <- reactive({
    ngs <- inputData()
    req(ngs)
    
    ## get foldchanges
    fc0 = getSignificantFoldChangeMatrix()  ## isolate??
    if(is.null(fc0) || nrow(fc0)==0) return(NULL)
    fc0 <- fc0[order(-rowMeans(fc0)),,drop=FALSE]
    
    fc0 = round(fc0, digits=3)
    colnames(fc0) = paste0("fc.",LETTERS[1:ncol(fc0)])
    ##fc0 = data.frame(fc0)
    
    ## add gene name/title
    if(input$cmp_level == "gene") {
        gene = as.character(ngs$genes[rownames(fc0),"gene_name"])
        gene.tt = substring( GENE.TITLE[gene],1,50)
        gene.tt = as.character(gene.tt)
        ##fc0 = data.frame( name=name, title=gene.tt, fc0)
        fc0 = data.frame( name=gene, fc0, check.names=FALSE)
    } else {
        name = substring(rownames(fc0),1,50)
        name[is.na(name)] = "NA"
        fc0 = data.frame(name=name, fc0, check.names=FALSE)
    }

    D = data.frame( fc0, check.names=FALSE)
    ##dt <- dt[rownames(fc0),]    
    ##D <- cbind(intersection=dt$intersection, D)
    DT::datatable(D, class='compact cell-border stripe',
                  rownames=FALSE,
                  extensions = c('Buttons','Scroller'), selection='none',
                  options=list(
                      ## pageLength = 40, ##lengthMenu = c(20, 30, 40, 60, 100, 250),
                      scrollX = TRUE, ## scrollY = TRUE,
                      scrollY = 230, scroller=TRUE, deferRender=TRUE,
                      dom = 'Blfrtip',                      
                      buttons = c('copy','csv')
                  )  ## end of options.list 
                  ) %>%
        DT::formatStyle(0, target='row', fontSize='11px', lineHeight='70%')  
})

##-------------------------------------------------------
##---------- MODULES ------------------------------------
##-------------------------------------------------------

FDR.VALUES2 <- c(1e-9,1e-6,1e-3,0.01,0.05,0.1,0.2,0.5,1)
cmp_venndiagram.opts = tagList(
    ##    checkboxGroupInput('intersection',NULL, choices=c("A","B","C"), inline=TRUE )    
    fillRow(
        flex=c(1,1), ## height=80,       
        tipify( selectInput("cmp_fdr","FDR", choices=FDR.VALUES2, selected=0.05),
               "Threshold for false discovery rate"),
        tipify( selectInput("cmp_lfc","logFC threshold", choices=c(0,0.2,0.5,1,2,5),
                            selected=1),
               "Threshold for fold-change (log2 scale)")
    ),
    br(),br(),br(),br(),
    radioButtons('cmp_include','Counting mode:', choices=c("up/down","both"), inline=TRUE)
)

cmp_venndiagram_module <- plotModule(
    "cmp_venndiagram", cmp_venndiagram.RENDER,
    title = "Venn diagram", label="a",
    info.text = "The Venn diagram visualizes the number of intersecting genes between the profiles. The list of intersecting genes with further details is also reported in an interactive table below, where users can select and remove a particular contrasts from the intersection analysis.",
    options = cmp_venndiagram.opts,
    pdf.width=8, pdf.height=8, res=72
)
output <- attachModule(output, cmp_venndiagram_module)

cmp_venntable_module <- tableModule(
    id="cmp_venntable", func=cmp_venntable.RENDER,
    title = "Intersecting genes", label="b",
    info.text = "Intersecting genes", 
    info.width="500px"
)
output <- attachModule(output, cmp_venntable_module)

##-------------------------------------------------------
##---------- UI LAYOUT ----------------------------------
##-------------------------------------------------------

fillCol(
    height = "100%",
    flex = c(1, NA, NA, 0.66),
    moduleWidget(cmp_venndiagram_module),
    
    cmp_venntable_module$buttons,
    inputPanel(checkboxGroupInput('intersection',"Intersect regions:",
                                  choices=c("A","B","C"), inline=TRUE )),
    dataTableOutput("cmp_venntable")
)

observeEvent(input$cmp_comparisons, {
    cmp <- input$cmp_comparisons
    if(is.null(cmp)) return(NULL)
    dt.labels = LETTERS[1:length(cmp)]
    updateCheckboxGroupInput(session, "intersection", choices=dt.labels,
                             selected=dt.labels, inline=TRUE )    
})

```

> **Venn diagram and intersection table.** **(a)** Venn diagram showing the number of overlapping (significant) genes for multiple contrasts. **(b)** Table reporting genes in the selected overlap region with their fold-changes.


### Meta-volcano

```{r warnings=FALSE, message=FALSE}

cmp_volcano1.RENDER <- reactive({
    
    ngs <- inputData()
    req(ngs)
    
    sel = names(ngs$gx.meta$meta)
    sel = input_cmp_comparisons()
    if(is.null(sel) || sel[1]=="") return(NULL)
    sel = intersect(sel, names(ngs$gx.meta$meta))
    
    ## GENE LEVEL
    gxmethods <- "trend.limma"
    gxmethods <- c("trend.limma","edger.qlf","deseq2.wald")
    gxmethods <- selected_gxmethods()
    if(length(gxmethods)<1 || gxmethods[1]=="") return(NULL)
    
    ##fc0 = sapply(ngs$gx.meta$meta[sel], function(x) unclass(x$fc)[,"trend.limma"])
    ##qv0 = sapply(ngs$gx.meta$meta[sel], function(x) unclass(x$q)[,"trend.limma"])
    fc0 = sapply(ngs$gx.meta$meta[sel], function(x)
        rowMeans(unclass(x$fc)[,gxmethods,drop=FALSE]))
    qv0 = sapply(ngs$gx.meta$meta[sel], function(x)
        apply(unclass(x$q)[,gxmethods,drop=FALSE],1,max))        
        
    if(input$cmp_level=="gene") {
        sel.probes = rownames(fc0) 
        ##sel.probes = filterFamily(ngs$genes, input$cmp_filter, ngs=ngs)
        if(input$cmp_filter %in% names(GSETS)) {
            sel.probes = filterProbes(ngs$genes, GSETS[[input$cmp_filter]])
        } else if(input$cmp_filter == "<custom>") {
            genes = strsplit( input$cmp_customlist, split="[, ;]")[[1]]
            if(length(genes)>0) {
                sel.probes = filterProbes(ngs$genes, genes)
            }
        }
        sel.probes = intersect(sel.probes, rownames(fc0))
        fc0 = fc0[sel.probes,,drop=FALSE]
        qv0 = qv0[sel.probes,,drop=FALSE]
    }
    rownames(fc0) = sub(".*:","",rownames(fc0))
    rownames(qv0) = sub(".*:","",rownames(qv0))
    fdr=0.001;lfc=2
    fdr = as.numeric(input$cmp_fdr)
    lfc = as.numeric(input$cmp_lfc)
    if(is.null(fdr)) return(NULL)
    if(is.null(lfc)) return(NULL)

    dbg("dim(fc0)=",dim(fc0))
    
    ## check signs, thresholds
    sign.fc <- sign(rowMeans(fc0))
    min.fc <- apply(abs(fc0),1,min) * sign.fc
    same.sign <- (rowMeans(sign(fc0)==sign.fc)==1)
    max.qv <- apply(qv0,1,max)
    fc.genes <- rownames(fc0)
    in.common <- which( abs(min.fc) >= lfc & max.qv <= fdr & same.sign) 
    sel.genes <- fc.genes[in.common]
    ##max.qv[which(!same.sign)] <- 1
    
    dbg("min.min.fc=",min(min.fc))
    dbg("max.min.fc=",max(min.fc))
    dbg("min.max.qv=",min(max.qv))
    dbg("max.max.qv=",max(max.qv))

    par(mfrow=c(1,1), mar=c(5,5,1,3), mgp=c(2.4,1,0) )
    gx.volcanoPlot.XY( x= min.fc, pv= max.qv, gene=fc.genes,
                      render="canvas", n=5000, nlab=25, 
                      ##xlim=xlim, ylim=ylim, ## hi.col="#222222",
                      use.fdr=TRUE, p.sig=fdr, lfc=lfc,
                      cex=0.5, lab.cex=1.2, cex.main=1.5,
                      xlab="meta fold change (log2)",
                      ylab="meta significance (log10q)",
                      highlight=sel.genes)
    ##title(main="common genes", line=1, cex=1.4)
    
})

cmp_fcbarplot.RENDER <- reactive({

    ngs <- inputData()
    sel = names(ngs$gx.meta$meta)
    sel = input_cmp_comparisons()
    if(sel[1]=="") return(NULL)
    sel = intersect(sel, names(ngs$gx.meta$meta))

        
    ##fc = sapply(ngs$gx.meta$meta[1:3], function(x) x$meta.fx)
    ##rownames(fc) <- rownames(ngs$gx.meta$meta[[1]])    
    fc = getSignificantFoldChangeMatrix()  ## isolate??
    fc <- fc[,sel,drop=FALSE]
    if(input$cmp_fcbarplot_abs) {
        fc <- abs(fc)  
    }
    fc <- fc[order(-rowMeans(fc**2)),,drop=FALSE]
    fc <- head(fc,30)
    fc <- fc[order(-rowMeans(fc)),,drop=FALSE]
    
    ## add some empty rows (keeps barplot bar-widths equal)
    fc.na <- matrix(0,nrow=100,ncol=ncol(fc))
    fc <- rbind(fc,fc.na)
    fc.top <- head(fc,30)
    
    par(mar=c(8,4,2,2))
    par(mfrow=c(1,1), mar=c(8,5,3,3), mgp=c(2.4,1,0) )
    fc.sum <- rowSums(fc.top,na.rm=TRUE)
    ylim <- c(min(c(0,fc.sum)), max(0,1.3*max(fc.sum)))
    barplot(t(fc.top), las=3, cex.names=0.9,
            ylim=ylim, ylab="cumulative logFC")
    legend("topright", legend=colnames(fc.top),
           fill=c("grey20","grey50","grey80"),
           cex=0.9, y.intersp=0.8)
    
})

cmp_volcano2.RENDER <- reactive({

    ngs <- inputData()
    sel = names(ngs$gx.meta$meta)
    sel = input_cmp_comparisons()
    if(sel[1]=="") return(NULL)
    sel = intersect(sel, names(ngs$gx.meta$meta))
    
    ## GENESET LEVEL
    fc0 = sapply(ngs$gset.meta$meta[sel], function(x) unclass(x$fc)[,"gsva"])
    qv0 = sapply(ngs$gset.meta$meta[sel], function(x) unclass(x$q)[,"gsva"])        
    if(input$cmp_level == "geneset") {
        gsets = unique(unlist(COLLECTIONS[input$cmp_filter]))
        gsets = intersect(gsets, rownames(fc0))
        fc0 = fc0[gsets,,drop=FALSE]
        qv0 = qv0[gsets,,drop=FALSE]
    }
    
    rownames(fc0) = sub(".*:","",rownames(fc0))
    rownames(qv0) = sub(".*:","",rownames(qv0))
    fdr=0.001;lfc=2
    fdr = as.numeric(input$cmp_fdr)
    lfc = as.numeric(input$cmp_lfc)
    if(is.null(fdr)) return(NULL)
    if(is.null(lfc)) return(NULL)

    ## check signs, thresholds
    sign.fc <- sign(rowMeans(fc0))
    min.fc <- apply(abs(fc0),1,min) * sign.fc
    same.sign <- (rowMeans(sign(fc0)==sign.fc)==1)
    max.qv <- apply(qv0,1,max)
    fc.genes <- rownames(fc0)
    in.common <- which( abs(min.fc) >= lfc & max.qv <= fdr & same.sign) 
    sel.genes <- fc.genes[in.common]
    ##max.qv[which(!same.sign)] <- 1
    
    par(mfrow=c(1,1), mar=c(4,5,1,3), mgp=c(2.4,1,0) )
    gx.volcanoPlot.XY( x= min.fc, pv= max.qv, gene=fc.genes,
                      render="canvas", n=5000, nlab=25, 
                      ##xlim=xlim, ylim=ylim, ## hi.col="#222222",
                      use.fdr=TRUE, p.sig=fdr, lfc=lfc,
                      cex=0.5, lab.cex=1.2, cex.main=1.5,
                      xlab="meta fold change (log2)",
                      ylab="meta significance (log10q)",
                      highlight=sel.genes)
    ##title(main="common gene sets", line=1, cex=1.4)

    
})

##------------------------------------------------------------
##------------------------------------------------------------
##------------------------------------------------------------

cmp_volcano1.opts = tagList(
##    radioButtons('cmp_include','Counting mode:', choices=c("up/down","both"), inline=TRUE)
)
cmp_volcano1_module <- plotModule(
    "cmp_volcano1", cmp_volcano1.RENDER,
    title="Meta-volcano plot", label="a",
    info.text = "The Volcano plot visualizes the intersecting genes between the profiles.",
    options = cmp_volcano1.opts,
    pdf.width=8, pdf.height=6, res=72
)
output <- attachModule(output, cmp_volcano1_module)


cmp_fcbarplot.opts = tagList(
    checkboxInput('cmp_fcbarplot_abs','Absolute foldchange')
)
cmp_fcbarplot_module <- plotModule(
    "cmp_fcbarplot", cmp_fcbarplot.RENDER,
    title="Cumulative fold-change", label="b",
    info.text = "This plot visualizes the cumulative fold-change between the profiles.",
    options = cmp_fcbarplot.opts,
    pdf.width=8, pdf.height=6, res=72
)
output <- attachModule(output, cmp_fcbarplot_module)


fillCol(
    height = "100%", flex = c(1, 1),
    moduleWidget(cmp_volcano1_module),
    moduleWidget(cmp_fcbarplot_module)
)


```

> **Meta-volcano plot and top ranked cumulative fold-change.** . **(a)** The meta-volcano highlights the genes that are common/shared in all selected comparisons. **(b)** Genes ranked by cumulative fold-change across the selected comparisons. 
