Clustering {data-orientation=cols}
==========================================================================================


Inputs {.sidebar data-width=250}
------------------------------------------------------------------------------------------

<br>**Cluster Analysis.** Discover clusters of similar genes or
samples using unsupervised machine learning.

```{r}
##----------------------------------------------------------------------
## More Info (pop up window)
##----------------------------------------------------------------------
tipify( actionLink("clust_info", "Info", icon = icon("info-circle")),
       "Show more information about this module.")

clust_infotext = paste('
The <strong>Cluster Analysis</strong> module performs unsupervised clustering analysis of the data. After having done the QC, it is probably the first way to explore your data. The main purpose is to discover patterns and subgroups in the data, show correlation with known phenotypes, detect outliers, or investigate batch effects.

<br><br>In the <strong>Heatmap</strong> panel hierarchical clustering can be performed on gene level or gene set level (selected under the {Level} dropdown list). During the heatmap generation, the platform provides a functional annotation for each feature cluster in <strong>Annotate cluster</strong> panel. Users can select from a variety of annotation databases from the literature, such as ',a_MSigDB,', ',a_KEGG,' and ',a_GO,'. The <strong>PCA/tSNE</strong> panel shows unsupervised clustering of the samples in 2D/3D as obtained by ',a_PCA,' or ',a_tSNE,' algorithms. The <strong>Phenotypes</strong> panel on the right, shows the phenotype distribution as colors on the t-SNE plot. 

<br><br>EXPERT MODE ONLY: The <strong>Feature ranking</strong> panel computes a discriminant score for gene (or geneset) families. This allows to investigate what family of genes (or gene sets) can best discriminate the groups. 

<br><br><br><br>
<center><iframe width="500" height="333" src="https://www.youtube.com/embed/watch?v=qCNcWRKj03w&list=PLxQDY_RmvM2JYPjdJnyLUpOStnXkWTSQ-&index=2" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></center>


')

observeEvent( input$clust_info, {
    showModal(modalDialog(
        title = HTML("<strong>Clustering Module</strong>"),
        HTML(clust_infotext),
        easyClose = TRUE, size="l" ))
})


##----------------------------------------------------------
##----------------- INPUT WIDGETS --------------------------
##----------------------------------------------------------

br();br();hr();
##h5("Inputs:")

tipify( selectInput("hm_level","Level:", choices=c("gene","geneset")),
        "Specify the level analysis: gene or geneset level.", placement="top")
tipify( selectInput("hm_features","Features:", choices=NULL, multiple=FALSE),
        "Select a family of features.", placement="top")
conditionalPanel(
    "input.hm_features == '<custom>'",
    tipify( textAreaInput("hm_customlist", NULL, value = NULL,
                          rows=5, placeholder="Paste your custom gene list"),
           "Paste a custom list of genes to be used as features.", placement="bottom")
)
tipify( selectInput("hm_samplefilter","Filter samples:", choices=NULL, multiple=TRUE),
       "Filter the relevant samples for the analysis.", placement="top")


conditionalPanel(
    ## "input.main_usermode == 'PRO'",
    condition = "output.main_usermode == 'PRO' || output.main_usermode == 'DEV'",
    tipify( actionLink("hm_options", "Options", icon=icon("cog", lib = "glyphicon")),
           "Toggle advanced options.", placement="top"),
    br(),
    conditionalPanel(
        "input.hm_options % 2 == 1",
        tagList(
            tipify( checkboxInput('hm_group','grouped',FALSE),
                   "Group the samples by a predefined phenotype class.", placement="bottom")
        )
    )
)

if(DEV.VERSION) {
    tagList(
        br(),hr(),
        h5("Developer options:"),
        radioButtons('hm_gsetmatrix','Gene set matrix (dev):',
                     choices=c("meta"), inline=TRUE)
    )
}

##================================================================================
##======================= OBSERVE FUNCTIONS ======================================
##================================================================================

## update filter choices upon change of data set 
observe({
    ngs <- inputData()
    req(ngs)

    levels = getLevels(ngs$Y)
    updateSelectInput(session, "hm_samplefilter", choices=levels)
    
    if(DEV.VERSION && !is.null(ngs$gset.meta$matrices) ) {
        jj = which(!sapply(ngs$gset.meta$matrices,is.null))
        mat.names = names(ngs$gset.meta$matrices)[jj]
        updateRadioButtons(session, "hm_gsetmatrix", choices=mat.names, selected="meta", inline=TRUE)    
    } else {
        updateRadioButtons(session, "hm_gsetmatrix", choices=c("meta"), inline=TRUE)    
    }

})

input_hm_samplefilter <- reactive({
    input$hm_samplefilter
}) %>% debounce(2000)


## update choices upon change of level
##observeEvent(input$hm_level, {
observe({
    ngs = inputData()
    req(ngs)
    if(is.null(input$hm_level)) return(NULL)
    choices = names(ngs$families)
    if(input$hm_level=="geneset") {
        choices = names(COLLECTIONS)
    }
    choices <- c("<custom>",choices)
    choices <- sort(unique(choices))
    updateSelectInput(session, "hm_features", choices=choices)
})


hm_filtered_matrix <- reactive({
    ## Returns filtered matrix ready for clustering. Filtering based
    ## on user selected geneset/features or custom list of genes.
    ##
    ##
    ##
    ngs <- inputData()
    req(ngs)
    genes = as.character(ngs$genes$gene_name)
    genesets = rownames(ngs$gsetX)

    if(input$hm_level=="geneset") {
        gsets = rownames(ngs$gsetX)
        gsets = unique(unlist(COLLECTIONS[input$hm_features]))
        zx = ngs$gsetX
        if(0 && DEV.VERSION && !is.null(ngs$gset.meta$matrices) ) {
            ##zx = ngs$gset.meta$matrices[["meta"]]
            jj = which(!sapply(ngs$gset.meta$matrices,is.null))
            mat.names = names(ngs$gset.meta$matrices)[jj]
            if(is.null(mat.names)) stop("error:: no geneset matrices!")
            k = input$hm_gsetmatrix
            if(k %in% mat.names)  zx <- ngs$gset.meta$matrices[[k]]
        }
        if(input$hm_customlist!="") {
            gsets1 = genesets[grep(input$hm_customlist, genesets,ignore.case=TRUE)]
            if(length(gsets1)>2) gsets = gsets1
        }        
        zx = zx[intersect(gsets,rownames(zx)),]
    } else {
        pp = head(rownames(ngs$X),400)
        gg = ngs$families[[1]]
        gg = ngs$families[[input$hm_features]]
        if(input$hm_customlist!="") {
            gg1 = strsplit(input$hm_customlist,split="[, ;\n\t]")[[1]]
            if(length(gg1)==1) gg1 <- paste0(gg1,"*")
            gg1 = gsub("[ \n\t]","",gg1)
            starred = grep("[*]",gg1)
            if(length(starred)>0) {
                gg2 = lapply(gg1[starred], function(a)
                    genes[grep(paste0("^",sub("[*]","",a)),genes,ignore.case=TRUE)])
                gg1 = unique(c(gg1,unlist(gg2)))
            }
            gg1 = intersect(gg1,ngs$genes$gene_name)            
            if(length(gg1)>1) gg = gg1
        }
        jj <- match(toupper(gg), toupper(ngs$genes$gene_name))
        pp = rownames(ngs$genes)[setdiff(jj,NA)]
        zx = ngs$X[intersect(pp,rownames(ngs$X)),]
    }
    if(nrow(zx)==0) return(NULL)
    dim(zx)
    kk <- selectSamplesFromSelectedLevels(ngs$Y, input_hm_samplefilter() )
    zx <- zx[,kk,drop=FALSE]    

    if(input$hm_level=="gene" && "chr" %in% names(ngs$genes)) {
        ## Filter out X/Y chromosomes before clustering
        chr <- ngs$genes[rownames(zx),]$chr
        not.xy <- !(chr %in% c("X","Y",23,24))
        table(not.xy)
        zx <- zx[which(not.xy), ]
        dim(zx)
    }
    
    nmax=4000
    nmax = as.integer(input$hm_ntop)
    idx <- NULL
    splitx <- input$hm_splitx
    topmode="sd"
    topmode <- input$hm_topmode

    if(splitx=="<none>" && topmode=="specific") topmode <- "sd"
    if(topmode=="pca") {
        require(irlba)
        NPCA=5
        ntop = 12
        ntop <- as.integer(input$hm_ntop) / NPCA
        svdres <- irlba(zx - rowMeans(zx), nv=NPCA)
        gg <- rownames(zx)
        sv.top <- lapply(1:NPCA,function(i) gg[head(order(-abs(svdres$u[,i])),ntop)] )
        gg.top <- unlist(sv.top)
        for(i in 1:length(sv.top)) {
            sv.top[[i]] <- paste0("PC",i,":",sv.top[[i]])
        }
        sv.top1 <- unlist(sv.top)
        zx <- zx[gg.top,]
        ##rownames(zx) <- sv.top1
        dim(zx)
        ##idx <- paste0("PC",sub(":.*","",sv.top1))
        idx <- sub(":.*","",sv.top1)
        table(idx)
    } else if(topmode=="specific" && splitx!="<none>") {
        ##grp <- ngs$samples[colnames(zx),"cluster"]
        grp <- ngs$samples[colnames(zx),splitx]
        table(grp)
        grp.zx <- t(apply(zx, 1, function(x) tapply(x, grp, mean)))
        grp.dx <- grp.zx*0
        nc <- ncol(grp.dx)
        for(i in 1:nc) {
            grp.dx[,i] <- grp.zx[,i] - rowMeans(grp.zx[,-i,drop=FALSE])
        }
        gg <- rownames(zx)
        ntop = 12
        ntop <- ceiling( as.integer(input$hm_ntop) / ncol(grp.dx) )
        grp.top <- lapply(1:nc,function(i) gg[head(order(-grp.dx[,i]),ntop)] )
        ##idx <- unlist(sapply(1:nc,function(i) rep(i,length(grp.top[[i]]))))
        idx <- unlist(mapply(rep,1:nc,sapply(grp.top,length)))
        idx <- paste0("M",idx)
        table(idx)        
        gg.top <- unlist(grp.top)
        zx <- zx[gg.top,]
        dim(zx)
    } else {
        ii <- order(-apply(zx,1,sd,na.rm=TRUE))
        zx = zx[ii,,drop=FALSE] ## order
        zx = head(zx,nmax)
    }
    ##zx = zx / apply(zx,1,sd,na.rm=TRUE)  ## scale??

    ## ------------- cluster the genes???
    if(is.null(idx)) {
        hc  = fastcluster::hclust( as.dist(1 - cor(t(zx),use="pairwise")), method="ward.D2" )
        ngrp = 4  ## how many default groups???
        idx = paste0("S",cutree(hc, ngrp))
    }

    ## ------------- matched annotation
    annot = ngs$Y[colnames(zx),,drop=FALSE]
    kk = grep("sample|patient",colnames(annot),invert=TRUE)
    annot = annot[,kk,drop=FALSE]  ## no group??    
    samples = colnames(zx) ## original sample list
    
    ## ------------- calculate group summarized
    if(1) { 
        grp = ngs$samples[colnames(zx),"group"]
        if(0) {
            grp.zx = t(apply( zx, 1, function(x) tapply(x, grp, mean)))
            grp.annot = annot[match(colnames(zx),grp),,drop=FALSE] ## NEED RETHINK!!!
            rownames(grp.annot) = colnames(zx)
        } else {
            grp.zx = tapply( colnames(zx), grp, function(k) rowMeans(zx[,k,drop=FALSE],na.rm=TRUE))
            grp.zx = do.call( cbind, grp.zx)
            ## take most frequent term as group annotation value
            most.freq <- function(x) names(sort(-table(x)))[1]
            grp.annot = tapply( rownames(annot), grp, function(k) {
                f <- apply(annot[k,,drop=FALSE],2,function(x) most.freq(x))
                w.null <- sapply(f,is.null)
                if(any(w.null))  f[which(w.null)] <- NA
                unlist(f)
            })
            grp.annot = data.frame(do.call( rbind, grp.annot))
            grp.annot = grp.annot[colnames(grp.zx),]
        }
    }
    
    ##input$top_terms
    filt <- list(mat=zx, annot=annot,
                 grp.mat = grp.zx, grp.annot = grp.annot,
                 clust=idx, samples=samples)
    return(filt)
})

```


Col {.tabset data-width=600}
-----------------------------------------------------------------------------------------


### Heatmap
	
```{r}

hm_splitmap_text = tagsub("Under the <strong>Heatmap</strong> panel, hierarchical clustering can be performed on gene level or gene set level expression in which users have to specify it under the {Level} dropdown list. <p>Under the plot configuration {{Settings}}, users can split the samples by a phenotype class (e.g., tissue, cell type, or gender) using the {split by} setting. In addition, users can specify the top N = (50, 500) features to be used in the heatmap. The ordering of top features is selected under {top mode}. The criteria to select the top features are: <ol><li>SD - features with the highest standard deviation across all the samples, </li><li>specific - features that are overexpressed in each phenotype class compared to the rest, or by </li><li>PCA - by principal components.<br></ol> <br><p>Users can also choose between 'relative' or 'absolute' expression scale. Under the {CexCol} and {CexRow} settings, it is also possible to adjust the cex for the column and row labels.")


require(plotly)
require(scatterD3)
##require(tippy)

observe({
    ngs <- inputData()
    req(ngs)    
    cvar <- pgx.getCategoricalPhenotypes(ngs$samples, min.ncat=2, max.ncat=20)
    sel <- c(grep("cell.type|cell.family|type|family|tissue|histo",cvar,value=TRUE),"<none>")[1]
    updateSelectInput(session, "hm_splitx", choices=c("<none>",cvar), selected=sel)
})

hm1_splitmap.RENDER <- reactive({

    ngs <- inputData()
    filt <- hm_filtered_matrix()
    req(ngs, filt)
    
    if(input$hm_group) {
        zx <- filt$grp.mat    
        annot = filt$grp.annot
    } else {
        zx <- filt$mat    
        annot = filt$annot        
    }
    zx.clust <- filt$clust    
    
    show_rownames = TRUE
    ##if(nrow(zx) > 100) rownames(zx) = rep("",nrow(zx))
    if(nrow(zx) > 100) show_rownames = FALSE   

    main = "  "
    main = input$hm_features
    
    cex1 = ifelse(ncol(zx)>50,0.75,1)
    cex1 = ifelse(ncol(zx)>100,0.5,cex1)
    cex1 = ifelse(ncol(zx)>200,0,cex1)
    
    scale.mode = "row.center"
    scale.mode = ifelse(input$hm_scale=="relative","row.center","none")
    scale.mode
    
    ## split genes dimension in 5 groups
    splity = 5
    splity = 6
    if(!is.null(zx.clust)) splity = zx.clust
    
    ## split samples
    splitx = NULL    
    splitx = input$hm_splitx
    if( splitx %in% colnames(annot) ) {
        splitx = annot[,splitx]
    } else {
        splitx = NULL
    }

    show_legend = TRUE
    if(input$hm_level=="geneset" || !is.null(splitx)) show_legend = FALSE
    annot$group = NULL  ## no group in annotation
    show_colnames <- ("column" %in% input$hm_showlabel)
    if(ncol(zx) > 200) show_colnames <- FALSE ## never...    
    
    if(input$hm_level=="gene") {
        rownames(zx) = sub(".*:","",rownames(zx))
    }
    rownames(zx) <- sub("HALLMARK:HALLMARK_","HALLMARK:",rownames(zx))
    rownames(zx) = gsub(GSET.PREFIX.REGEX,"",rownames(zx))
    rownames(zx) = substring(rownames(zx),1,50)  ## cut long names...
    if(input$hm_level=="geneset")  rownames(zx) <- tolower(rownames(zx))
    
    cex2 <- ifelse( nrow(zx) > 60, 0.8, 0.9)    
    cex1 <- as.numeric(input$hm_cexCol)*0.9
    cex2 <- as.numeric(input$hm_cexRow)*0.85
    
    crot <- 0
    totnchar <- nchar(paste0(unique(splitx),collapse=""))
    totnchar
    nx <- length(unique(splitx))
    if(!is.null(splitx) & (totnchar > 44 || nx>=6) ) crot=90
    if(main=="<all>") main <- "  "

    nrownames = 60
    nrownames = ifelse("row" %in% input$hm_showlabel,60,0)
    
    withProgress(
        message='rendering heatmap...', value=0.66,
        gx.splitmap( zx, 
                    split=splity, splitx=splitx,
                    mar=c(5,25), scale=scale.mode, show_legend=show_legend,
                    show_colnames = show_colnames, column_title_rot=crot,
                    show_rownames = nrownames, softmax=0,
                    ## side.height.fraction=0.03+0.055*NCOL(annot), 
                    labRow=NULL, cexCol=cex1, cexRow=cex2, 
                    col.annot=annot, row.annot=NULL, annot.ht=2.6,
                    main=main, nmax=-1)
    )

})

hm2_splitmap.RENDER <- reactive({

    ngs <- inputData()
    req(ngs, input$hm_splitx)
       
    cat("<module-clustering:hm2_splitmap.RENDER> reacted\n")

    ## -------------- variable to split samples
    split.var=NULL    
    split.var="activated"
    split.var = input$hm_splitx
    if(split.var=="<none>") split.var = NULL
    
    scale = ifelse(input$hm_scale=="relative","row.center","none")    
    plt <- NULL
    
    withProgress(
        message='rendering iHeatmap...', value=0.66,
        {
            filt <- hm_filtered_matrix()
            ##if(is.null(filt)) return(NULL)
            req(filt)        
            if(input$hm_group) {
                X <- filt$grp.mat    
                annot = filt$grp.annot
            } else {
                X <- filt$mat    
                annot = filt$annot        
            }
            idx <- filt$clust    
            
            ## sample clustering index
            splitx <- NULL
            if(!is.null(split.var) && split.var %in% colnames(annot)) {
                splitx <- annot[,split.var]
            }
            
            ## iheatmapr needs factors for sharing between groups
            annotF <- data.frame(as.list(annot),stringsAsFactors=TRUE)
            rownames(annotF) = rownames(annot)

            colcex <- as.numeric(input$hm_cexCol)
            rowcex = as.numeric(input$hm_cexRow)
            rowcex = ifelse("row" %in% input$hm_showlabel, rowcex, 0)
            colcex = ifelse("column" %in% input$hm_showlabel, colcex, 0)
            
            tooltips = NULL
            if(input$hm_level=="gene") {
                getInfo <- function(g) {
                    aa = paste0("<b>",ngs$genes[g,"gene_name"],"</b>. ",
                                ## ngs$genes[g,"map"],". ",
                                ngs$genes[g,"gene_title"],".")
                    breakstring2(aa, 50, brk="<br>")
                }
                tooltips = sapply(rownames(X), getInfo)
            } else {
                aa = gsub("_"," ",rownames(X)) ## just geneset names
                tooltips = breakstring2(aa, 50, brk="<br>")
            }
            ##genetips = rownames(X)
            
            cat("<module-clustering:hm2_splitmap.RENDER> plotting\n")            
            plt <- pgx.splitHeatmapX(
                X=X, annot=annotF, ytips=tooltips,
                idx=idx, splitx=splitx, scale=scale,
                row_annot_width=0.03, rowcex=rowcex,
                colcex=colcex )
        }
    )
    cat("<module-clustering:hm2_splitmap.RENDER> done\n")
    return(plt)
})


hm_splitmap_opts = tagList(
    tipify( radioButtons("hm_plottype", "Plot type:",
                         choices=c("ComplexHeatmap","iHeatmap"),
                         selected="ComplexHeatmap", inline=TRUE, width='100%'),
           "Choose plot type: ComplexHeatmap (static) or iHeatmap (interactive)",
           placement="right",options = list(container = "body")),
    tipify( selectInput("hm_splitx", "split by:", choices="group", width='100%'),
           "Split the samples by a predetermined phenotype class (e.g. tissue or cell type).",
           placement="right",options = list(container = "body")),
    tipify( selectInput('hm_topmode','Top mode:',c("specific","sd","pca"), width='100%'),
           "Specify the criteria for selecting top features to be shown in the heatmap.",
           placement="right", options = list(container = "body")),
    tipify( radioButtons('hm_ntop','Top N:',c(50,500),inline=TRUE,selected=50),
           "Select the number of top features to be shown in the analysis.", placement="top"),
    tipify( radioButtons(
        'hm_scale', 'Scale:', choices=c('relative','absolute'), inline=TRUE),
        "Show relative (i.e. mean-centered) or absolute expression values.",
        placement="bottom"),
    tipify( checkboxGroupInput('hm_showlabel', 'Show labels:', choices=c('row','column'),
                               selected=c('row','column'), inline=TRUE),
           "Show/hide row or column names.", placement="bottom"),
    fillRow( flex=c(1,1),
        tipify( selectInput("hm_cexCol", "CexCol:", choices=seq(0.1,1.2,0.1), selected=1, width='100%'),
               "Specify the column label cex.", placement="right",options = list(container = "body")),
        tipify( selectInput("hm_cexRow", "CexRow:", choices=seq(0.1,1.2,0.1), selected=1, width='100%'),
               "Specify the row label cex.", placement="right",options = list(container = "body"))
    ),
    br(),br(),br(),br()
)


hm_splitmap_caption <- reactive({
    text1 = "Heatmap showing gene expression sorted by 2-way hierarchical clustering. Red corresponds to overexpression, blue to underexpression of the gene. At the same time, gene clusters are functionally annotated in the 'Annotate clusters' panel on the right."
    return(text1)
})

hm_splitmap.switchRENDER <- reactive({
    cat("<module_intersect::hm_splitmap.switchRENDER\n")
    ##req(input$hm_plottype)
    p = NULL
    if(input$hm_plottype %in% c("ComplexHeatmap","static") ) {
        p = plotOutput("hm1_splitmap")  ## see below
    } else {
        p = iheatmaprOutput("hm2_splitmap") ## see below
    }
    return(p)
})

hm_splitmap_module <- plotModule(
    "hm_splitmap", hm_splitmap.switchRENDER,
    plotlib="generic", renderFunc="renderUI",
    download.fmt = c("pdf","html"),
    info.text = hm_splitmap_text,
    options = hm_splitmap_opts,
    pdf.width=10, pdf.height=8, info.width="350px",
    title="Clustered Heatmap"
)
output <- attachModule(output, hm_splitmap_module)

output$hm1_splitmap  <- renderPlot({
    hm1_splitmap.RENDER()
    ## plot(sin)
}, res=90)

output$hm2_splitmap <- renderIheatmap({
    hm2_splitmap.RENDER()
})

output$hm_splitmap_pdf <- downloadHandler(
    filename = "plot.pdf",
    content = function(file) {
        PDFFILE = hm_splitmap_module$.tmpfile["pdf"]  ## from above!
        dbg("hm_splitmap_pdf:: exporting to PDF...")
        withProgress({
            if(input$hm_plottype %in% c("ComplexHeatmap","static")) {
                pdf(PDFFILE, width=10, height=8)
                print(hm1_splitmap.RENDER())  ## should be done inside render for base plot...
                dev.off()
            } else {
                save_iheatmap(hm2_splitmap.RENDER(), filename=PDFFILE,  vwidth=1000, vheight=800)
            }
        }, message="exporting to PDF", value=0.5)
        dbg("hm_splitmap_pdf:: exporting done...")
        file.copy(PDFFILE,file)        
    }
)

output$hm_splitmap_html <- downloadHandler(
    filename = "plot.html",
    content = function(file) {
        HTMLFILE = hm_splitmap_module$.tmpfile["html"]  ## from above!
        ##HTMLFILE = paste0(tempfile(),".html")
        dbg("renderIheatmap:: exporting to HTML...")
        withProgress({
            ##write("<body>HTML export error</body>", file=HTMLFILE)    
            p <- hm2_splitmap.RENDER()
            incProgress(0.5)
            save_iheatmap(p, filename=HTMLFILE)
        }, message="exporting to HTML", value=0 )
        dbg("renderIheatmap:: ... exporting done")
        file.copy(HTMLFILE,file)        
    }
)

## > **Clustered heatmap.** `r renderUI(HTML(hm_splitmap_caption()))`

fillCol(
    moduleWidget(hm_splitmap_module, outputFunc="uiOutput")
)
```

> **Clustered heatmap.** Heatmap showing gene expression sorted by
> 2-way hierarchical clustering. Red corresponds to overexpression,
> blue to underexpression of the gene. At the same time, gene clusters
> are functionally annotated in the 'Annotate clusters' panel on the
> right.


### PCA/tSNE

```{r warnings=FALSE, message=FALSE, fig.width=12, fig.height=8}

hm_PCAplot_text = tagsub(paste0(' The <b>PCA/tSNE</b> panel visualizes unsupervised clustering obtained by the principal components analysis (',a_PCA,') or t-distributed stochastic embedding (',a_tSNE,') algorithms. This plot shows the relationship (or similarity) between the samples for visual analytics, where similarity is visualized as proximity of the points. Samples that are ‘similar’ will be placed close to each other. 
<br><br>Users can customise the PCA/tSNE plot in the plot settings, including the {color} and {shape} of points using a phenotype class, choose t-SNE or PCA layout, label the points, or display 2D and 3D visualisation of the PCA/tSNE plot.'))


require(plotly)
require(scatterD3)

observe({
    ngs <- inputData()
    var.types = colnames(ngs$Y)
    var.types = var.types[grep("sample|patient",var.types,invert=TRUE)]
    vv = c(var.types,rep("<none>",10))
    var.types0 = c("<none>","<cluster>",var.types)
    var.types0 = c("<none>",var.types)
    var.types1 = c("<none>",var.types)
    grp = vv[1]
    if("group" %in% var.types) grp = "group"
    updateSelectInput(session, "hmpca.colvar", choices=var.types0, selected=grp)
    updateSelectInput(session, "hmpca.shapevar", choices=var.types1, selected="<none>")
    ##updateSelectInput(session, "hmpca.line", choices=var.types1, selected="<none>")
    ##updateSelectInput(session, "hmpca.text", choices=var.types0, selected="group")
})

hm_getClusterPositions <- reactive({
    ngs <- inputData()
    req(ngs)
    ##zx <- hm_filtered_matrix()
    zx = ngs$X
    kk <- selectSamplesFromSelectedLevels(ngs$Y, input_hm_samplefilter() )
    zx <- zx[,kk,drop=FALSE]

    ## apply feature filter
    gg = ngs$families[[input$hm_features]]
    jj <- match(toupper(gg), toupper(ngs$genes$gene_name))
    gg = ngs$genes$gene_name[setdiff(jj,NA)]
    pp = filterProbes(ngs$genes, gg)
    zx = zx[intersect(pp,rownames(zx)),]
    zx = head(zx[order(-apply(zx,1,sd)),],1000)  ## OK?

    if("normalize" %in% input$hmpca_options) {
        zx <- scale(t(scale(t(zx))))
    }
    pdim = 3
    do3d <- ("3D" %in% input$hmpca_options)
    pdim = c(2,3)[ 1 + 1*do3d]
    
    pos = NULL
    if(input$hm_clustmethod=="tsne") {
        require(Rtsne)
        force.compute = FALSE
        ## force.compute = TRUE
        if(!force.compute && pdim==2 && !is.null(ngs$tsne2d) ) {
            cat("getClusterPositions:: 2D tSNE from object\n")
            pos <- ngs$tsne2d[colnames(zx),]
        } else if(!force.compute && pdim==3 && !is.null(ngs$tsne3d) ) {
            cat("getClusterPositions:: 3D tSNE from object\n")
            pos <- ngs$tsne3d[colnames(zx),]
        } else {
            cat("getClusterPositions:: computing tSNE...\n")
            showNotification("computing tSNE...\n")
            perplexity = max(min(30,ncol(zx)/4),1)
            perplexity = min((ncol(zx)-1)/3, 30)
            perplexity
            pos <- Rtsne( t(zx), dim=pdim, check_duplicated=FALSE,
                         num_threads=100, ##Y_init=Y_init,
                         perplexity=perplexity )$Y
        }
    } else if(input$hm_clustmethod=="umap") {
        ## install.packages("umap")
        showNotification("computing UMAP...\n")
        require(umap)
        ngrp = length(unique(ngs$samples$group))
        nnb  = min(min(15,max(3,ncol(zx)/ngrp)),ncol(zx))
        nnb
        pos = umap(
            t(zx),
            n_neighbours = nnb,
            n_components = pdim,
            metric = "euclidean",
            n_components = pdim
        )$layout

    } else {
        cat("getClusterPositions:: computing PCA/SVD...\n")
        showNotification("computing PCA...\n")
        require(irlba)
        ##pos <- cmdscale(dist(t(zx)), k=3)
        ##pos = svd(zx,nv=3)$v
        pos = irlba(zx, nv=pdim)$v
    }

    pos = scale(pos) ## scale
    colnames(pos) = paste0("dim",1:ncol(pos))
    rownames(pos) = colnames(zx)

    clust <- NULL
    if(FALSE) {
        ## should be relatively fast in sample space...
        cat("getClusterPositions:: louvain clustering...\n")
        require(igraph)
        dist = as.dist(dist(pos))
        gr = graph_from_adjacency_matrix(
            1.0/dist, diag=FALSE, mode="undirected")
        clust <- cluster_louvain(gr)$membership
    }

    ##cat("getClusterPositions:: done!\n")
    return( list(pos=pos, clust=clust) )
})


hm_PCAplotFUNC <- reactive({

    ngs <- inputData()
    req(ngs)
    do3d = ("3D" %in% input$hmpca_options)

    clust <- hm_getClusterPositions()
    pos <- clust$pos
    sel <- rownames(pos)
    df <- cbind(pos, ngs$Y[sel,])
    if(!is.null(clust$clust)) df[["<cluster>"]] <- clust$clust

    colvar = shapevar = linevar = textvar = NULL
    if(input$hmpca.colvar %in% colnames(df)) colvar <- factor(df[,input$hmpca.colvar])
    if(input$hmpca.shapevar %in% colnames(df)) shapevar <- factor(df[,input$hmpca.shapevar])
    ##if(input$hmpca.line %in% colnames(df)) linevar = factor(df[,input$hmpca.line])
    ##if(input$hmpca.text %in% colnames(df)) textvar = factor(df[,input$hmpca.text])
    mode = "markers"
    ann.text = rep(" ",nrow(df))
    if(!do3d && "label" %in% input$hmpca_options) ann.text = rownames(df)
    if(!is.null(colvar)) {
        colvar = factor(colvar)
        textvar <- factor(df[,input$hmpca.colvar])
    }
    symbols = c('circle','square','star','triangle-up','triangle-down','pentagon',
                'bowtie','hexagon', 'asterisk','hash','cross','triangle-left',
                'triangle-right','+',c(15:0))

    require(plotly)
    tt.info <- paste('Sample:', rownames(df),'</br>Group:', df$group)
    cex1 = c(1.0,0.8,0.6)[1 + 1*(nrow(pos)>30) + 1*(nrow(pos)>200)]

    if(do3d ) {
        ## 3D plot
        j0 = 1:nrow(df)
        j1 = NULL
        if(!is.null(linevar)) {
            linevar = factor(linevar)
            j0 = which(linevar==levels(linevar)[1])
            j1 = which(linevar!=levels(linevar)[1])
        }
        plt <- plot_ly(df, mode=mode) %>%
            add_markers(x = df[j0,1], y = df[j0,2], z = df[j0,3], type="scatter3d",
                        color = colvar[j0], ## size = sizevar, sizes=c(80,140),
                        ##marker = list(size = 5*cex1),
                        marker = list(size=5*cex1, line=list(color="grey10", width=0.1)),
                        symbol = shapevar[j0], symbols=symbols,
                        text = tt.info[j0] ) %>%
            add_annotations(x = pos[,1], y = pos[,2], z = pos[,3],
                            text = ann.text,
                            ##xref = "x", yref = "y",
                            showarrow = FALSE)
        if(!is.null(j1) & length(j1)>0) {
            plt <- plt %>%  add_markers(
                                x = df[j1,1], y = df[j1,2], z = df[j1,3], type="scatter3d",
                                color = colvar[j1], ## size = sizevar, sizes=c(80,140),
                                ##marker = list(size=5*cex1, line=list(color="grey10", width=2)),
                                symbol = shapevar[j1], symbols=symbols,
                                text=tt.info[j1])
        }
        ## add cluster annotation labels
        if(0 && length(unique(colvar))>1) {
            ## add cluster annotation labels
            grp.pos <- apply(pos,2,function(x) tapply(x,colvar,median))
            ##grp.pos <- matrix(grp.pos, ncol=3)
            cex2 <- ifelse(length(grp.pos)>20,0.8,1)
            plt <- plt %>% add_annotations(
                               x = grp.pos[,1], y = grp.pos[,2], z = grp.pos[,3],
                               text = rownames(grp.pos),
                               font=list(size=24*cex2, color='#555'),
                               showarrow = FALSE)
        }

    } else {
        ## 2D plot
        j0 = 1:nrow(df)
        j1 = NULL
        if(!is.null(linevar)) {
            linevar = factor(linevar)
            j0 = which(linevar==levels(linevar)[1])
            j1 = which(linevar!=levels(linevar)[1])
        }
        plt <- plot_ly(df, mode=mode) %>%
            add_markers(x = df[j0,1], y = df[j0,2], type="scatter",
                        color = colvar[j0], ## size = sizevar, sizes=c(80,140),
                        marker = list(size=16*cex1, line=list(color="grey20", width=0.6)),
                        symbol = shapevar[j0], symbols=symbols,
                        text = tt.info[j0] ) %>%
            add_annotations(x = pos[,1], y = pos[,2],
                            text = ann.text,
                            ##xref = "x", yref = "y",
                            showarrow = FALSE)

        ## add node labels
        if(!is.null(j1) & length(j1)>0 ) {
            plt <- plt %>%  add_markers(
                                x = df[j1,1], y = df[j1,2], type="scatter",
                                color = colvar[j1], ## size = sizevar, sizes=c(80,140),
                                marker = list(size=16*cex1, line=list(color="grey20", width=1.8)),
                                symbol = shapevar[j1], symbols=symbols,
                                text=tt.info[j1])
        }

        ## add group/cluster annotation labels
        if(!is.null(textvar) && length(unique(textvar))>1) {
            grp.pos <- apply(pos,2,function(x) tapply(x,as.character(textvar),median))
            cex2 <- 1
            if(length(grp.pos)>20) cex2 <- 0.8
            if(length(grp.pos)>50) cex2 <- 0.6
            plt <- plt %>% add_annotations(
                               x = grp.pos[,1], y = grp.pos[,2],
                               text = paste0("<b>",rownames(grp.pos),"</b>"),
                               font = list(size=24*cex2, color='#555'),
                               showarrow = FALSE)
        }
        plt <- plt %>% layout(showlegend = FALSE)
        
    }
    title = paste0("<b>PCA</b>  (",nrow(pos)," samples)")
    if(input$hm_clustmethod=="tsne") title = paste0("<b>tSNE</b>  (",nrow(pos)," samples)")
    ## plt <- plt %>% layout(title=title)
    ## plt <- plt %>% config(displayModeBar = FALSE)
    ##print(plt)
    return(plt)
})


hm_PCAplot_opts = tagList(
    tipify( selectInput("hmpca.colvar", "Color:", choices=NULL, width='100%'),
            "Set the colors of the samples according to a given phenotype class.", placement="right", options = list(container = "body")),
    tipify( selectInput("hmpca.shapevar", "Shape:", choices=NULL, width='100%'),
            "Set the shapes of the samples according to a given phenotype class.", placement="right", options = list(container = "body")),
    tipify( radioButtons('hm_clustmethod',"Layout:",c("tsne","pca","umap"),inline=TRUE),
            "Choose the layout method for clustering to visualise.", placement="top"),
    tipify( checkboxGroupInput('hmpca_options',"Other:", choices=c('label','3D','normalize'), inline=TRUE),
            "Normalize matrix before calculating distances.", placement="bottom")
)

hm_PCAplot_module <- plotModule(
    id="hm_PCAplot", func=hm_PCAplotFUNC,
    plotlib = "plotly", info.text = hm_PCAplot_text,
    options = hm_PCAplot_opts,
    pdf.width=8, pdf.height=8,
    title="PCA/tSNE plot"
)
output <- attachModule(output, hm_PCAplot_module)

fillCol(
    moduleWidget(hm_PCAplot_module, outputFunc="plotlyOutput")
)

hm_PCAplot_caption <- reactive({
    text1 = "The plot visualizes the similarity in expression of samples as a scatterplot in reduced dimension (2D or 3D). Samples that are similar are clustered near to each other, while samples with different expression are positioned farther away. Groups of samples with similar profiles will appear as <i>clusters</i> in the plot."
    if(input$hmpca.colvar!="<none>") {
        text1 <- paste(text1, "Colors correspond to the <strong>",input$hmpca.colvar,"</strong>phenotype.")
    }
    if(input$hmpca.shapevar!="<none>") {
        text1 <- paste(text1, "Shapes correspond to the <strong>",input$hmpca.shapevar,"</strong>phenotype.")
    }
    return(HTML(text1))
})
## > **PCA/tSNE plot.** `r renderUI(hm_PCAplot_caption())`

```

> **PCA/tSNE plot.** The plot visualizes the similarity in expression
> of samples as a scatterplot in reduced dimension (2D or 3D). Samples
> that are similar are clustered near to each other, while samples
> with different expression are positioned farther away. Groups of
> samples with similar profiles will appear as <i>clusters</i> in the
> plot.

Col {.tabset data-width=450}
--------------------------------------------------------------------------------------

### Annotate clusters

```{r warnings=FALSE, message=FALSE, fig.width=8, fig.height=4}

clustannot_plots_text = paste0('The top features of the heatmap in the <code>Heatmap</code> panel are divided into gene (or gene set) clusters based on their expression profile patterns. For each cluster, the platform provides a functional annotation in the <code>Annotate cluster</code> panel by correlating annotation features from more than 42 published reference databases, including well-known databases such as ',a_MSigDB,', ',a_KEGG,' and ',a_GO,'. In the plot settings, users can specify the level and reference set to be used under the <code>Reference level</code> and <code>Reference set</code> settings, respectively.')

observe({
    ngs <- inputData()    
    if(is.null(input$xann.level)) return(NULL)
    ann.types=sel=NULL
    if(input$xann.level!="phenotype") {
        if(input$xann.level=="geneset") ann.types <- names(COLLECTIONS)
        if(input$xann.level=="gene") ann.types <- names(ngs$families)
        ann.types <- setdiff(ann.types,"<all>")  ## avoid slow...
        ann.types <- grep("^<",ann.types,invert=TRUE,value=TRUE)  ## remove special groups
        sel = ann.types[1]
        if("H" %in% ann.types) sel = "H"
        j <- grep("^transcription",ann.types,ignore.case=TRUE)
        if(input$xann.level=="geneset") j <- grep("hallmark",ann.types,ignore.case=TRUE)
        if(length(j)>0) sel = ann.types[j[1]]
        ann.types <- sort(ann.types)
    } else {
        ann.types =sel = "<all>"
    }
    updateSelectInput(session, "xann.refset", choices=ann.types, selected=sel)    
})


getClustannotCorrelation <- reactive({

    dbg("<clustering:getClustannotCorrelation> reacted\n")
    
    ngs <- inputData()
    req(ngs)
    filt <- hm_filtered_matrix()
    req(filt)

    dbg("<clustering:getClustannotCorrelation> 1\n")
    
    zx  <- filt$mat
    idx <- filt$clust
    samples <- filt$samples

    ann.level="geneset"
    ann.refset="Hallmark collection"
    ann.level = input$xann.level
    ##if(is.null(ann.level)) return(NULL)
    ann.refset = input$xann.refset
    ##if(is.null(ann.refset)) return(NULL)
    req(input$xann.level, input$xann.refset)

    dbg("<clustering:getClustannotCorrelation> 2\n")
        
    ref = NULL
    ref = ngs$gsetX[,]    
    ref = ngs$X[,]    
    if(ann.level=="gene" && ann.refset %in% names(ngs$families) ) {
        gg = ngs$families[[ann.refset]]
        jj = match(toupper(gg), toupper(ngs$genes$gene_name))
        jj <- setdiff(jj,NA)
        pp = rownames(ngs$genes)[jj]
        ref = ngs$X[intersect(pp,rownames(ngs$X)),]    
    }
    if(ann.level=="geneset" && ann.refset %in% names(COLLECTIONS)) {
        ss = COLLECTIONS[[ann.refset]]
        ss = intersect(ss, rownames(ngs$gsetX))
        length(ss)
        ref = ngs$gsetX[ss,]    
    }
    if(ann.level=="phenotype") {
        ref = t(expandAnnotationMatrix(ngs$Y))
    }
    if(is.null(ref)) {
        cat("<clustering:getClustannotCorrelation> WARNING:: ref error\n")
        return(NULL)
    }

    cat("<clustering:getClustannotCorrelation> dim(ref)=",dim(ref),"\n")
    
    ##-----------  restrict to top??
    dim(ref)
    if(nrow(ref)>1000) {
        ref = head(ref[order(-apply(ref,1,sd)),],1000)
    }

    ##-----------  get original data level
    X = ngs$X
    if(input$hm_level=="geneset") X <- ngs$gsetX
    
    ##----------- for each gene cluster compute average correlation
    i=idx[1]
    idxx = setdiff(idx, c(NA," ","   "))    
    rho <- matrix(NA, nrow(ref), length(idxx))
    colnames(rho) <- idxx
    rownames(rho) <- rownames(ref)
    for(i in 1:length(idxx)) {
        gg = rownames(zx)[which(idx==idxx[i])]        
        aa <- t(X[gg,samples,drop=FALSE])
        bb <- t(ref[,samples,drop=FALSE])
        ##rr = cor(aa , bb, use="pairwise", method="spearman")
        rr = cor(apply(aa,2,rank), apply(bb,2,rank), use="pairwise")
        if(input$hm_topmode=="pca") rr <- abs(rr)
        rho[,i] <- colMeans(rr,na.rm=TRUE)
    }

    cat("<clustering:getClustannotCorrelation> dim(rho)=",dim(rho),"\n")
    ##rho = round(rho, digits=3)
    dim(rho)

    return(rho)
})


clustannot_plots.RENDER <- reactive({
    require(RColorBrewer)
    rho = getClustannotCorrelation()
    ##if(is.null(rho)) return(NULL)
    req(rho)
    
    NTERMS = 6
    NTERMS = 8
    if(ncol(rho)>6) {
        par( mfrow=c(3,3), mar=c(3,2,1.5,1)*0.5 )
        NTERMS = 6
    }
    i=1
    klrpal = brewer.pal(8,"Set2")

    par(mfrow=c(2,3), mar=c(3.5,2,2,1), mgp=c(2,0.8,0))
    for(i in 1:min(9,ncol(rho))) {
        x = rev(head(sort(rho[,i],decreasing=TRUE),NTERMS))
        names(x) = sub(".*:","",names(x))
        names(x) = gsub(GSET.PREFIX.REGEX,"",names(x))
        klr = klrpal[i]
        ##klr <- rgb(t(pmin(1.33*col2rgb(klr),255)), maxColorValue=255) ## make color lighter
        klr = paste0(klr,"66")
        is.bottom <- ifelse(i>=4,TRUE,FALSE)
        if(ncol(rho)>6)  is.bottom <- ifelse(i>=7,TRUE,FALSE)
        barplot(x, horiz=TRUE, las=1, names.arg=NA, xlim=c(0,1),
                width=5/6, space=0.2, border=NA, col=klr, ##col="grey80",
                xlab=ifelse(is.bottom, "correlation (rho)",""),
                cex.axis=1.1, cex.lab=1.1)
        title(main=colnames(rho)[i], cex.main=1.3 )
        text(0, 1:length(x)-0.45, labels=names(x), cex=1.1, pos=4, adj=0)
    }            
})

clustannot_plots.PLOTLY <- reactive({
    require(RColorBrewer)
    rho = getClustannotCorrelation()
    ##if(is.null(rho)) return(NULL)
    req(rho)
    
    ##par(mfrow=c(2,3), mar=c(3.5,2,2,1), mgp=c(2,0.8,0))
    NTERMS = 6
    NTERMS = 12
    slen=40
    if(ncol(rho)>=5)  {
        slen=20
    }
    if(ncol(rho)>6)  {
        NTERMS=6
    }
    if(ncol(rho)<=2) {
        NTERMS=20
    }

    klrpal = rep(brewer.pal(8,"Set2"),2)
    ##klrpal = paste0(klrpal,"88")
    col.addalpha <- function(clr,a=100)
        paste0("rgba(",paste(col2rgb(clr)[,1],collapse=","),",",a,")")
    ##klrpal = as.character(sapply(klrpal, col.addalpha, a=50))
    klrpal <- paste0(klrpal,"55")
    
    plot_list <- list()
    i=1    
    for(i in 1:min(9,ncol(rho))) {
        
        x = rev(head(sort(rho[,i],decreasing=TRUE),NTERMS))
        names(x) = sub(".*:","",names(x))
        names(x) = gsub(GSET.PREFIX.REGEX,"",names(x))

        y = names(x)
        y = factor(y, levels=y)
        anntitle <- function(tt) {
            list(text=tt, font = list(size=13),
                 xref="paper", yref="paper",
                 yanchor = "bottom", xanchor = "center",
                 align = "center", x=0.5, y=1.02 , showarrow = FALSE )
        }
        
        plot_list[[i]] <- plot_ly(
            x=x, y=y, type='bar',  orientation='h',
            text=y, hoverinfo = 'text',
            hovertemplate = paste0("%{y}<extra>",colnames(rho)[i],"</extra>"),
            ##hovertemplate = "%{y}",
            marker = list(color=klrpal[i])) %>%
            layout(
                showlegend = FALSE,
                annotations = anntitle(colnames(rho)[i]),
                ##annotations = list(text="TITLE"),
                xaxis = list(range = c(0,1),
                             titlefont = list(size=11),
                             tickfont = list(size=10),
                             showgrid=FALSE,
                             title = "correlation (R)" ),
                yaxis = list(title = "",
                             showgrid = FALSE,
                             showline = FALSE,
                             showticklabels = FALSE,
                             showgrid=FALSE,
                             zeroline = FALSE)
            ) %>%
            ## labeling the y-axis inside bars
            add_annotations(xref = 'paper', yref = 'y',
                            x = 0.01, y = y, xanchor='left',
                            text = shortstring(y,slen), 
                            font = list(size = 11),
                            showarrow = FALSE, align = 'right') 
    }

    if(length(plot_list) <= 4) {
        nrows = ceiling(length(plot_list)/2 )
    } else {
        nrows = ceiling(length(plot_list)/3 )
    }
    
    subplot( plot_list, nrows=nrows, shareX=TRUE,
            ## template = "plotly_dark",
            margin=c(0, 0.0, 0.05, 0.05) )
    
})

clustannot_plots_opts = tagList(
    tipify( selectInput("xann.level", "Reference level:",
                        choices=c("gene","geneset","phenotype"), selected="geneset", width='80%'),
           "Select the level of an anotation analysis.",
           placement="left", options = list(container = "body")),
    tipify( selectInput("xann.refset", "Reference set:", choices="", width='80%'),
            "Specify a reference set to be used in the annotation.",
           placement="left",options = list(container = "body"))
)

clustannot_plots_module <- plotModule(
    id="clustannot_plots",
    ##func=clustannot_plots.RENDER, plotlib = "base",
    func=clustannot_plots.PLOTLY, plotlib="plotly",
    download.fmt = c("png","pdf","html"),
    info.text = clustannot_plots_text,
    options = clustannot_plots_opts,
    pdf.width=8, pdf.height=5, res=80,
    title="Functional annotation of clusters", label="a"
)
output <- attachModule(output, clustannot_plots_module)

    
clustannot_table.RENDER <- reactive({

    cat("<clustering:clustannot_table.RENDER> called\n")
    
    rho = getClustannotCorrelation()
    if(is.null(rho)) return(NULL)

    cat("<clustering:clustannot_table.RENDER> dim(rho)=",dim(rho),"\n")
        
    ##rownames(rho) = shortstring(rownames(rho),50)
    rho.name = shortstring(sub(".*:","",rownames(rho)),60)
    ##rho = data.frame(cbind( name=rho.name, rho))
    df = data.frame( feature=rho.name, round(as.matrix(rho),digits=3))
    rownames(df) = rownames(rho)
    if(input$xann.level=="geneset") {
        df$feature <- wrapHyperLink(df$feature, rownames(df))
    }

    cat("<clustering:clustannot_table.RENDER> dim(df)=",dim(df),"\n")
    
    DT::datatable(
            df, rownames=FALSE, escape = c(-1,-2),
            extensions = c('Buttons','Scroller'),
            selection=list(mode='single', target='row', selected=c(1)),
            class = 'compact cell-border stripe hover',
            options=list(
                dom = 'lfrtip', buttons = c('copy','csv','pdf'),
                ##pageLength = 20,##  lengthMenu = c(20, 30, 40, 60, 100, 250),
                scrollX = TRUE, ##scrollY = TRUE,
                scrollY = 200, scroller=TRUE, deferRender=TRUE
            )  ## end of options.list 
        ) %>%
        DT::formatStyle(0, target='row', fontSize='11px', lineHeight='70%') 
})

clustannot_table_info_text = "In this table, users can check mean correlation values of features in the clusters with respect to the annotation references database selected in the settings."

clustannot_table_module <- tableModule(
    id = "clustannot_table", func = clustannot_table.RENDER,
    info.text = clustannot_table_info_text,
    title="Annotation scores", label="b"
)
output <- attachModule(output, clustannot_table_module)

fillCol(
    flex = c(1.7,0.05,1),
    moduleWidget(clustannot_plots_module, outputFunc="plotlyOutput"),
    br(),
    moduleWidget(clustannot_table_module, outputFunc="dataTableOutput")
)

```

> **Cluster annotation.** Functional annotation for the gene clusters using **`r renderText(input$xann.refset)`**. **(a)** Top ranked annotation features (by correlation) for each gene cluster. Length of the bar corresponds to its average correlation. **(b)** Table of average correlation values of annotation features, for each gene cluster.


### Phenotypes {data-height=800}

```{r}

clust_phenoplot.RENDER <- reactive({
    ##if(!input$tsne.all) return(NULL)
    require(RColorBrewer)
   
    ngs <- inputData()
    req(ngs)
    
    ## get t-SNE positions
    clust <- hm_getClusterPositions()
    ##pos = ngs$tsne2d
    pos = clust$pos
    Y <- ngs$Y[rownames(pos),,drop=FALSE]
    pheno = colnames(Y)    

    ## don't show these...
    pheno <- grep("batch|sample|donor|repl|surv",pheno,
                  invert=TRUE, ignore.case=TRUE,value=TRUE)
        
    ## layout
    par(mfrow = c(3,2), mar=c(0.3,0.7,2.8,0.7))
    if(length(pheno)>=6) par(mfrow = c(4,3), mar=c(0.3,0.4,2.8,0.4)*0.8)
    if(length(pheno)>=12) par(mfrow = c(5,4), mar=c(0.2,0.2,2.5,0.2)*0.8)
    i=1    

    cex1 <- 1.3*c(1.8,1.3,0.8,0.5)[cut(nrow(pos),breaks=c(-1,40,200,1000,1e10))]    
    cex1 = cex1 * ifelse(length(pheno)>6, 0.8, 1)
    cex1 = cex1 * ifelse(length(pheno)>12, 0.8, 1)
    
    require(RColorBrewer)
    for(i in 1:min(20,length(pheno))) {

        ## ------- set colors
        colvar = factor(Y[,1])
        colvar = factor(Y[,pheno[i]])
        colvar[which(colvar %in% c(NA,""," ","NA","na"))] <- NA
        colvar = factor(as.character(colvar))
        klrpal = COLORS  
        klr1 = klrpal[colvar]
        klr1 = paste0(col2hex(klr1),"99")
        jj = which(is.na(klr1))
        if(length(jj)) klr1[jj] <- "#AAAAAA22"
        tt = tolower(pheno[i])

        ## ------- start plot
        plot( pos[,], pch=19, cex=cex1, col=klr1,
             fg = gray(0.5), bty = "o", xaxt='n', yaxt='n',
             xlab="tSNE1", ylab="tSNE2")
        title( tt, cex.main=1.3, line=0.5, col="grey40")
        if(input$clust_phenoplot_labelmode=="legend") {
            legend("bottomright", legend=levels(colvar), fill=klrpal,
                   cex=0.95, y.intersp=0.85, bg="white")
        } else {
            grp.pos <- apply(pos,2,function(x) tapply(x,colvar,mean,na.rm=TRUE))
            grp.pos <- apply(pos,2,function(x) tapply(x,colvar,median,na.rm=TRUE))
            nvar <- length(setdiff(colvar,NA))
            if(nvar==1) {
                grp.pos <- matrix(grp.pos,nrow=1)
                rownames(grp.pos) <- setdiff(colvar,NA)[1]
            }
            labels = rownames(grp.pos)
            boxes = sapply(nchar(labels),function(n) paste(rep("\u2588",n),collapse=""))
            cex2 = 0.99*cex1**0.33
            text( grp.pos, labels=boxes, cex=cex2*0.95, col="#CCCCCC99")
            text( grp.pos, labels=labels, font=2, cex=cex2)
        }
    }    
})

clust_phenoplot.opts = tagList(
    radioButtons('clust_phenoplot_labelmode',"Label",c("groups","legend"),inline=TRUE)
)

clust_phenoplot.module <- plotModule(
    "clust_phenoplot", clust_phenoplot.RENDER, ## plotlib="base",
    info.text = tagsub("<strong>Phenotype distribution.</strong> This figure visualizes the distribution of the available phenotype data. You can choose to put the group labels in the figure or as separate legend in the {Label} setting, in the plot {{settings}}"),
    options = clust_phenoplot.opts,
    pdf.width=6, pdf.height=9, res=85
)
output <- attachModule(output, clust_phenoplot.module)

fillCol(
    moduleWidget(clust_phenoplot.module)
)

```


> **Phenotype distribution.** The plots show the distribution of the phenotypes superposed on the t-SNE clustering. Often, we can expect the t-SNE distribution to be driven by the particular phenotype that is controlled by the experimental condition or unwanted batch effects.


### Feature ranking

```{r warnings=FALSE, message=FALSE, fig.width=6, fig.height=6}
require(plotly)

clust_featureRank.RENDER <- reactive({
    ngs <- inputData()
    req(ngs)

    features=X=NULL
    if(input$hm_level=="geneset") {
        features = COLLECTIONS
        X = ngs$gsetX
    } else {
        features = ngs$families
        X = ngs$X
    }

    ## ------------ intersect features, set minimum set size
    features <- lapply(features, function(f) intersect(f,rownames(X)))
    features <- features[sapply(features,length) >=10 ]
    
    ## ------------ Just to get current samples
    samples = hm_filtered_matrix()$samples    
    X = X[,samples]
    cvar <- pgx.getCategoricalPhenotypes(ngs$Y)
    cvar = grep("group|sample|patient|years|days|months|gender",
              cvar,invert=TRUE,value=TRUE) ## no sample IDs
    cvar
    Y = ngs$Y[colnames(X),cvar,drop=FALSE]
    kk = which(apply(Y,2,function(y) length(unique(y))>1))
    Y = Y[,kk,drop=FALSE]
    dim(Y)
    
    ## ------------ Note: this takes a while. Maybe better precompute off-line...
    sdx = apply(X,1,sd)
    names(sdx) = rownames(X)
    S = matrix(NA, nrow=length(features), ncol=ncol(Y))
    rownames(S) = names(features)
    colnames(S) = colnames(Y)

    ## ------------ Create a Progress object
    progress <- shiny::Progress$new()
    on.exit(progress$close())    
    progress$set(message = "Calculating feature-set scores", value = 0)
    
    gene.level = TRUE
    gene.level = (input$hm_level=="gene")
    i=1
    for(i in 1:ncol(Y)) {

        progress$inc(1/ncol(Y))

        grp = Y[,i]
        grp = as.character(grp)
        score = rep(NA, length(features))
        names(score) = names(features)
        j=1
        for(j in 1:length(features)) {
            pp = features[[j]]
            if(gene.level) {
                pp = filterProbes(ngs$genes, features[[j]])
            }
            pp = head(pp[order(-sdx[pp])],1000)  ## how many top SD??
            pp = intersect(pp, rownames(X))
            X1 = X[pp,,drop=FALSE]
            dim(X1)
            ##cat("<clust_featureRank> dim(X1)=",dim(X1),"\n")
            ##if( nrow(X1) 
            
            s1 = s2 = 1
            method = input$clust_featureRank_method
            if(method %in% c("correlation","meta")) {
                mx = t(apply(X1, 1, function(x) tapply(x,grp,mean)))
                if(nrow(mx)==0 || ncol(mx)==0) next
                D = 1 - cor(mx, use="pairwise")
                diag(D) = NA
                s1 = mean(D,na.rm=TRUE)
            }

            if(method %in% c("p-value","meta")) {
                jj  <- which(!is.na(grp))
                design = model.matrix( ~ grp[jj])
                suppressWarnings( fit <- eBayes(lmFit( X1[,jj], design)) )
                suppressWarnings( suppressMessages( top <- topTable(fit) ))
                ##s2 = mean(-log10(top$P.Value))  ## as score
                s2 = mean(-log10(top$adj.P.Val),na.rm=TRUE)  ## as score
            }
            
            f = 1
            f <- (1 - exp(-(length(pp)/20)**2)) ## penalize smaller sets
            score[j] = f * (s1 * s2) ** ifelse(method=="meta",0.5,1)
            
        }
        S[,i] = score
    }

    if(is.null(S) || nrow(S)==0 || ncol(S)==0 ) return(NULL)

    ## top scoring
    S = tail( S[order(rowSums(S)),,drop=FALSE], 35)  

    par(mfrow=c(2,1), mar=c(1,5,3,3) )
    par(mfrow=c(1,2), mar=c(5,5,3,2), oma=c(6,0,4,0)); frame()
    ## par(mfrow=c(1,1), mar=c(10,5,3,3) )
    rownames(S) = substring(rownames(S),1,80)
    bpos = barplot( t(S), beside=FALSE, las=1,
                   cex.names=0.9, horiz=TRUE,
                   xlab="discriminant score" )
    ##title("feature-set score", cex=1.3)
    cc1 = grey.colors(ncol(Y))
    legend("bottomright",legend=colnames(Y), fill=cc1,
           cex=0.8, y.intersp=0.8, inset=c(0,0.035), bg="white")
    
})


clust_featureRank_info = "Ranked discriminant score for top feature sets. The plot ranks the discriminitive power of the feature set (genes) as a cumulative discriminant score for all phenotype variables. In this way, we can find which feature set (or gene family/set) can explain the variance in the data the best. <p>Correlation-based discriminative power is calculated as the average '(1-cor)' between the groups. Thus, a feature set is highly discriminative if the between-group correlation is low. P-value based scoring is computed as the average negative log p-value from the ANOVA. The 'meta' method combines the score of the former methods in a multiplicative manner."

clust_featureRank.opts =  tagList(
    tipify( radioButtons('clust_featureRank_method','Method:',
                         choices=c("p-value","correlation","meta"),
                         inline=TRUE),
           "Choose ranking method: p-value based or correlation-based.",
           placement="right", options = list(container = "body") )
)

clust_featureRank_module <- plotModule(
    title="Feature-set ranking",
    id="clust_featureRank", func=clust_featureRank.RENDER,
    info.text = clust_featureRank_info,
    options = clust_featureRank.opts,
    pdf.width=8, pdf.height=10, res=72
)
output <- attachModule(output, clust_featureRank_module)

require(shinycssloaders)
fillCol(
    moduleWidget(clust_featureRank_module)
)

```

> **Feature-set ranking.** Ranked discriminant score for top feature sets. The plot ranks the discriminative power of feature sets (or gene sets) as the cumulative discriminant score for all phenotype variables. 
